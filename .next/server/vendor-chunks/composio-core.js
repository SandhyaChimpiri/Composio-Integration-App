/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/composio-core";
exports.ids = ["vendor-chunks/composio-core"];
exports.modules = {

/***/ "(rsc)/./node_modules/composio-core/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/composio-core/constants.js ***!
  \*************************************************/
/***/ ((module) => {

eval("const APPS = {\n  // apps list start here\n  // apps list end here\n};\n\nconst ACTIONS = {\n  // actions list start here\n  // actions list end here\n};\n\nconst COMPOSIO_VERSION = `0.5.35`;\n\nmodule.exports = {\n  APPS,\n  ACTIONS,\n  COMPOSIO_VERSION,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY29tcG9zaW8tY29yZS9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pblxcT25lRHJpdmVcXERlc2t0b3BcXGNvbXBvLWFwcFxcaW50ZWdyYXRpb24tY29tcG9zaW9cXGNvbXBvc2lvLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxjb21wb3Npby1jb3JlXFxjb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQVBQUyA9IHtcbiAgLy8gYXBwcyBsaXN0IHN0YXJ0IGhlcmVcbiAgLy8gYXBwcyBsaXN0IGVuZCBoZXJlXG59O1xuXG5jb25zdCBBQ1RJT05TID0ge1xuICAvLyBhY3Rpb25zIGxpc3Qgc3RhcnQgaGVyZVxuICAvLyBhY3Rpb25zIGxpc3QgZW5kIGhlcmVcbn07XG5cbmNvbnN0IENPTVBPU0lPX1ZFUlNJT04gPSBgMC41LjM1YDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEFQUFMsXG4gIEFDVElPTlMsXG4gIENPTVBPU0lPX1ZFUlNJT04sXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/composio-core/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/composio-core/index.js":
/*!*********************************************!*\
  !*** ./node_modules/composio-core/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nvar axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nvar uuid = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nvar z = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nvar clientAxios = __webpack_require__(/*! @hey-api/client-axios */ \"(rsc)/./node_modules/@hey-api/client-axios/dist/index.cjs\");\nvar zodToJsonSchema = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/cjs/index.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar pathModule = __webpack_require__(/*! path */ \"path\");\nvar tools = __webpack_require__(/*! @langchain/core/tools */ \"(rsc)/./node_modules/@langchain/core/tools.cjs\");\nvar ai = __webpack_require__(/*! ai */ \"(rsc)/./node_modules/ai/dist/index.js\");\n\nconst COMPOSIO_VERSION = `0.5.35`;\n\nconst getUUID = () => {\n    return uuid.v4();\n};\n\nfunction jsonSchemaPropertiesToTSTypes(value) {\n    if (!value.type) {\n        return z.object({});\n    }\n    let zodType;\n    switch (value.type) {\n        case \"string\":\n            zodType = z\n                .string()\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"number\":\n            zodType = z\n                .number()\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"integer\":\n            zodType = z\n                .number()\n                .int()\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"boolean\":\n            zodType = z\n                .boolean()\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"array\":\n            zodType = z\n                .array(jsonSchemaPropertiesToTSTypes(value.items))\n                .describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"object\":\n            zodType = jsonSchemaToModel(value).describe((value.description || \"\") +\n                (value.examples ? `\\nExamples: ${value.examples.join(\", \")}` : \"\"));\n            break;\n        case \"null\":\n            zodType = z.null().describe(value.description || \"\");\n            break;\n        default:\n            throw new Error(`Unsupported JSON schema type: ${value.type}`);\n    }\n    return zodType;\n}\nfunction jsonSchemaToModel(jsonSchema) {\n    const properties = jsonSchema.properties;\n    const requiredFields = jsonSchema.required || [];\n    if (!properties) {\n        return z.object({});\n    }\n    const zodSchema = {};\n    for (const [key, _] of Object.entries(properties)) {\n        const value = _;\n        let zodType;\n        if (value.anyOf) {\n            const anyOfTypes = value.anyOf.map((schema) => jsonSchemaPropertiesToTSTypes(schema));\n            zodType = z\n                .union(anyOfTypes)\n                .describe((value.description || \"\") +\n                (value.examples\n                    ? `\\nExamples: ${value.examples.join(\", \")}`\n                    : \"\"));\n        }\n        else if (value.allOf) {\n            const allOfTypes = value.allOf.map((schema) => jsonSchemaPropertiesToTSTypes(schema));\n            zodType = z\n                .intersection(allOfTypes[0], allOfTypes\n                .slice(1)\n                .reduce((acc, schema) => acc.and(schema), allOfTypes[0]))\n                .describe((value.description || \"\") +\n                (value.examples\n                    ? `\\nExamples: ${value.examples.join(\", \")}`\n                    : \"\"));\n        }\n        else {\n            if (!value.type) {\n                value.type = \"string\";\n            }\n            zodType = jsonSchemaPropertiesToTSTypes(value);\n        }\n        if (value.description) {\n            zodType = zodType.describe(value.description);\n        }\n        if (requiredFields.includes(key)) {\n            zodSchema[key] = zodType;\n        }\n        else {\n            zodSchema[key] = zodType.optional();\n        }\n    }\n    return z.object(zodSchema);\n}\nconst getEnvVariable = (name, defaultValue = undefined) => {\n    try {\n        return process.env[name] || defaultValue;\n    }\n    catch (_e) {\n        return defaultValue;\n    }\n};\n\n// Define log levels with corresponding priorities\nconst LOG_LEVELS = {\n    silent: -1, // No logs\n    error: 0, // Highest priority - critical errors\n    warn: 1, // Warning messages\n    info: 2, // General information\n    debug: 3, // Debug information\n};\n/**\n * Get the current log level from environment variables.\n * Defaults to 'info' if not set or invalid.\n * @returns {keyof typeof LOG_LEVELS} The current log level\n */\nconst getLogLevel = () => {\n    var _a;\n    const envLevel = (_a = getEnvVariable(\"COMPOSIO_LOGGING_LEVEL\", \"info\")) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n    return envLevel && envLevel in LOG_LEVELS\n        ? envLevel\n        : \"info\";\n};\nconst addTimestampToMessage = (message) => {\n    const timestamp = new Date().toISOString();\n    return `${timestamp} - ${message}`;\n};\nconst formatErrorMessage = (args) => {\n    return args\n        .map((arg) => (typeof arg === \"object\" ? JSON.stringify(arg) : arg))\n        .join(\" \");\n};\nconst getLogger = () => {\n    const logger = console;\n    const loggingLevel = getLogLevel();\n    const logLevelValue = LOG_LEVELS[loggingLevel];\n    const noop = () => { };\n    return {\n        error: logLevelValue >= LOG_LEVELS.error\n            ? (...args) => logger.error(addTimestampToMessage(formatErrorMessage(args)))\n            : noop,\n        warn: logLevelValue >= LOG_LEVELS.warn\n            ? (...args) => logger.warn(addTimestampToMessage(formatErrorMessage(args)))\n            : noop,\n        info: logLevelValue >= LOG_LEVELS.info\n            ? (...args) => logger.info(addTimestampToMessage(formatErrorMessage(args)))\n            : noop,\n        debug: logLevelValue >= LOG_LEVELS.debug\n            ? (...args) => logger.debug(addTimestampToMessage(formatErrorMessage(args)))\n            : noop,\n    };\n};\nvar logger = getLogger();\n\nconst ZAuthMode = z.z.enum([\n    \"OAUTH2\",\n    \"OAUTH1\",\n    \"OAUTH1A\",\n    \"API_KEY\",\n    \"BASIC\",\n    \"BEARER_TOKEN\",\n    \"GOOGLE_SERVICE_ACCOUNT\",\n    \"NO_AUTH\",\n    \"BASIC_WITH_JWT\",\n]);\nconst ZCreateIntegrationParams = z.z.object({\n    name: z.z.string(),\n    authScheme: ZAuthMode.optional(),\n    appUniqueKey: z.z.string().optional(),\n    appId: z.z.string().optional(),\n    forceNewIntegration: z.z.boolean().optional(),\n    authConfig: z.z\n        .union([\n        z.z.record(z.z.unknown()),\n        z.z.object({\n            client_id: z.z.string(),\n            client_secret: z.z.string(),\n            api_key: z.z.string(),\n            consumer_key: z.z.string(),\n            consumer_secret: z.z.string(),\n            base_url: z.z.string(),\n        }),\n    ])\n        .optional(),\n    useComposioAuth: z.z.boolean().optional(),\n});\nconst ZSingleIntegrationParams = z.z.object({\n    integrationId: z.z.string(),\n});\nconst ZListIntegrationsParams = z.z.object({\n    page: z.z.number().optional(),\n    pageSize: z.z.number().optional(),\n    appName: z.z.string().optional(),\n    appUniqueKey: z.z.string().optional(),\n    showDisabled: z.z.boolean().optional(),\n});\n\nconst ZExecuteActionParams$1 = z.z.object({\n    actionName: z.z.string(),\n    params: z.z.record(z.z.any()).optional(),\n    text: z.z.string().optional(),\n    connectedAccountId: z.z.string().optional(),\n});\nconst ZInitiateConnectionParams = z.z.object({\n    appName: z.z.string().optional(),\n    authConfig: z.z.record(z.z.any()).optional(),\n    integrationId: z.z.string().optional(),\n    authMode: ZAuthMode.optional(),\n    connectionParams: z.z.record(z.z.any()).optional(),\n    config: z.z\n        .object({\n        labels: z.z.array(z.z.string()).optional(),\n        redirectUrl: z.z.string().optional(),\n    })\n        .optional(),\n    redirectUri: z.z.string().optional(),\n    labels: z.z.array(z.z.string()).optional(),\n});\nconst ZConnectionParams = z.z.object({\n    connectedAccountId: z.z.string().optional(),\n    app: z.z.string().optional(),\n});\nconst ZTriggerSubscribeParam = z.z.object({\n    app: z.z.string().optional(),\n    appName: z.z.string().optional(),\n    triggerName: z.z.string(),\n    config: z.z.record(z.z.any()),\n});\n\n// Helper function to stringify objects if needed\nconst serializeValue = (obj) => {\n    return typeof obj === \"object\" ? JSON.stringify(obj) : obj;\n};\n\n// Constants\nconst COMPOSIO_DIR = \".composio\";\nconst USER_DATA_FILE_NAME = \"user_data.json\";\nconst TEMP_FILES_DIRECTORY_NAME = \"files\";\nconst DEFAULT_BASE_URL = \"https://backend.composio.dev\";\nconst TELEMETRY_URL = \"https://app.composio.dev\";\nconst IS_DEVELOPMENT_OR_CI = process.env.DEVELOPMENT || process.env.CI || false;\n\n/**\n * Sends a reporting payload to the telemetry server using a child process.\n * This function is intended for use in Node.js environments.\n *\n * @param {any} reportingPayload - The payload to be sent to the telemetry server.\n */\nfunction sendProcessReq(info) {\n    if (IS_DEVELOPMENT_OR_CI) {\n        logger.debug(`Hitting ${info.url}[${info.method}] with ${serializeValue(info.data)}`);\n        return true;\n    }\n    try {\n        const url = new URL(info.url);\n        const protocol = url.protocol === \"https:\" ? \"https\" : \"http\";\n        const port = url.port || (url.protocol === \"https:\" ? 443 : 80);\n        const args = [\n            \"-e\",\n            `\n      const http = require('${protocol}');\n      const options = {\n        hostname: '${url.hostname}',\n        path: '${url.pathname}${url.search}',\n        port: ${port},\n        method: '${info.method}',\n        headers: ${JSON.stringify(info.headers)}\n      };\n\n      const req = http.request(options, (res) => {\n        res.on('data', () => {});\n        res.on('end', () => {\n          process.exit(0);\n        });\n      });\n\n      req.on('error', () => {\n        process.exit(0);\n      });\n\n      req.write(JSON.stringify(${JSON.stringify(info.data)}));\n      req.end();\n      `,\n        ];\n        // Use spawn with detached option instead of spawnSync to make it non-blocking\n        const { spawn } = __webpack_require__(/*! child_process */ \"child_process\");\n        spawn(\"node\", args, {\n            stdio: \"ignore\",\n            detached: true,\n            shell: false,\n        }).unref();\n        return true;\n    }\n    catch (error) {\n        logger.debug(\"Error sending error to telemetry\", error);\n        // DO NOTHING\n    }\n}\n/**\n * Sends a reporting payload to the telemetry server using XMLHttpRequest.\n * This function is intended for use in browser environments.\n *\n * @param {any} reportingPayload - The payload to be sent to the telemetry server.\n */\nfunction sendBrowserReq(info) {\n    if (IS_DEVELOPMENT_OR_CI) {\n        logger.debug(`Hitting ${info.url}[${info.method}] with ${serializeValue(info.data)}`);\n        return true;\n    }\n    try {\n        // Create a new XMLHttpRequest object\n        const xhr = new XMLHttpRequest();\n        // Open a new POST request to the telemetry server\n        xhr.open(info.method, info.url, true);\n        // Set the request header to indicate JSON content\n        xhr.setRequestHeader(\"Content-Type\", \"application/json\");\n        Object.entries(info.headers || {}).forEach(([key, value]) => {\n            xhr.setRequestHeader(key, value);\n        });\n        // Define the onload event handler\n        xhr.onload = function () {\n            // Log the response if the request was successful\n            if (xhr.status === 200) {\n                logger.debug(xhr.response);\n            }\n        };\n        // Send the reporting payload as a JSON string\n        xhr.send(JSON.stringify(info.data));\n    }\n    catch (error) {\n        logger.debug(\"Error sending error to telemetry\", error);\n        // DO NOTHING\n    }\n}\n\n/*\n    ComposioContext class provides a global context for storing SDK configuration.\n    This singleton class maintains essential SDK settings like API key and base URL.\n    It is used to store the API key and base URL in a global context so that it can be accessed by other modules without having to pass the configuration around.\n\n    Warning: Can cause problems if there are multiple instances of the SDK running in the same process.\n*/\nclass ComposioSDKContext {\n}\nComposioSDKContext.source = \"javascript\";\n\nasync function logError(payload) {\n    const isTelemetryDisabled = getEnvVariable(\"TELEMETRY_DISABLED\", \"false\") === \"true\";\n    if (isTelemetryDisabled) {\n        return;\n    }\n    try {\n        const isBrowser = typeof window !== \"undefined\";\n        const reportingPayload = generateReportingPayload(payload);\n        const reqPayload = {\n            data: reportingPayload,\n            url: `${TELEMETRY_URL}/api/sdk_metrics/error`,\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n        };\n        if (isBrowser) {\n            await sendBrowserReq(reqPayload);\n        }\n        else {\n            await sendProcessReq(reqPayload);\n        }\n    }\n    catch (error) {\n        logger.debug(\"Error sending error to telemetry\", error);\n        // DO NOTHING\n    }\n}\nfunction generateReportingPayload(payload) {\n    const { apiKey, baseURL, composioVersion, frameworkRuntime, source } = ComposioSDKContext;\n    const { error_id, error_code, description, message, possible_fix, original_error, current_stack, } = payload;\n    return {\n        error_id,\n        error_code,\n        description,\n        error_message: message,\n        possible_fix,\n        original_error,\n        current_stack,\n        sdk_meta: {\n            platform: process.platform,\n            version: composioVersion,\n            baseURL,\n            apiKey,\n            frameworkRuntime,\n            source,\n        },\n    };\n}\n\n/**\n * Custom error class for Composio that provides rich error details, tracking, and improved debugging\n */\nclass ComposioError extends Error {\n    constructor(errCode, message, description, possibleFix, metadata, originalError) {\n        var _a;\n        // Ensure message is never empty\n        super(message || \"An unknown error occurred\");\n        // additional metadata about the error\n        this.metadata = {};\n        // Ensure proper prototype chain for instanceof checks\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.name = \"ComposioError\";\n        this.errCode = errCode;\n        this.description = description;\n        this.possibleFix = possibleFix;\n        this.timestamp = new Date().toISOString();\n        this.metadata = metadata;\n        this.errorId = getUUID();\n        let originalErrorString = \"\";\n        // Only print original error if COMPOSIO_LOGGING_LEVEL is debug\n        if (originalError) {\n            try {\n                originalErrorString =\n                    typeof originalError === \"object\"\n                        ? JSON.parse(JSON.stringify(originalError))\n                        : originalError;\n            }\n            catch (_e) {\n                originalErrorString = String(originalError);\n            }\n            if (getLogLevel() === \"debug\") {\n                this._originalError = originalErrorString;\n            }\n        }\n        // Only in case of info or debug, we will log the error\n        if (LOG_LEVELS[getLogLevel()] >= 2) {\n            logger.info(`🚀 [Info] Give Feedback / Get Help: https://dub.composio.dev/discord `);\n            logger.info(`🐛 [Info] Create a new issue: https://github.com/ComposioHQ/composio/issues `);\n            if (getLogLevel() !== \"debug\") {\n                logger.info(`⛔ [Info] If you need to debug this error, set env variable COMPOSIO_LOGGING_LEVEL=debug`);\n            }\n        }\n        logError({\n            error_id: this.errorId,\n            error_code: this.errCode,\n            original_error: originalErrorString,\n            description: this.description || \"\",\n            metadata: this.metadata || {},\n            message: this.message,\n            possible_fix: this.possibleFix || \"\",\n            current_stack: ((_a = this.stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\")) || [],\n        });\n        // Capture stack trace, excluding constructor call\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get originalError() {\n        return this._originalError;\n    }\n    /**\n     * Returns a complete object representation for logging/serialization\n     * Includes all error details and metadata\n     */\n    toJSON() {\n        var _a, _b, _c;\n        const errorObj = {\n            name: this.name,\n            errorId: this.errorId,\n            code: this.errCode,\n            message: this.message,\n            description: this.description,\n            possibleFix: this.possibleFix,\n            timestamp: this.timestamp,\n            stack: (_a = this.stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\"),\n            originalStack: (_c = (_b = this.originalError) === null || _b === void 0 ? void 0 : _b.stack) === null || _c === void 0 ? void 0 : _c.split(\"\\n\"),\n        };\n        // Remove undefined/null properties\n        return Object.entries(errorObj).reduce((acc, [key, value]) => {\n            if (value !== undefined && value !== null) {\n                acc[key] = value;\n            }\n            return acc;\n        }, {});\n    }\n}\n\nconst COMPOSIO_SDK_ERROR_CODES = {\n    BACKEND: {\n        NOT_FOUND: \"BACKEND::NOT_FOUND\",\n        RATE_LIMIT: \"BACKEND::RATE_LIMIT\",\n        BAD_REQUEST: \"BACKEND::BAD_REQUEST\",\n        UNAUTHORIZED: \"BACKEND::UNAUTHORIZED\",\n        SERVER_ERROR: \"BACKEND::SERVER_ERROR\",\n        SERVER_UNAVAILABLE: \"BACKEND::SERVER_UNAVAILABLE\",\n        SERVER_UNREACHABLE: \"BACKEND::SERVER_UNREACHABLE\",\n        UNKNOWN: \"BACKEND::UNKNOWN\",\n    },\n    COMMON: {\n        API_KEY_UNAVAILABLE: \"COMMON::API_KEY_INVALID\",\n        BASE_URL_NOT_REACHABLE: \"COMMON::BASE_URL_NOT_REACHABLE\",\n        UNKNOWN: \"COMMON::ERROR_CODE_NOT_DEFINED\",\n        SERVER_UNAVAILABLE: \"COMMON::SERVER_UNAVAILABLE\",\n        REQUEST_TIMEOUT: \"COMMON::REQUEST_TIMEOUT\",\n        REQUEST_ABORTED: \"COMMON::REQUEST_ABORTED\",\n        INVALID_PARAMS_PASSED: \"COMMON::INVALID_PARAMS_PASSED\",\n    },\n    SDK: {\n        NO_CONNECTED_ACCOUNT_FOUND: \"SDK::NO_CONNECTED_ACCOUNT_FOUND\",\n        FAILED_TO_INITIATE_CONNECTION: \"SDK::FAILED_TO_INITIATE_CONNECTION\",\n        INVALID_PARAMETER: \"SDK::INVALID_PARAMETER\",\n    },\n};\nconst BASE_ERROR_CODE_INFO = {\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND]: {\n        message: \"🔍 API not found\",\n        description: \"The requested resource is missing\",\n        possibleFix: \"Ensure the resource id or resource identifier is correct and valid as backend returned 404\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.BAD_REQUEST]: {\n        message: \"🚫 Bad Request. The request was malformed or incorrect\",\n        description: null,\n        possibleFix: \"Check your parameters and request format, as the backend returned a 400 error.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.UNAUTHORIZED]: {\n        message: \"🔑 Access Denied\",\n        description: \"You do not have the necessary credentials.\",\n        possibleFix: \"Ensure your API key is correct and has the required permissions.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.COMMON.REQUEST_TIMEOUT]: {\n        message: \"🕒 Request Timeout\",\n        description: \"The request timed out while waiting for a response.\",\n        possibleFix: \"Please try again later. If the issue persists, contact support or check your network connection.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_ERROR]: {\n        message: \"💥 Oops! Internal server error\",\n        description: \"Your request could not be processed due to an internal server error.\",\n        possibleFix: \"Please try again later. If the issue persists, contact support.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.RATE_LIMIT]: {\n        message: \"⏱️ API Rate Limit Exceeded\",\n        description: \"You have exceeded the rate limit for requests.\",\n        possibleFix: \"Please wait a bit before trying your request again.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.COMMON.API_KEY_UNAVAILABLE]: {\n        message: \"🔑 API Key Missing or Invalid\",\n        description: \"The API key provided is missing or incorrect.\",\n        possibleFix: \"Ensure that your API key is passed to client or set in COMPOSIO_API_KEY environment variable.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNAVAILABLE]: {\n        message: \"🚫 Server Unavailable\",\n        description: \"The server is currently unable to handle the request.\",\n        possibleFix: \"Please try again later. If the issue persists, contact support.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.COMMON.BASE_URL_NOT_REACHABLE]: {\n        message: \"🔗 Base URL is not valid\",\n        description: \"The base URL provided is not valid.\",\n        possibleFix: \"Ensure that the base URL is correct and accessible.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED]: {\n        message: \"🕒 Invalid parameters passed\",\n        description: \"The parameters passed are invalid\",\n        possibleFix: \"Please check the error message for more details\",\n    },\n    UNKNOWN: {\n        message: null,\n        description: null,\n        possibleFix: \"Contact our support team with the error details for further assistance.\",\n    },\n    [COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN]: {\n        message: null,\n        description: null,\n        possibleFix: \"Contact our support team with the error details for further assistance.\",\n    },\n};\nconst API_TO_SDK_ERROR_CODE = {\n    400: COMPOSIO_SDK_ERROR_CODES.BACKEND.BAD_REQUEST,\n    401: COMPOSIO_SDK_ERROR_CODES.BACKEND.UNAUTHORIZED,\n    404: COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND,\n    408: COMPOSIO_SDK_ERROR_CODES.COMMON.REQUEST_TIMEOUT,\n    429: COMPOSIO_SDK_ERROR_CODES.BACKEND.RATE_LIMIT,\n    500: COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_ERROR,\n    502: COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNAVAILABLE,\n};\n\nconst getAPIErrorDetails = (axiosError) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;\n    const statusCode = (_a = axiosError.response) === null || _a === void 0 ? void 0 : _a.status;\n    const errorCode = statusCode\n        ? API_TO_SDK_ERROR_CODE[statusCode]\n        : COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN;\n    const predefinedError = BASE_ERROR_CODE_INFO[errorCode];\n    const defaultErrorDetails = {\n        message: axiosError.message,\n        description: ((_c = (_b = axiosError === null || axiosError === void 0 ? void 0 : axiosError.response) === null || _b === void 0 ? void 0 : _b.data) === null || _c === void 0 ? void 0 : _c.message) || axiosError.message,\n        possibleFix: \"Please check the parameters you are passing to the API\",\n    };\n    const metadata = generateMetadataFromAxiosError(axiosError);\n    const errorNameFromBE = (_e = (_d = axiosError === null || axiosError === void 0 ? void 0 : axiosError.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.name;\n    const errorTypeFromBE = (_g = (_f = axiosError === null || axiosError === void 0 ? void 0 : axiosError.response) === null || _f === void 0 ? void 0 : _f.data) === null || _g === void 0 ? void 0 : _g.type;\n    const errorMessage = (_j = (_h = axiosError === null || axiosError === void 0 ? void 0 : axiosError.response) === null || _h === void 0 ? void 0 : _h.data) === null || _j === void 0 ? void 0 : _j.message;\n    let genericMessage = \"\";\n    const hasNotReceivedResponseFromBE = errorCode === COMPOSIO_SDK_ERROR_CODES.BACKEND.UNAUTHORIZED ||\n        errorCode === COMPOSIO_SDK_ERROR_CODES.BACKEND.RATE_LIMIT ||\n        errorCode === COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNAVAILABLE ||\n        errorCode === COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNREACHABLE;\n    if (hasNotReceivedResponseFromBE) {\n        genericMessage = predefinedError.message;\n    }\n    else if (((_k = axiosError.config) === null || _k === void 0 ? void 0 : _k.baseURL) && ((_l = axiosError.config) === null || _l === void 0 ? void 0 : _l.url)) {\n        genericMessage = `${errorNameFromBE || predefinedError.message} ${errorTypeFromBE ? `- ${errorTypeFromBE}` : \"\"} on ${((_m = axiosError.config) === null || _m === void 0 ? void 0 : _m.baseURL) + ((_o = axiosError.config) === null || _o === void 0 ? void 0 : _o.url)}`;\n    }\n    switch (errorCode) {\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.BAD_REQUEST:\n            const validationErrors = (_q = (_p = axiosError.response) === null || _p === void 0 ? void 0 : _p.data) === null || _q === void 0 ? void 0 : _q.details;\n            const formattedErrors = Array.isArray(validationErrors)\n                ? validationErrors.map((err) => JSON.stringify(err)).join(\", \")\n                : JSON.stringify(validationErrors);\n            return {\n                message: genericMessage,\n                description: `Validation Errors: ${formattedErrors}`,\n                possibleFix: \"Please check the request parameters and ensure they are correct.\",\n                metadata,\n            };\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.UNAUTHORIZED:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_ERROR:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNAVAILABLE:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.RATE_LIMIT:\n        case COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN:\n            return {\n                message: genericMessage,\n                description: errorMessage || predefinedError.description,\n                possibleFix: predefinedError.possibleFix ||\n                    defaultErrorDetails.possibleFix,\n                metadata,\n            };\n        default:\n            const message = genericMessage || axiosError.message;\n            const description = errorMessage || predefinedError.description;\n            const possibleFix = predefinedError.possibleFix ||\n                defaultErrorDetails.possibleFix ||\n                \"\";\n            return {\n                message,\n                description,\n                possibleFix,\n                metadata,\n            };\n    }\n};\nconst generateMetadataFromAxiosError = (axiosError) => {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const { requestId, ...restMetadata } = axiosError.metadata || {};\n    return {\n        fullUrl: ((_b = (_a = axiosError.config) === null || _a === void 0 ? void 0 : _a.baseURL) !== null && _b !== void 0 ? _b : \"\") + ((_d = (_c = axiosError.config) === null || _c === void 0 ? void 0 : _c.url) !== null && _d !== void 0 ? _d : \"\"),\n        method: ((_f = (_e = axiosError.config) === null || _e === void 0 ? void 0 : _e.method) !== null && _f !== void 0 ? _f : \"\").toUpperCase(),\n        statusCode: (_g = axiosError.response) === null || _g === void 0 ? void 0 : _g.status,\n        requestId: requestId ? `${requestId}` : undefined,\n        metadata: restMetadata,\n    };\n};\n\nclass CEG {\n    static handleAllError(error, shouldThrow = false) {\n        if (error instanceof ComposioError) {\n            if (shouldThrow) {\n                throw error;\n            }\n            return error;\n        }\n        if (!(error instanceof Error)) {\n            const error = new Error(\"Passed error is not an instance of Error\");\n            if (shouldThrow) {\n                throw error;\n            }\n            return error;\n        }\n        if (error instanceof z.ZodError) {\n            const zodError = this.returnZodError(error);\n            if (shouldThrow) {\n                throw zodError;\n            }\n            return zodError;\n        }\n        const isAxiosError = error.isAxiosError;\n        if (!isAxiosError) {\n            const customError = this.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.UNKNOWN, {\n                message: error.message,\n                description: \"\",\n                possibleFix: \"Please check error message and stack trace\",\n                originalError: error,\n                metadata: {},\n            });\n            if (shouldThrow) {\n                throw customError;\n            }\n            return customError;\n        }\n        else {\n            const isResponseNotPresent = !(\"response\" in error);\n            if (isResponseNotPresent) {\n                const nonResponseError = this.handleNonResponseAxiosError(error);\n                if (shouldThrow) {\n                    throw nonResponseError;\n                }\n                return nonResponseError;\n            }\n            const apiError = this.throwAPIError(error);\n            if (shouldThrow) {\n                throw apiError;\n            }\n            return apiError;\n        }\n    }\n    static handleNonResponseAxiosError(error) {\n        var _a, _b;\n        const fullUrl = (((_a = error.config) === null || _a === void 0 ? void 0 : _a.baseURL) || \"\") + (((_b = error.config) === null || _b === void 0 ? void 0 : _b.url) || \"\");\n        const metadata = generateMetadataFromAxiosError(error);\n        if (error.code === \"ECONNREFUSED\") {\n            throw new ComposioError(COMPOSIO_SDK_ERROR_CODES.COMMON.BASE_URL_NOT_REACHABLE, `ECONNREFUSED for ${fullUrl}`, \"\", \"Make sure:\\n1. The base URL is correct and is accessible\\n2. Your network connection is stable\\n3. There are no firewall rules blocking the connection\", metadata, error);\n        }\n        if (error.code === \"ETIMEDOUT\") {\n            throw new ComposioError(COMPOSIO_SDK_ERROR_CODES.COMMON.REQUEST_TIMEOUT, `ECONNABORTED for ${fullUrl}`, `Request to ${fullUrl} timed out after the configured timeout period. This could be due to slow network conditions, server performance issues, or the request being too large. Error code: ETIMEDOUT`, \"Try:\\n1. Checking your network speed and stability\\n2. Increasing the request timeout setting if needed\\n3. Breaking up large requests into smaller chunks\\n4. Retrying the request when network conditions improve\\n5. Contact tech@composio.dev if the issue persists\", metadata, error);\n        }\n        if (error.code === \"ECONNABORTED\") {\n            throw new ComposioError(COMPOSIO_SDK_ERROR_CODES.COMMON.REQUEST_ABORTED, error.message, \"The request was aborted due to a timeout or other network-related issues. This could be due to network instability, server issues, or the request being too large. Error code: ECONNABORTED\", \"Try:\\n1. Checking your network speed and stability\\n2. Increasing the request timeout setting if needed\\n3. Breaking up large requests into smaller chunks\\n4. Retrying the request when network conditions improve\\n5. Contact tech@composio.dev if the issue persists\", metadata, error);\n        }\n        throw new ComposioError(COMPOSIO_SDK_ERROR_CODES.BACKEND.SERVER_UNREACHABLE, error.message ||\n            \"Server is unreachable. Please contact tech@composio.dev with the error details.\", \"Server is unreachable. Please contact tech@composio.dev with the error details.\", \"Please contact tech@composio.dev with the error details.\", metadata, error);\n    }\n    static throwAPIError(error) {\n        var _a;\n        const statusCode = ((_a = error === null || error === void 0 ? void 0 : error.response) === null || _a === void 0 ? void 0 : _a.status) || null;\n        const errorCode = statusCode\n            ? API_TO_SDK_ERROR_CODE[statusCode] ||\n                COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN\n            : COMPOSIO_SDK_ERROR_CODES.BACKEND.UNKNOWN;\n        const errorDetails = getAPIErrorDetails(error);\n        const metadata = generateMetadataFromAxiosError(error);\n        throw new ComposioError(errorCode, errorDetails.message, errorDetails.description, errorDetails.possibleFix, metadata, error);\n    }\n    static returnZodError(error) {\n        const errorCode = COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED;\n        const errorMessage = error.message;\n        const errorDescription = \"The parameters passed are invalid\";\n        const possibleFix = \"Please check error message for more details\";\n        const metadata = {\n            issues: error.issues,\n        };\n        return new ComposioError(errorCode, errorMessage, errorDescription, possibleFix, metadata, error);\n    }\n    static getCustomError(messageCode, { message, type, subtype, description, possibleFix, originalError, metadata, }) {\n        const finalErrorCode = !!messageCode ? messageCode : `${type}::${subtype}`;\n        const errorDetails = BASE_ERROR_CODE_INFO[finalErrorCode] || BASE_ERROR_CODE_INFO.UNKNOWN;\n        const finalMessage = message || errorDetails.message || \"\";\n        const finalDescription = description || errorDetails.description || undefined;\n        const finalPossibleFix = possibleFix || errorDetails.possibleFix || \"\";\n        throw new ComposioError(messageCode, finalMessage, finalDescription, finalPossibleFix, metadata, originalError);\n    }\n}\n\nclass BatchProcessor {\n    constructor(time = 2000, batchSize = 100, processBatchCallback) {\n        this.batch = [];\n        this.timer = null;\n        this.batch = [];\n        this.time = time;\n        this.batchSize = batchSize;\n        this.processBatchCallback = processBatchCallback;\n    }\n    pushItem(item) {\n        this.batch.push(item);\n        if (this.batch.length >= this.batchSize) {\n            this.processBatch();\n        }\n        else if (!this.timer) {\n            this.timer = setTimeout(() => this.processBatch(), this.time);\n        }\n    }\n    processBatch() {\n        if (this.batch.length > 0) {\n            this.processBatchCallback(this.batch);\n            this.batch = [];\n        }\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    }\n}\n\nvar _a;\nclass TELEMETRY_LOGGER {\n    static createTelemetryWrapper(method, className) {\n        return async (...args) => {\n            const payload = {\n                eventName: method.name,\n                data: { className, args },\n                sdk_meta: {\n                    apiKey: ComposioSDKContext.apiKey,\n                    baseURL: ComposioSDKContext.baseURL,\n                    composioVersion: ComposioSDKContext.composioVersion,\n                    frameworkRuntime: ComposioSDKContext.frameworkRuntime,\n                    source: ComposioSDKContext.source,\n                    sessionId: ComposioSDKContext.sessionId,\n                    isBrowser: typeof window !== \"undefined\",\n                },\n            };\n            _a.batchProcessor.pushItem(payload);\n            return method(...args);\n        };\n    }\n    static async sendTelemetry(payload) {\n        const isTelemetryDisabled = getEnvVariable(\"TELEMETRY_DISABLED\", \"false\") === \"true\";\n        if (isTelemetryDisabled) {\n            return;\n        }\n        const url = `${TELEMETRY_URL}/api/sdk_metrics/telemetry`;\n        const reqPayload = {\n            data: payload,\n            url,\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n        };\n        const isBrowser = typeof window !== \"undefined\";\n        if (isBrowser) {\n            await sendBrowserReq(reqPayload);\n        }\n        else {\n            await sendProcessReq(reqPayload);\n        }\n    }\n    static manualTelemetry(eventName, data) {\n        const payload = {\n            eventName,\n            data,\n            sdk_meta: {\n                apiKey: ComposioSDKContext.apiKey,\n                baseURL: ComposioSDKContext.baseURL,\n                composioVersion: ComposioSDKContext.composioVersion,\n                frameworkRuntime: ComposioSDKContext.frameworkRuntime,\n                source: ComposioSDKContext.source,\n                isBrowser: typeof window !== \"undefined\",\n            },\n        };\n        _a.batchProcessor.pushItem(payload);\n    }\n    static wrapFunctionForTelemetry(func, className) {\n        return _a.createTelemetryWrapper(func, className);\n    }\n}\n_a = TELEMETRY_LOGGER;\nTELEMETRY_LOGGER.batchProcessor = new BatchProcessor(100, 10, async (data) => {\n    await _a.sendTelemetry(data);\n});\n\nvar TELEMETRY_EVENTS;\n(function (TELEMETRY_EVENTS) {\n    TELEMETRY_EVENTS[\"SDK_INITIALIZED\"] = \"SDK_INITIALIZED\";\n    TELEMETRY_EVENTS[\"SDK_METHOD_INVOKED\"] = \"SDK_METHOD_INVOKED\";\n    TELEMETRY_EVENTS[\"CLI_INVOKED\"] = \"CLI_INVOKED\";\n})(TELEMETRY_EVENTS || (TELEMETRY_EVENTS = {}));\n\n// This file is auto-generated by @hey-api/openapi-ts\nconst client = clientAxios.createClient(clientAxios.createConfig());\nclass ClientService {\n    /**\n     * Get user info\n     * Get client info\n     */\n    static getUserInfo(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/client/auth/client_info\",\n        });\n    }\n    /**\n     * Add new project\n     * Add a new project to the client's organization\n     */\n    static addProject(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/client/auth/project/add\",\n        });\n    }\n    /**\n     * Delete project\n     * Delete a project from the client's organization\n     */\n    static deleteProject(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/client/auth/project/delete/{projectId}\",\n        });\n    }\n    /**\n     * Get projects\n     */\n    static getProjects(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/client/auth/projects\",\n        });\n    }\n    /**\n     * Get org api key\n     */\n    static getOrgApiKey(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/client/auth/org/api_key\",\n        });\n    }\n    /**\n     * Regenerate org api key\n     */\n    static regenerateOrgApiKey(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/client/auth/org/api_key/regenerate\",\n        });\n    }\n}\nclass ApiKeysService {\n    /**\n     * Generate api key\n     */\n    static generateApiKey(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/api_keys\",\n        });\n    }\n    /**\n     * List api keys\n     */\n    static listApiKeys(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/api_keys\",\n        });\n    }\n    /**\n     * Delete api key\n     */\n    static deleteApiKey(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/api_keys/{id}\",\n        });\n    }\n}\nclass AppsService {\n    /**\n     * List app categories\n     * List of available app categories, can be used to filter apps.\n     */\n    static listAppCategories(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/apps/list/categories\",\n        });\n    }\n    /**\n     * List app enums\n     * List app enums\n     */\n    static listAppEnums(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/apps/list/enums\",\n        });\n    }\n    /**\n     * List apps\n     * List all apps based on the given filters, if any. This will return all available apps if no filters are provided.\n     */\n    static getApps(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/apps\",\n        });\n    }\n    /**\n     * Get single app\n     * Get app details\n     */\n    static getApp(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/apps/{appName}\",\n        });\n    }\n}\nclass IntegrationsService {\n    /**\n     * Create connector\n     * Create a new connector\n     */\n    static createConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/integrations\",\n        });\n    }\n    /**\n     * List all connectors\n     * List all connectors\n     */\n    static listAllConnectors(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/integrations\",\n        });\n    }\n    /**\n     * Get connector info\n     * Get connector info\n     */\n    static getConnectorInfo(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/integrations/{integrationId}\",\n        });\n    }\n    /**\n     * Modify connector\n     * Modify a connector\n     */\n    static modifyConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).patch({\n            ...options,\n            url: \"/api/v1/integrations/{integrationId}\",\n        });\n    }\n    /**\n     * Delete connector\n     * Delete a connector\n     */\n    static deleteConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/integrations/{integrationId}\",\n        });\n    }\n}\nclass ActionsService {\n    /**\n     * List action enums\n     * List action enums\n     */\n    static listActionEnums(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/actions/list/enums\",\n        });\n    }\n    /**\n     * List action tags\n     * List all the action tags available in composio\n     */\n    static listActionTags(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/list/tags\",\n        });\n    }\n    /**\n     * List action enums\n     * List action enums\n     */\n    static listActionEnums1(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/list/enums\",\n        });\n    }\n    /**\n     * List actions with complete details\n     * List and filter all the actions available in composio, with all the details needed for manual action execution or through function-calling.\n     */\n    static listActionsV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions\",\n        });\n    }\n    /**\n     * List actions\n     * Retrieve a list of all actions based on query parameters.\n     */\n    static listActionsMinimalV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/list/all\",\n        });\n    }\n    /**\n     * Execute an action\n     * Execute an action. Support both connected account and no auth auth.\n     */\n    static executeActionV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/actions/{actionId}/execute\",\n        });\n    }\n    /**\n     * Get action inputs\n     * Get the inputs for an action with NLA\n     */\n    static getActionInputsV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/actions/{actionId}/execute/get.inputs\",\n        });\n    }\n    /**\n     * Get single action\n     * Get action details, including the input and response schema. This is very useful for setting upfunction/tool calling with composio actions.\n     */\n    static getActionV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/{actionId}\",\n        });\n    }\n    /**\n     * Execute with HTTP Client\n     * Use composio as a http client to make request to the connected account service on your behalf, without managing authentication on your side.\n     */\n    static executeWithHttpClient(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/actions/proxy\",\n        });\n    }\n    /**\n     * Advanced use case search\n     * Perform use case search.\n     */\n    static advancedUseCaseSearch(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/search/advanced\",\n        });\n    }\n    /**\n     * List user files\n     */\n    static v2ListUserFiles(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/actions/files/list\",\n        });\n    }\n    /**\n     * Create file upload url\n     * Create file upload URL for action execution.\n     */\n    static createFileUploadUrl(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/actions/files/upload/{fileType}\",\n        });\n    }\n}\nclass ConnectionsService {\n    /**\n     * List connections\n     * Get all connections in the current project.\n     */\n    static listConnections(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/connectedAccounts\",\n        });\n    }\n    /**\n     * Initiate connection\n     */\n    static initiateConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/connectedAccounts\",\n        });\n    }\n    /**\n     * Update connection data\n     * Update connection data\n     */\n    static updateConnectionData(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).patch({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/data\",\n        });\n    }\n    /**\n     * Reinitiate connection\n     * Reinitiate an existing connection to get new credentials\n     */\n    static reinitiateConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/reinitiate\",\n        });\n    }\n    /**\n     * Get single connection\n     */\n    static getConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}\",\n        });\n    }\n    /**\n     * Delete connection\n     * Delete a connection\n     */\n    static deleteConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}\",\n        });\n    }\n    /**\n     * Get Auth credentials\n     * Get authentication crdentials for the connected account, i.e all the headers, query parameters, etc. that are required to make requests to the third-party service directly.\n     */\n    static getConnectionInfo(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/info\",\n        });\n    }\n    /**\n     * Disable connection\n     * Disable a connection\n     */\n    static disableConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/disable\",\n        });\n    }\n    /**\n     * Enable connection\n     * Enable a connection\n     */\n    static enableConnection(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/connectedAccounts/{connectedAccountId}/enable\",\n        });\n    }\n}\nclass TriggersService {\n    /**\n     * List triggers\n     * List triggers\n     */\n    static listTriggers(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers\",\n        });\n    }\n    /**\n     * List trigger enums\n     * List trigger enums\n     */\n    static listTriggerEnums(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers/list/enums\",\n        });\n    }\n    /**\n     * Update new webhook\n     * Update isNewWebhook\n     */\n    static updateNewWebhook(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/triggers/update_webhook_format\",\n        });\n    }\n    /**\n     * Enable trigger\n     * Enables a trigger for a connected account and specific trigger name.\n     */\n    static enableTrigger(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/triggers/enable/{connectedAccountId}/{triggerName}\",\n        });\n    }\n    /**\n     * Get active triggers\n     * Lists active triggers based on query parameters.\n     */\n    static getActiveTriggers(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers/active_triggers\",\n        });\n    }\n    /**\n     * Switch trigger instance status\n     * Switches the status of a trigger instance.\n     */\n    static switchTriggerInstanceStatus(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).patch({\n            ...options,\n            url: \"/api/v1/triggers/instance/{triggerId}/status\",\n        });\n    }\n    /**\n     * Disable trigger\n     * Disables a specified trigger instance.\n     */\n    static disableTrigger(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/triggers/disable/{triggerInstanceId}\",\n        });\n    }\n    /**\n     * Delete trigger\n     * Deletes a specified trigger instance.\n     */\n    static deleteTrigger(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).delete({\n            ...options,\n            url: \"/api/v1/triggers/instance/{triggerInstanceId}\",\n        });\n    }\n    /**\n     * Set callback url\n     * Sets a universal callback URL for the client.\n     */\n    static setCallbackUrl(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/triggers/set_callback_url\",\n        });\n    }\n    /**\n     * Get webhook url\n     * Retrieves the universal callback URL set for the client.\n     */\n    static getWebhookUrl(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers/callback_url\",\n        });\n    }\n    /**\n     * Get logs\n     * Fetches logs based on connection and integration details.\n     */\n    static getTriggerLogs(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/triggers/logs\",\n        });\n    }\n    /**\n     * Get trigger info\n     * Get Trigger Info\n     */\n    static getTriggerInfoV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v2/triggers/{triggerName}\",\n        });\n    }\n}\nclass CliService {\n    /**\n     * Handle cli code exchange\n     */\n    static generateCliSession(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/cli/generate-cli-session\",\n        });\n    }\n    /**\n     * Get cli code\n     */\n    static getCliCode(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/cli/get-cli-code\",\n        });\n    }\n    /**\n     * Handle cli code verification\n     */\n    static verifyCliCode(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/cli/verify-cli-code\",\n        });\n    }\n}\nclass LogsService {\n    /**\n     * Get logs\n     * List logs\n     */\n    static getLogs(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).get({\n            ...options,\n            url: \"/api/v1/logs/\",\n        });\n    }\n    /**\n     * Post logs\n     * Add new logs\n     */\n    static postLogs(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v1/logs/\",\n        });\n    }\n}\nclass IntegrationsV2Service {\n    /**\n     * Search connector\n     * Search for a connector\n     */\n    static searchConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/integrations/search-by-filters\",\n        });\n    }\n    /**\n     * Create connector\n     * Create a new connector\n     */\n    static createConnectorV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/integrations/create\",\n        });\n    }\n    /**\n     * Get or create connector\n     * Get or create a connector\n     */\n    static getOrCreateConnector(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/integrations/get-or-create\",\n        });\n    }\n}\nclass Connectionsv2Service {\n    /**\n     * Initiate connection\n     */\n    static initiateConnectionV2(options) {\n        var _a;\n        return ((_a = options === null || options === void 0 ? void 0 : options.client) !== null && _a !== void 0 ? _a : client).post({\n            ...options,\n            url: \"/api/v2/connectedAccounts/initiateConnection\",\n        });\n    }\n}\n\nvar apiClient = {\n    logs: LogsService,\n    actionsV1: ActionsService,\n    actionsV2: ActionsService,\n    apiKeys: ApiKeysService,\n    clientAuth: ClientService,\n    cli: CliService,\n    appConnector: IntegrationsService,\n    appConnectorV2: IntegrationsV2Service,\n    apps: AppsService,\n    connections: ConnectionsService,\n    connectionsV2: Connectionsv2Service,\n    triggers: TriggersService,\n};\n\nconst ZActionGetParams = z.z.object({\n    actionName: z.z.string(),\n});\nconst ZGetListActionsParams = z.z.object({\n    apps: z.z.string().optional().describe(\"Comma separated app names\"),\n    actions: z.z.string().optional().describe(\"Comma separated action names\"),\n    tags: z.z.string().optional().describe(\"Comma separated tag names\"),\n    useCase: z.z.string().nullable().optional().describe(\"Use case name\"),\n    usecaseLimit: z.z.number().optional().describe(\"Limit for use case\"),\n    showAll: z.z.boolean().optional().describe(\"Show all actions\"),\n    showEnabledOnly: z.z.boolean().optional().describe(\"Show enabled actions\"),\n    filterImportantActions: z.z\n        .boolean()\n        .optional()\n        .describe(\"Filter important actions\"),\n    filterByAvailableApps: z.z\n        .boolean()\n        .optional()\n        .describe(\"Filter actions by available apps\"),\n});\nconst ZParameter = z.z.object({\n    name: z.z.string(),\n    in: z.z.enum([\"query\", \"header\"]),\n    value: z.z.string(),\n});\nconst ZCustomAuthParams = z.z.object({\n    base_url: z.z.string().optional(),\n    parameters: z.z.array(ZParameter),\n    body: z.z.record(z.z.unknown()).optional(),\n});\nconst ZExecuteParams = z.z.object({\n    actionName: z.z.string(),\n    requestBody: z.z.object({\n        connectedAccountId: z.z.string().optional(),\n        input: z.z.record(z.z.unknown()).optional(),\n        appName: z.z.string().optional(),\n        text: z.z.string().optional(),\n        authConfig: ZCustomAuthParams.optional(),\n        allowTracing: z.z.boolean().optional(),\n        sessionInfo: z.z\n            .object({\n            sessionId: z.z.string().optional(),\n        })\n            .optional(),\n    }),\n});\nconst ZFindActionEnumsByUseCaseParams = z.z.object({\n    apps: z.z.array(z.z.string()),\n    useCase: z.z.string(),\n    limit: z.z.number().optional(),\n    filterByAvailableApps: z.z.boolean().optional(),\n});\nconst ZExecuteRequestParams = z.z.object({\n    connectedAccountId: z.z.string(),\n    endpoint: z.z.string(),\n    method: z.z.enum([\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]),\n    parameters: z.z.array(ZParameter),\n    body: z.z.record(z.z.unknown()).optional(),\n});\n\nclass Actions {\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/actions.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * Retrieves details of a specific action in the Composio platform by providing its action name.\n     *\n     * The response includes the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {GetActionData} data The data for the request.\n     * @returns {Promise<ActionItemGetRes[0]>} A promise that resolves to the details of the action.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZActionGetParams.parse(data);\n            const actions = await apiClient.actionsV2.getActionV2({\n                client: this.client,\n                path: {\n                    actionId: parsedData.actionName,\n                },\n            });\n            return actions.data;\n        }\n        catch (e) {\n            throw CEG.handleAllError(e);\n        }\n    }\n    /**\n     * Retrieves a list of all actions in the Composio platform.\n     *\n     * This method allows you to fetch a list of all the available actions. It supports pagination to handle large numbers of actions. The response includes an array of action objects, each containing information such as the action's name, display name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {GetListActionsData} data The data for the request.\n     * @returns {Promise<ActionsListResponseDTO>} A promise that resolves to the list of all actions.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list(data = {}) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZGetListActionsParams.parse(data);\n            let apps = parsedData.apps;\n            // Throw error if user has provided both filterByAvailableApps and apps\n            if ((data === null || data === void 0 ? void 0 : data.filterByAvailableApps) && (data === null || data === void 0 ? void 0 : data.apps)) {\n                throw new Error(\"Both filterByAvailableApps and apps cannot be provided together\");\n            }\n            if (data === null || data === void 0 ? void 0 : data.filterByAvailableApps) {\n                // Todo: To create a new API to get all integrated apps for a user instead of fetching all apps\n                const integratedApps = await apiClient.appConnector.listAllConnectors();\n                apps = (_a = integratedApps.data) === null || _a === void 0 ? void 0 : _a.items.map((app) => app === null || app === void 0 ? void 0 : app.appName).join(\",\");\n            }\n            const response = await apiClient.actionsV2.listActionsV2({\n                client: this.client,\n                query: {\n                    actions: data.actions,\n                    apps: apps,\n                    showAll: data.showAll,\n                    tags: data.tags,\n                    filterImportantActions: data.filterImportantActions,\n                    showEnabledOnly: data.showEnabledOnly,\n                    usecaseLimit: data.usecaseLimit || undefined,\n                    useCase: data.useCase,\n                },\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Executes a specific action in the Composio platform.\n     * This doesn't execute the local action and is wrapper over backend. Try to call this method directly from toolset\n     *\n     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.\n     *\n     * @param {ExecuteActionData} data The data for the request.\n     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the execution status and response data.\n     * @throws {ComposioError} If the request fails.\n     */\n    async execute(data) {\n        var _a, _b, _c;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"execute\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZExecuteParams.parse(data);\n            const { data: res } = await apiClient.actionsV2.executeActionV2({\n                client: this.client,\n                body: {\n                    ...parsedData.requestBody,\n                    sessionInfo: {\n                        ...(((_a = parsedData.requestBody) === null || _a === void 0 ? void 0 : _a.sessionInfo) || {}),\n                        sessionId: ((_c = (_b = parsedData.requestBody) === null || _b === void 0 ? void 0 : _b.sessionInfo) === null || _c === void 0 ? void 0 : _c.sessionId) ||\n                            ComposioSDKContext.sessionId,\n                    },\n                    allowTracing: Boolean(ComposioSDKContext === null || ComposioSDKContext === void 0 ? void 0 : ComposioSDKContext.allowTracing),\n                },\n                path: {\n                    actionId: parsedData.actionName,\n                },\n            });\n            return res;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Finds all action enums by use case.\n     *\n     * @param {FindActionEnumsByUseCaseParam} data The data for the request.\n     * @returns {Promise<ActionFindActionEnumsByUseCaseRes>} A promise that resolves to the list of action enums.\n     * @throws {ComposioError} If the request fails.\n     */\n    async findActionEnumsByUseCase(data) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"findActionEnumsByUseCase\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZFindActionEnumsByUseCaseParams.parse(data);\n            const { data: res } = await apiClient.actionsV2.advancedUseCaseSearch({\n                client: this.client,\n                query: {\n                    apps: (_a = parsedData.apps) === null || _a === void 0 ? void 0 : _a.join(\",\"),\n                    limit: parsedData.limit || undefined,\n                    filterByAvailableApps: parsedData.filterByAvailableApps,\n                },\n                body: {\n                    useCase: parsedData.useCase,\n                },\n            });\n            return res.items.map((item) => item.actions).flat() || [];\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Executes a action using Composio Proxy\n     *\n     * This method allows you to trigger the execution of an action by providing its name and the necessary input parameters. The request includes the connected account ID to identify the app connection to use for the action, and the input parameters required by the action. The response provides details about the execution status and the response data returned by the action.\n     *\n     * @param {ExecuteActionData} data The data for the request.\n     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the execution status and response data.\n     * @throws {ComposioError} If the request fails.\n     */\n    async executeRequest(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"executeRequest\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZExecuteRequestParams.parse(data);\n            const { data: res } = await apiClient.actionsV2.executeWithHttpClient({\n                client: this.client,\n                body: {\n                    connectedAccountId: parsedData.connectedAccountId,\n                    endpoint: parsedData.endpoint,\n                    method: parsedData.method,\n                    parameters: parsedData.parameters,\n                    body: parsedData.body,\n                },\n            });\n            return res;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nconst ZTriggerItemParam = z.z.object({\n    triggerId: z.z.string(),\n});\nconst ZActiveTriggersQuery = z.z.object({\n    triggerIds: z.z.string().optional(),\n    triggerNames: z.z.string().optional(),\n    connectedAccountIds: z.z.string().optional(),\n    integrationIds: z.z.string().optional(),\n    limit: z.z.number().optional(),\n    page: z.z.number().optional(),\n    showDisabled: z.z.boolean().optional(),\n});\nconst ZConnection = z.z.object({\n    id: z.z.string(),\n    integrationId: z.z.string(),\n    memberId: z.z.string(),\n    clientUniqueUserId: z.z.string(),\n    status: z.z.string(),\n    data: z.z.record(z.z.unknown()),\n    deleted: z.z.boolean().optional(),\n    enabled: z.z.boolean(),\n    labels: z.z.array(z.z.unknown()),\n    createdAt: z.z.string(),\n    updatedAt: z.z.string(),\n});\nz.z.object({\n    id: z.z.string(),\n    connectionId: z.z.string(),\n    triggerName: z.z.string(),\n    triggerData: z.z.string(),\n    triggerConfig: z.z.record(z.z.unknown()),\n    state: z.z.record(z.z.unknown()),\n    createdAt: z.z.string(),\n    updatedAt: z.z.string(),\n    disabledAt: z.z.string().nullable(),\n    disabledReason: z.z.string().nullable(),\n    connection: ZConnection,\n});\n\nclass ActiveTriggers {\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/activeTriggers.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /** Missing type */\n    /**\n     * Retrieves details of a specific active trigger in the Composio platform by providing its trigger name.\n     *\n     * The response includes the trigger's name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {TriggerItemParam} data The data for the request.\n     * @returns {Promise<TriggerItemRes>} A promise that resolves to the details of the active trigger.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get({ triggerId }) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { triggerId },\n        });\n        try {\n            const parsedData = ZTriggerItemParam.parse({ triggerId });\n            const { data } = await apiClient.triggers.getActiveTriggers({\n                client: this.client,\n                query: {\n                    triggerIds: `${parsedData.triggerId}`,\n                },\n            });\n            return (_a = data === null || data === void 0 ? void 0 : data.triggers) === null || _a === void 0 ? void 0 : _a[0];\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves a list of all active triggers in the Composio platform.\n     *\n     * This method allows you to fetch a list of all the available active triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {GetActiveTriggersData} data The data for the request.\n     * @returns {Promise<ZActiveTriggerItemRes[]>} A promise that resolves to the list of all active triggers.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list(data = {}) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZActiveTriggersQuery.parse(data);\n            const { data: response } = await apiClient.triggers.getActiveTriggers({\n                client: this.client,\n                query: parsedData,\n            });\n            return response === null || response === void 0 ? void 0 : response.triggers;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Enables the previously disabled trigger.\n     *\n     * @param {TriggerItemParam} data The data for the request.\n     * @returns {Promise<{status: string}>} A promise that resolves to the response of the enable request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async enable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"enable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZTriggerItemParam.parse(data);\n            await apiClient.triggers.switchTriggerInstanceStatus({\n                client: this.client,\n                path: { triggerId: parsedData.triggerId },\n                body: {\n                    enabled: true,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Disables the previously enabled trigger.\n     *\n     * @param {TriggerItemParam} data The data for the request.\n     * @returns {Promise<{status: string}>} A promise that resolves to the response of the disable request.\n     */\n    async disable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"disable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZTriggerItemParam.parse(data);\n            await apiClient.triggers.switchTriggerInstanceStatus({\n                client: this.client,\n                path: parsedData,\n                body: {\n                    enabled: false,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nz.z.object({\n    appKey: z.z.string(),\n});\nconst ZGetRequiredParams = z.z.object({\n    appId: z.z.string(),\n});\nconst ZGetRequiredParamsForAuthScheme = z.z.object({\n    appId: z.z.string(),\n    authScheme: z.z.string(),\n});\nconst ZRequiredParamsResponse = z.z.object({\n    required_fields: z.z.array(z.z.string()),\n    expected_from_user: z.z.array(z.z.string()),\n    optional_fields: z.z.array(z.z.string()),\n});\nz.z.object({\n    availableAuthSchemes: z.z.array(z.z.string()),\n    authSchemes: z.z.record(z.z.string(), ZRequiredParamsResponse),\n});\n\nclass Apps {\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/apps.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * Retrieves a list of all available apps in the Composio platform.\n     *\n     * This method allows clients to explore and discover the supported apps. It returns an array of app objects, each containing essential details such as the app's key, name, description, logo, categories, and unique identifier.\n     *\n     * @returns {Promise<AppItemListResponse[]>} A promise that resolves to the list of all apps.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list() {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: {},\n        });\n        try {\n            const { data } = await apiClient.apps.getApps({\n                client: this.client,\n                query: {\n                    additionalFields: \"auth_schemes\",\n                },\n            });\n            return (data === null || data === void 0 ? void 0 : data.items) || [];\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves details of a specific app in the Composio platform.\n     *\n     * This method allows clients to fetch detailed information about a specific app by providing its unique key. The response includes the app's name, key, status, description, logo, categories, authentication schemes, and other metadata.\n     *\n     * @param {AppGetDataParams} data The data for the request, including the app's unique key.\n     * @returns {Promise<AppItemResponse>} A promise that resolves to the details of the app.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { data: response } = await apiClient.apps.getApp({\n                client: this.client,\n                path: {\n                    appName: data.appKey,\n                },\n            });\n            if (!response)\n                throw new Error(\"App not found\");\n            return response;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific app in the Composio platform.\n     *\n     * This method allows clients to fetch the necessary parameters for a specific app by providing its unique key. The response includes the app's name, key, status, description, logo, categories, authentication schemes, and other metadata.\n     *\n     * @param {string} appId The unique key of the app.\n     * @returns {Promise<AppRequiredParamsFullResponse>} A promise that resolves to the required parameters for the app.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getRequiredParams(appId) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getRequiredParams\",\n            file: this.fileName,\n            params: { appId },\n        });\n        try {\n            ZGetRequiredParams.parse({ appId });\n            const appData = await this.get({ appKey: appId });\n            if (!appData)\n                throw new Error(\"App not found\");\n            const authSchemes = appData.auth_schemes;\n            const availableAuthSchemes = authSchemes === null || authSchemes === void 0 ? void 0 : authSchemes.map((scheme) => scheme === null || scheme === void 0 ? void 0 : scheme.mode);\n            const authSchemesObject = {};\n            for (const scheme of authSchemes) {\n                const name = scheme.mode;\n                authSchemesObject[name] = {\n                    required_fields: [],\n                    optional_fields: [],\n                    expected_from_user: [],\n                };\n                scheme.fields.forEach((field) => {\n                    const isExpectedForIntegrationSetup = field.expected_from_customer === false;\n                    const isRequired = field.required;\n                    if (isExpectedForIntegrationSetup) {\n                        if (isRequired) {\n                            authSchemesObject[name].expected_from_user.push(field.name);\n                        }\n                        else {\n                            authSchemesObject[name].optional_fields.push(field.name);\n                        }\n                    }\n                    else {\n                        authSchemesObject[name].required_fields.push(field.name);\n                    }\n                });\n            }\n            return {\n                availableAuthSchemes,\n                authSchemes: authSchemesObject,\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.\n     *\n     * This method allows clients to fetch the necessary parameters for a specific authentication scheme of an app by providing its unique key and the authentication scheme.\n     *\n     * @param {AppGetRequiredParamsForAuthSchemeParam} data The data for the request, including the app's unique key and the authentication scheme.\n     * @returns {Promise<AppRequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getRequiredParamsForAuthScheme({ appId, appName, authScheme, }) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getRequiredParamsForAuthScheme\",\n            file: this.fileName,\n            params: { appId, authScheme },\n        });\n        try {\n            const finalAppId = appName || appId;\n            ZGetRequiredParamsForAuthScheme.parse({ appId: finalAppId, authScheme });\n            const params = await this.getRequiredParams(finalAppId);\n            return params.authSchemes[authScheme];\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nconst ZConnectionStatus = z.z.enum([\"INITIATED\", \"ACTIVE\", \"FAILED\"]);\nconst ZListConnectionsData = z.z.object({\n    appNames: z.z.string().optional(),\n    appUniqueKeys: z.z.string().array().optional(),\n    connectionId: z.z.string().optional(),\n    entityId: z.z.string().optional(),\n    integrationId: z.z.string().optional(),\n    labels: z.z.string().optional(),\n    page: z.z.number().optional(),\n    pageSize: z.z.number().optional(),\n    showActiveOnly: z.z.boolean().optional(),\n    showDisabled: z.z.boolean().optional(),\n    status: ZConnectionStatus.optional(),\n    user_uuid: z.z.string().optional(),\n});\nz.z.object({\n    connectionParams: z.z.record(z.z.string(), z.z.unknown()).optional(),\n    entityId: z.z.string().optional(),\n    labels: z.z.array(z.z.string()).optional(),\n    integrationId: z.z.string().optional(),\n    redirectUri: z.z.string().optional(),\n    authMode: ZAuthMode.optional(),\n    authConfig: z.z.record(z.z.string(), z.z.unknown()).optional(),\n    appName: z.z.string().optional(),\n});\nconst ZSaveUserAccessDataParam = z.z.object({\n    fieldInputs: z.z.record(z.z.string(), z.z.unknown()),\n    redirectUrl: z.z.string().optional(),\n    entityId: z.z.string().optional(),\n});\nconst ZSingleConnectionParams = z.z.object({\n    connectedAccountId: z.z.string(),\n});\nz.z.object({\n    data: z.z.record(z.z.string(), z.z.unknown()),\n    integrationId: z.z.string(),\n    redirectUri: z.z.string().optional(),\n    userUuid: z.z.string().optional(),\n    entityId: z.z.string().optional(),\n    labels: z.z.string().array().optional(),\n});\nconst ZReinitiateConnectionPayloadDto = z.z.object({\n    connectedAccountId: z.z.string(),\n    data: z.z.record(z.z.string(), z.z.unknown()),\n    redirectUri: z.z.string().optional(),\n});\n\n/**\n * Class representing connected accounts in the system.\n */\nclass ConnectedAccounts {\n    /**\n     * Initializes a new instance of the ConnectedAccounts class.\n     * @param {AxiosBackendClient} backendClient - The backend client instance.\n     */\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/connectedAccounts.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * List all connected accounts\n     * @param {ConnectedAccountsListData} data - The data for the connected accounts list\n     * @returns {Promise<ConnectedAccountListResponse>} - A promise that resolves to a list of connected accounts\n     */\n    async list(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { appNames, appUniqueKeys } = ZListConnectionsData.parse(data);\n            const finalAppNames = appNames || (appUniqueKeys === null || appUniqueKeys === void 0 ? void 0 : appUniqueKeys.join(\",\"));\n            const res = await apiClient.connections.listConnections({\n                client: this.client,\n                query: {\n                    ...data,\n                    appNames: finalAppNames,\n                },\n            });\n            return res.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Get a single connected account\n     * @param {SingleConnectionParam} data - The data for the single connection\n     * @returns {Promise<SingleConnectedAccountResponse>} - A promise that resolves to a single connected account\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleConnectionParams.parse(data);\n            const res = await apiClient.connections.getConnection({\n                client: this.client,\n                path: data,\n                throwOnError: true,\n            });\n            return res.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Delete a single connected account\n     * @param {SingleConnectionParam} data - The data for the single connection\n     * @returns {Promise<SingleDeleteResponse>} - A promise that resolves when the connected account is deleted\n     */\n    async delete(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"delete\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleConnectionParams.parse(data);\n            const res = await apiClient.connections.deleteConnection({\n                client: this.client,\n                path: data,\n                throwOnError: true,\n            });\n            return res.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Disable a single connected account\n     * @param {SingleConnectionParam} data - The data for the single connection\n     * @returns {Promise<ConnectionChangeResponse>} - A promise that resolves when the connected account is disabled\n     */\n    async disable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"disable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleConnectionParams.parse(data);\n            const res = await apiClient.connections.disableConnection({\n                client: this.client,\n                path: data,\n                throwOnError: true,\n            });\n            return {\n                status: \"success\",\n                connectedAccountId: data.connectedAccountId,\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Enable a single connected account\n     * @param {SingleConnectionParam} data - The data for the single connection\n     * @returns {Promise<ConnectionChangeResponse>} - A promise that resolves when the connected account is enabled\n     */\n    async enable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"enable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleConnectionParams.parse(data);\n            await apiClient.connections.enableConnection({\n                client: this.client,\n                path: {\n                    connectedAccountId: data.connectedAccountId,\n                },\n                throwOnError: true,\n            });\n            return {\n                status: \"success\",\n                connectedAccountId: data.connectedAccountId,\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Initiate a connection\n     * @param {InitiateConnectionDataReq} payload - The payload for the connection initiation\n     * @returns {Promise<ConnectionRequest>} - A promise that resolves to a connection request\n     */\n    async initiate(payload) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"initiate\",\n            file: this.fileName,\n            params: { payload },\n        });\n        try {\n            const connection = await apiClient.connectionsV2.initiateConnectionV2({\n                client: this.client,\n                body: {\n                    app: {\n                        uniqueKey: payload.appName,\n                        integrationId: payload.integrationId,\n                    },\n                    config: {\n                        name: payload.appName,\n                        useComposioAuth: !!payload.authMode && !!payload.authConfig,\n                        authScheme: payload.authMode,\n                        integrationSecrets: payload.authConfig,\n                    },\n                    connection: {\n                        entityId: payload.entityId,\n                        initiateData: payload.connectionParams || {},\n                        extra: {\n                            redirectURL: payload.redirectUri,\n                            labels: payload.labels || [],\n                        },\n                    },\n                },\n            });\n            const connectionResponse = (_a = connection === null || connection === void 0 ? void 0 : connection.data) === null || _a === void 0 ? void 0 : _a.connectionResponse;\n            return new ConnectionRequest({\n                connectionStatus: connectionResponse === null || connectionResponse === void 0 ? void 0 : connectionResponse.connectionStatus,\n                connectedAccountId: connectionResponse === null || connectionResponse === void 0 ? void 0 : connectionResponse.connectedAccountId,\n                redirectUri: connectionResponse === null || connectionResponse === void 0 ? void 0 : connectionResponse.redirectUrl,\n                client: this.client,\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Reinitiate a connection\n     * @param {ReinitiateConnectionPayload} data - The payload for the connection reinitialization\n     * @returns {Promise<ConnectionRequest>} - A promise that resolves to a connection request\n     */\n    async reinitiateConnection(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"reinitiateConnection\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZReinitiateConnectionPayloadDto.parse(data);\n            const connection = await apiClient.connections.reinitiateConnection({\n                client: this.client,\n                path: {\n                    connectedAccountId: data.connectedAccountId,\n                },\n                body: {\n                    data: data.data,\n                    redirectUri: data.redirectUri,\n                },\n            });\n            const res = connection.data;\n            return new ConnectionRequest({\n                connectionStatus: res === null || res === void 0 ? void 0 : res.connectionStatus,\n                connectedAccountId: res === null || res === void 0 ? void 0 : res.connectedAccountId,\n                redirectUri: res === null || res === void 0 ? void 0 : res.redirectUrl,\n                client: this.client,\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\nclass ConnectionRequest {\n    constructor({ connectionStatus, connectedAccountId, redirectUri, client, }) {\n        this.connectionStatus = connectionStatus;\n        this.connectedAccountId = connectedAccountId;\n        this.redirectUrl = redirectUri;\n        this.client = client;\n    }\n    async saveUserAccessData(data) {\n        try {\n            ZSaveUserAccessDataParam.parse(data);\n            const { data: connectedAccount } = await apiClient.connections.getConnection({\n                client: this.client,\n                path: { connectedAccountId: this.connectedAccountId },\n            });\n            if (!connectedAccount)\n                throw new Error(\"Connected account not found\");\n            return await apiClient.connections.initiateConnection({\n                client: this.client,\n                body: {\n                    integrationId: connectedAccount.integrationId,\n                    //@ts-ignore\n                    data: data.fieldInputs,\n                    redirectUri: data.redirectUrl,\n                    userUuid: data.entityId,\n                    entityId: data.entityId,\n                },\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Wait until the connection becomes active\n     * @param {number} timeout - The timeout for the connection to become active\n     * @returns {Promise<Connection>} - A promise that resolves to the connection\n     */\n    async waitUntilActive(timeout = 60) {\n        try {\n            const startTime = Date.now();\n            while (Date.now() - startTime < timeout * 1000) {\n                const connection = await apiClient.connections\n                    .getConnection({\n                    client: this.client,\n                    path: { connectedAccountId: this.connectedAccountId },\n                })\n                    .then((res) => res.data);\n                if (!connection)\n                    throw new Error(\"Connected account not found\");\n                if (connection.status === \"ACTIVE\") {\n                    return connection;\n                }\n                await new Promise((resolve) => setTimeout(resolve, 1000));\n            }\n            throw new Error(\"Connection did not become active within the timeout period.\");\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nclass Integrations {\n    constructor(backendClient, client) {\n        this.fileName = \"js/src/sdk/models/integrations.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * Retrieves a list of all available integrations in the Composio platform.\n     *\n     * This method allows clients to explore and discover the supported integrations. It returns an array of integration objects, each containing essential details such as the integration's key, name, description, logo, categories, and unique identifier.\n     *\n     * @returns {Promise<IntegrationListRes>} A promise that resolves to the list of all integrations.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list(data = {}) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { appName, appUniqueKey, ...rest } = ZListIntegrationsParams.parse(data);\n            const finalAppName = appName && appName.length > 0 ? appName : appUniqueKey;\n            const response = await apiClient.appConnector.listAllConnectors({\n                client: this.client,\n                query: { ...rest, appName: finalAppName },\n                throwOnError: true,\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves details of a specific integration in the Composio platform by providing its integration name.\n     *\n     * The response includes the integration's name, display name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {IntegrationGetParam} data The data for the request.\n     * @returns {Promise<IntegrationGetResponse>} A promise that resolves to the details of the integration.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const response = await apiClient.appConnector.getConnectorInfo({\n                client: this.client,\n                path: data,\n                throwOnError: true,\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific integration's authentication scheme.\n     *\n     * This method is used to get the necessary input fields for a specific integration's authentication scheme.\n     *\n     * @param {IntegrationGetParam} data The data for the request.\n     * @returns {Promise<IntegrationRequiredParamsRes>} A promise that resolves to the required parameters for the integration's authentication scheme.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getRequiredParams(data) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getRequiredParams\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleIntegrationParams.parse(data);\n            const response = await apiClient.appConnector.getConnectorInfo({\n                client: this.client,\n                path: {\n                    integrationId: data.integrationId,\n                },\n                throwOnError: true,\n            });\n            return (_a = response.data) === null || _a === void 0 ? void 0 : _a.expectedInputFields;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Creates a new integration in the Composio platform.\n     *\n     * This method allows clients to create a new integration by providing the necessary details such as app ID, name, authentication mode, and configuration.\n     *\n     * @param {IntegrationCreateParams} data The data for the request.\n     * @returns {Promise<IntegrationGetResponse>} A promise that resolves to the created integration model.\n     * @throws {ComposioError} If the request fails.\n     */\n    async create(data) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"create\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZCreateIntegrationParams.parse(data);\n            let uniqueKey = data.appUniqueKey;\n            if (!uniqueKey) {\n                const apps = await apiClient.apps.getApps({ client: this.client });\n                const app = (_a = apps.data) === null || _a === void 0 ? void 0 : _a.items.find((app) => app.appId === data.appId);\n                uniqueKey = app.key;\n                if (!uniqueKey) {\n                    throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                        message: `No app was found with the provided appId`,\n                        description: `Please provide an app unique key`,\n                    });\n                }\n            }\n            const response = await apiClient.appConnectorV2.createConnectorV2({\n                client: this.client,\n                body: {\n                    app: {\n                        uniqueKey: uniqueKey,\n                    },\n                    config: {\n                        useComposioAuth: data.useComposioAuth,\n                        name: data.name,\n                        authScheme: data.authScheme,\n                        integrationSecrets: data.authConfig,\n                    },\n                },\n                throwOnError: true,\n            });\n            const integrationId = response.data.integrationId;\n            return this.get({ integrationId });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    async getOrCreateIntegration(data) {\n        var _a;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getOrCreateIntegration\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZCreateIntegrationParams.parse(data);\n            let uniqueKey = data.appUniqueKey;\n            if (!uniqueKey) {\n                const apps = await apiClient.apps.getApps({ client: this.client });\n                const app = (_a = apps.data) === null || _a === void 0 ? void 0 : _a.items.find((app) => app.appId === data.appId);\n                uniqueKey = app.key;\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: `No app was found with the provided appId`,\n                    description: `Please provide an app unique key`,\n                });\n            }\n            const response = await apiClient.appConnectorV2.getOrCreateConnector({\n                client: this.client,\n                body: {\n                    app: {\n                        uniqueKey,\n                    },\n                    config: {\n                        useComposioAuth: data.useComposioAuth,\n                        name: data.name,\n                        authScheme: data.authScheme,\n                        integrationSecrets: data.authConfig,\n                    },\n                },\n                throwOnError: true,\n            });\n            const integrationId = response.data.integrationId;\n            return this.get({ integrationId });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Deletes an existing integration in the Composio platform.\n     *\n     * This method allows clients to delete an existing integration by providing its integration ID.\n     *\n     * @param {IntegrationListData} data The data for the request.\n     * @returns {Promise<IntegrationDeleteResponse>} A promise that resolves to the deleted integration model.\n     * @throws {ComposioError} If the request fails.\n     */\n    async delete(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"delete\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            ZSingleIntegrationParams.parse(data);\n            const response = await apiClient.appConnector.deleteConnector({\n                client: this.client,\n                path: {\n                    integrationId: data.integrationId,\n                },\n                throwOnError: true,\n            });\n            return response.data;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nconst PUSHER_KEY = process.env.CLIENT_PUSHER_KEY || \"8e1b8c92b7f8b2151c15\";\nconst PUSHER_CLUSTER = \"mt1\";\nclass PusherUtils {\n    static getPusherClient(baseURL, apiKey) {\n        if (!PusherUtils.pusherClient) {\n            // Dynamic import not available, using require for now\n            // TODO: Update to use dynamic import when available\n            // eslint-disable-next-line @typescript-eslint/no-require-imports\n            const PusherClient = __webpack_require__(/*! pusher-js */ \"(rsc)/./node_modules/pusher-js/dist/node/pusher.js\");\n            PusherUtils.pusherClient = new PusherClient(PUSHER_KEY, {\n                cluster: PUSHER_CLUSTER,\n                channelAuthorization: {\n                    endpoint: `${baseURL}/api/v1/client/auth/pusher_auth`,\n                    headers: {\n                        \"x-api-key\": apiKey,\n                    },\n                    transport: \"ajax\",\n                },\n            });\n        }\n        return PusherUtils.pusherClient;\n    }\n    /**\n     * Subscribes to a Pusher channel and binds an event to a callback function.\n     * @param {string} channelName - The name of the channel to subscribe to.\n     * @param {string} event - The event to bind to the channel.\n     * @param {(data: Record<string, unknown>) => void} fn - The callback function to execute when the event is triggered.\n     * @returns {PusherClient} The Pusher client instance.\n     */\n    static async subscribe(channelName, event, fn) {\n        try {\n            await PusherUtils.pusherClient.subscribe(channelName).bind(event, fn);\n        }\n        catch (error) {\n            logger.error(`Error subscribing to ${channelName} with event ${event}: ${error}`);\n        }\n    }\n    /**\n     * Unsubscribes from a Pusher channel.\n     * @param {string} channelName - The name of the channel to unsubscribe from.\n     * @returns {void}\n     */\n    static async unsubscribe(channelName) {\n        PusherUtils.pusherClient.unsubscribe(channelName);\n    }\n    /**\n     * Binds an event to a channel with support for chunked messages.\n     * @param {PusherClient} channel - The Pusher channel to bind the event to.\n     * @param {string} event - The event to bind to the channel.\n     * @param {(data: unknown) => void} callback - The callback function to execute when the event is triggered.\n     */\n    static bindWithChunking(channel, event, callback) {\n        channel.bind(event, callback); // Allow normal unchunked events.\n        // Now the chunked variation. Allows arbitrarily long messages.\n        const events = {};\n        channel.bind(\"chunked-\" + event, (data) => {\n            const typedData = data;\n            if (!events.hasOwnProperty(typedData.id)) {\n                events[typedData.id] = { chunks: [], receivedFinal: false };\n            }\n            const ev = events[typedData.id];\n            ev.chunks[typedData.index] = typedData.chunk;\n            if (typedData.final)\n                ev.receivedFinal = true;\n            if (ev.receivedFinal &&\n                ev.chunks.length === Object.keys(ev.chunks).length) {\n                callback(JSON.parse(ev.chunks.join(\"\")));\n                delete events[typedData.id];\n            }\n        });\n    }\n    /**\n     * Subscribes to a trigger channel for a client and handles chunked data.\n     * @param {string} clientId - The unique identifier for the client subscribing to the events.\n     * @param {(data: TriggerData) => void} fn - The callback function to execute when trigger data is received.\n     */\n    static triggerSubscribe(clientId, fn) {\n        const channel = PusherUtils.pusherClient.subscribe(`private-${clientId}_triggers`);\n        PusherUtils.bindWithChunking(channel, \"trigger_to_client\", fn);\n        logger.info(`Subscribed to triggers. You should start receiving events now.`);\n    }\n    static triggerUnsubscribe(clientId) {\n        PusherUtils.pusherClient.unsubscribe(`${clientId}_triggers`);\n    }\n}\n\nconst ZTriggerQuery = z.z.object({\n    triggerIds: z.z.array(z.z.string()).optional().describe(\"Trigger Instance IDs\"),\n    triggerInstanceIds: z.z\n        .array(z.z.string())\n        .optional()\n        .describe(\"Trigger Instance IDs\"),\n    appNames: z.z.array(z.z.string()).optional().describe(\"App Names in lowercase\"),\n    appUniqueKeys: z.z.array(z.z.string()).optional().describe(\"App Unique Keys\"),\n    connectedAccountIds: z.z\n        .array(z.z.string())\n        .optional()\n        .describe(\"Connected Account UUIDs\"),\n    integrationIds: z.z.array(z.z.string()).optional().describe(\"Integration IDs\"),\n    showEnabledOnly: z.z\n        .boolean()\n        .optional()\n        .describe(\"Show Enabled triggers only\"),\n});\nconst ZTriggerInstanceItems = z.z.object({\n    triggerInstanceId: z.z.string(),\n});\nconst ZTriggerSetupParam = z.z.object({\n    connectedAccountId: z.z.string(),\n    triggerName: z.z.string(),\n    config: z.z.record(z.z.unknown()).optional(),\n});\nz.z.object({\n    appName: z.z.string().optional(),\n    triggerId: z.z.string().optional(),\n    connectionId: z.z.string().optional(),\n    integrationId: z.z.string().optional(),\n    triggerName: z.z.string().optional(),\n    triggerData: z.z.string().optional(),\n    entityId: z.z.string().optional(),\n});\nconst ZSingleTriggerParam = z.z.object({\n    triggerId: z.z.string().optional(),\n    triggerName: z.z.string().optional(),\n});\nz.z.object({\n    triggerInstanceId: z.z.string().optional(),\n    triggerId: z.z.string().optional(),\n});\nz.z.object({\n    name: z.z.string(),\n    displayName: z.z.string(),\n    description: z.z.string(),\n    type: z.z.string(),\n    appId: z.z.string(),\n    appName: z.z.string(),\n    instructions: z.z.string().optional(),\n    payload: z.z.record(z.z.unknown()),\n    config: z.z.record(z.z.unknown()),\n});\n\nclass Triggers {\n    constructor(backendClient, client) {\n        this.trigger_to_client_event = \"trigger_to_client\";\n        this.fileName = \"js/src/sdk/models/triggers.ts\";\n        this.backendClient = backendClient;\n        this.client = client;\n    }\n    /**\n     * Retrieves a list of all triggers in the Composio platform.\n     *\n     * This method allows you to fetch a list of all the available triggers. It supports pagination to handle large numbers of triggers. The response includes an array of trigger objects, each containing information such as the trigger's name, description, input parameters, expected response, associated app information, and enabled status.\n     *\n     * @param {ListTriggersData} data The data for the request.\n     * @returns {Promise<ListTriggersResponse>} A promise that resolves to the list of all triggers.\n     * @throws {ComposioError} If the request fails.\n     */\n    async list(data = {}) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"list\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { appNames, triggerIds, connectedAccountIds, integrationIds, showEnabledOnly, triggerInstanceIds, appUniqueKeys, } = ZTriggerQuery.parse(data);\n            const finalTriggerInstanceIds = triggerIds && triggerIds.length > 0 ? triggerIds : triggerInstanceIds;\n            const finalAppNames = appNames && appNames.length > 0 ? appNames : appUniqueKeys;\n            const { data: response } = await apiClient.triggers.listTriggers({\n                client: this.client,\n                query: {\n                    appNames: finalAppNames === null || finalAppNames === void 0 ? void 0 : finalAppNames.join(\",\"),\n                    triggerIds: finalTriggerInstanceIds === null || finalTriggerInstanceIds === void 0 ? void 0 : finalTriggerInstanceIds.join(\",\"),\n                    connectedAccountIds: connectedAccountIds === null || connectedAccountIds === void 0 ? void 0 : connectedAccountIds.join(\",\"),\n                    integrationIds: integrationIds === null || integrationIds === void 0 ? void 0 : integrationIds.join(\",\"),\n                    showEnabledOnly: showEnabledOnly || false,\n                },\n            });\n            if (!response || response.length === 0) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND, {\n                    message: \"Trigger not found with the given params\",\n                    description: \"Trigger not found with the given params\",\n                    possibleFix: \"Pass a check if filter params are correct\",\n                });\n            }\n            return response;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the configuration of a single trigger.\n     *\n     * @param {TriggerSingleParam} data The data for the request.\n     * @returns {Promise<TriggerSingleConfig>} A promise that resolves to the trigger configuration.\n     * @throws {ComposioError} If the request fails.\n     */\n    async get(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            client: this.client,\n            method: \"get\",\n            file: this.fileName,\n            params: { data },\n        });\n        return this.getTriggerInfo(data);\n    }\n    /**\n     * @deprecated use trigger.get instead\n     * Retrieves the configuration of a single trigger.\n     *\n     * @param {TriggerSingleParam} data The data for the request.\n     * @returns {Promise<TriggerSingleConfig>} A promise that resolves to the trigger configuration.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getTriggerConfig(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getSingleTriggerConfig\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZSingleTriggerParam.parse(data);\n            if (!parsedData.triggerName && !parsedData.triggerId) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: \"Trigger name or trigger id is required\",\n                    description: \"Trigger name or trigger id is required\",\n                    possibleFix: \"Pass either triggerName or triggerId\",\n                });\n            }\n            const res = await apiClient.triggers.getTriggerInfoV2({\n                client: this.client,\n                path: {\n                    triggerName: parsedData.triggerName || parsedData.triggerId || \"\",\n                },\n            });\n            // Bad type inference\n            const triggerInfo = res.data;\n            if (!triggerInfo) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND, {\n                    message: \"Trigger info not found\",\n                    description: \"Trigger info not found\",\n                    possibleFix: \"Pass a check if trigger exists\",\n                });\n            }\n            return { config: triggerInfo.config };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves information about a single trigger.\n     *\n     * @param {TriggerSingleParam} data The data for the request.\n     * @returns {Promise<SingleTriggerRes>} A promise that resolves to the trigger information.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getTriggerInfo(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTriggerInfo\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZSingleTriggerParam.parse(data);\n            const res = await apiClient.triggers.getTriggerInfoV2({\n                client: this.client,\n                path: {\n                    triggerName: parsedData.triggerName || parsedData.triggerId || \"\",\n                },\n            });\n            // Bad type inference\n            const trigger = res.data;\n            if (!trigger) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.BACKEND.NOT_FOUND, {\n                    message: \"Trigger info not found\",\n                    description: \"Trigger info not found\",\n                    possibleFix: \"Pass a check if trigger exists\",\n                });\n            }\n            return trigger;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Setup a trigger for a connected account.\n     *\n     * @param {SetupTriggerData} data The data for the request.\n     * @returns {Promise<SetupTriggerResponse>} A promise that resolves to the setup trigger response.\n     * @throws {ComposioError} If the request fails.\n     */\n    async setup(params) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"setup\",\n            file: this.fileName,\n            params: params,\n        });\n        try {\n            const parsedData = ZTriggerSetupParam.parse(params);\n            const response = await apiClient.triggers.enableTrigger({\n                client: this.client,\n                path: {\n                    connectedAccountId: parsedData.connectedAccountId,\n                    triggerName: parsedData.triggerName,\n                },\n                body: {\n                    triggerConfig: parsedData.config || {},\n                },\n                throwOnError: true,\n            });\n            const { triggerId, status } = response.data;\n            return {\n                triggerId: triggerId,\n                triggerName: parsedData.triggerName,\n                status,\n                triggerInstanceId: triggerId,\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Enables a trigger for a connected account.\n     *\n     * @param {triggerId,triggerInstanceId} data The data for the request.\n     * @returns {Promise<boolean>} A promise that resolves to the response of the enable request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async enable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"enable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const finalTriggerId = data.triggerId || data.triggerInstanceId;\n            if (!finalTriggerId) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: \"Trigger ID is required\",\n                    description: \"Trigger ID is required\",\n                    possibleFix: \"Pass either triggerId or triggerInstanceId\",\n                });\n            }\n            await apiClient.triggers.switchTriggerInstanceStatus({\n                client: this.client,\n                path: {\n                    triggerId: finalTriggerId,\n                },\n                body: {\n                    enabled: true,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Disables a trigger for a connected account.\n     *\n     * @param {triggerId,triggerInstanceId} data The data for the request.\n     * @returns {Promise<boolean>} A promise that resolves to the response of the disable request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async disable(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"disable\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const finalTriggerId = data.triggerId || data.triggerInstanceId;\n            if (!finalTriggerId) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: \"Trigger ID is required\",\n                    description: \"Trigger ID is required\",\n                    possibleFix: \"Pass either triggerId or triggerInstanceId\",\n                });\n            }\n            await apiClient.triggers.switchTriggerInstanceStatus({\n                client: this.client,\n                path: {\n                    triggerId: finalTriggerId,\n                },\n                body: {\n                    enabled: false,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Deletes a trigger for a connected account.\n     *\n     * @param {TriggerInstanceItems} data The data for the request.\n     * @returns {Promise<boolean>} A promise that resolves to the response of the delete request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async delete(data) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"delete\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const parsedData = ZTriggerInstanceItems.parse(data);\n            await apiClient.triggers.deleteTrigger({\n                client: this.client,\n                path: {\n                    triggerInstanceId: parsedData.triggerInstanceId,\n                },\n            });\n            return {\n                status: \"success\",\n            };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    async subscribe(fn, filters = {}) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"subscribe\",\n            file: this.fileName,\n            params: { filters },\n        });\n        if (!fn)\n            throw new Error(\"Function is required for trigger subscription\");\n        const clientId = await this.backendClient.getClientId();\n        await PusherUtils.getPusherClient(this.backendClient.baseUrl, this.backendClient.apiKey);\n        const shouldSendTrigger = (data) => {\n            if (Object.keys(filters).length === 0)\n                return true;\n            else {\n                return ((!filters.appName ||\n                    data.appName.toLowerCase() === filters.appName.toLowerCase()) &&\n                    (!filters.triggerId ||\n                        data.metadata.id.toLowerCase() ===\n                            filters.triggerId.toLowerCase()) &&\n                    (!filters.connectionId ||\n                        data.metadata.connectionId.toLowerCase() ===\n                            filters.connectionId.toLowerCase()) &&\n                    (!filters.triggerName ||\n                        data.metadata.triggerName.toLowerCase() ===\n                            filters.triggerName.toLowerCase()) &&\n                    (!filters.entityId ||\n                        data.metadata.connection.clientUniqueUserId.toLowerCase() ===\n                            filters.entityId.toLowerCase()) &&\n                    (!filters.integrationId ||\n                        data.metadata.connection.integrationId.toLowerCase() ===\n                            filters.integrationId.toLowerCase()));\n            }\n        };\n        logger.debug(\"Subscribing to triggers\", filters);\n        PusherUtils.triggerSubscribe(clientId, (data) => {\n            if (shouldSendTrigger(data)) {\n                fn(data);\n            }\n        });\n    }\n    async unsubscribe() {\n        const clientId = await this.backendClient.getClientId();\n        PusherUtils.triggerUnsubscribe(clientId);\n    }\n}\n\nconst LABELS = {\n    PRIMARY: \"primary\",\n};\nclass Entity {\n    constructor(backendClient, id = \"default\") {\n        this.fileName = \"js/src/sdk/models/Entity.ts\";\n        this.backendClient = backendClient;\n        this.id = id;\n        this.triggerModel = new Triggers(this.backendClient, this.backendClient.instance);\n        this.actionsModel = new Actions(this.backendClient, this.backendClient.instance);\n        this.apps = new Apps(this.backendClient, this.backendClient.instance);\n        this.connectedAccounts = new ConnectedAccounts(this.backendClient, this.backendClient.instance);\n        this.integrations = new Integrations(this.backendClient, this.backendClient.instance);\n        this.activeTriggers = new ActiveTriggers(this.backendClient, this.backendClient.instance);\n    }\n    /**\n     * Executes an action for an entity.\n     *\n     * @param {string} actionName The name of the action to execute.\n     * @param {Record<string, unknown>} params The parameters for the action.\n     * @param {string} text The text to pass to the action. This can be to perform NLA execution\n     * @param {string} connectedAccountId The ID of the connected account to use for the action.\n     * @returns {Promise<ActionExecuteResponse>} A promise that resolves to the response from the action execution.\n     * @throws {ComposioError} If the request fails.\n     */\n    async execute({ actionName, params, text, connectedAccountId, }) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"execute\",\n            file: this.fileName,\n            params: { actionName, params, text, connectedAccountId },\n        });\n        try {\n            ZExecuteActionParams$1.parse({\n                actionName,\n                params,\n                text,\n                connectedAccountId,\n            });\n            const action = await this.actionsModel.get({\n                actionName: actionName,\n            });\n            if (!action) {\n                throw new Error(`Could not find action: ${actionName}`);\n            }\n            const app = await this.apps.get({\n                appKey: action.appKey,\n            });\n            if (app.no_auth) {\n                return this.actionsModel.execute({\n                    actionName: actionName,\n                    requestBody: {\n                        input: params,\n                        appName: action.appKey,\n                    },\n                });\n            }\n            const connectedAccount = await this.getConnection({\n                app: action.appKey,\n                connectedAccountId,\n            });\n            if (!connectedAccount) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                    message: `Could not find a connection with app='${action.appKey}' and entity='${this.id}'`,\n                    description: `Could not find a connection with app='${action.appKey}' and entity='${this.id}'`,\n                });\n            }\n            return this.actionsModel.execute({\n                actionName: actionName,\n                requestBody: {\n                    // @ts-ignore\n                    connectedAccountId: connectedAccount === null || connectedAccount === void 0 ? void 0 : connectedAccount.id,\n                    input: params,\n                    appName: action.appKey,\n                    text: text,\n                },\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.\n     *\n     * This method allows clients to fetch the necessary parameters for a specific authentication scheme of an app by providing its unique key and the authentication scheme.\n     *\n     * @param {ConnectionParams} data The data for the request, including the app's unique key and the authentication scheme.\n     * @returns {Promise<RequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getConnection({ app, appName, connectedAccountId }) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getConnection\",\n            file: this.fileName,\n            params: { app, appName, connectedAccountId },\n        });\n        try {\n            const finalApp = appName || app;\n            ZConnectionParams.parse({ app: finalApp, connectedAccountId });\n            if (!finalApp && !connectedAccountId) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                    message: \"App or connectedAccountId is required\",\n                    description: \"App or connectedAccountId is required\",\n                });\n            }\n            if (connectedAccountId) {\n                return await this.connectedAccounts.get({\n                    connectedAccountId,\n                });\n            }\n            let latestAccount = null;\n            let latestCreationDate = null;\n            const connectedAccounts = await this.connectedAccounts.list({\n                user_uuid: this.id,\n            });\n            for (const account of connectedAccounts.items) {\n                if ((account === null || account === void 0 ? void 0 : account.labels) && (account === null || account === void 0 ? void 0 : account.labels.includes(LABELS.PRIMARY))) {\n                    latestAccount = account;\n                    break;\n                }\n            }\n            if (!latestAccount) {\n                for (const connectedAccount of connectedAccounts.items) {\n                    if ((finalApp === null || finalApp === void 0 ? void 0 : finalApp.toLocaleLowerCase()) ===\n                        connectedAccount.appName.toLocaleLowerCase()) {\n                        const creationDate = new Date(connectedAccount.createdAt);\n                        if ((!latestAccount ||\n                            (latestCreationDate && creationDate > latestCreationDate)) &&\n                            connectedAccount.status === \"ACTIVE\") {\n                            latestCreationDate = creationDate;\n                            latestAccount = connectedAccount;\n                        }\n                    }\n                }\n            }\n            if (!latestAccount) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                    message: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                    description: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                });\n            }\n            const connectedAccount = await this.connectedAccounts.get({\n                connectedAccountId: latestAccount.id,\n            });\n            if (!connectedAccount) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                    message: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                    description: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                });\n            }\n            return connectedAccount;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.\n     *\n     * This method allows clients to setup a trigger for an app by providing its unique key and the trigger name.\n     *\n     * @param {TriggerSubscribeParam} data The data for the request, including the app's unique key and the trigger name.\n     * @returns {Promise<RequiredParamsResponse>} A promise that resolves to the required parameters for the authentication scheme.\n     * @throws {ComposioError} If the request fails.\n     */\n    async setupTrigger({ app, appName, triggerName, config, }) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"setupTrigger\",\n            file: this.fileName,\n            params: { app, appName, triggerName, config },\n        });\n        try {\n            const finalApp = appName || app;\n            ZTriggerSubscribeParam.parse({ app: finalApp, triggerName, config });\n            const connectedAccount = await this.getConnection({ app: finalApp });\n            if (!connectedAccount) {\n                throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                    message: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                    description: `Could not find a connection with app='${finalApp}' and entity='${this.id}'`,\n                });\n            }\n            const trigger = await this.triggerModel.setup({\n                connectedAccountId: connectedAccount.id,\n                triggerName,\n                config,\n            });\n            return trigger;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves the required parameters for a specific authentication scheme of an app in the Composio platform.\n     *\n     * This method allows clients to disable a trigger by providing its trigger ID.\n     *\n     * @param {string} triggerId The ID of the trigger to disable.\n     * @returns {Promise<{ status: string }>} A promise that resolves to the status of the trigger disablement.\n     * @throws {ComposioError} If the request fails.\n     */\n    async disableTrigger(triggerId) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"disableTrigger\",\n            file: this.fileName,\n            params: { triggerId },\n        });\n        try {\n            await this.activeTriggers.disable({ triggerId: triggerId });\n            return { status: \"success\" };\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves all connections for an entity.\n     *\n     * @returns {Promise<ConnectionItem[]>} A promise that resolves to an array of connection items.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getConnections() {\n        /**\n         * Get all connections for an entity.\n         */\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getConnections\",\n            file: this.fileName,\n            params: {},\n        });\n        try {\n            const connectedAccounts = await this.connectedAccounts.list({\n                user_uuid: this.id,\n            });\n            return connectedAccounts.items;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Retrieves all active triggers for an entity.\n     *\n     * @returns {Promise<ActiveTrigger[]>} A promise that resolves to an array of active triggers.\n     * @throws {ComposioError} If the request fails.\n     */\n    async getActiveTriggers() {\n        /**\n         * Get all active triggers for an entity.\n         */\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getActiveTriggers\",\n            file: this.fileName,\n            params: {},\n        });\n        try {\n            const connectedAccounts = await this.getConnections();\n            const activeTriggers = await this.activeTriggers.list({\n                // @ts-ignore\n                connectedAccountIds: connectedAccounts\n                    .map((account) => account.id)\n                    .join(\",\"),\n            });\n            return activeTriggers;\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Initiate a connection for an entity.\n     * @param {InitiateConnectionParams} data The data for the request, including the app's unique key and the authentication scheme.\n     * @returns {Promise<ConnectionRequest>} A promise that resolves to the connection request.\n     * @throws {ComposioError} If the request fails.\n     */\n    async initiateConnection(data) {\n        var _a, _b;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"initiateConnection\",\n            file: this.fileName,\n            params: { data },\n        });\n        try {\n            const { appName, authMode, authConfig, integrationId, connectionParams, redirectUri, labels, } = ZInitiateConnectionParams.parse(data);\n            // Initiate the connection process\n            return this.connectedAccounts.initiate({\n                authMode: authMode,\n                authConfig: authConfig,\n                integrationId: integrationId,\n                appName: appName,\n                entityId: this.id,\n                redirectUri: redirectUri || ((_a = data.config) === null || _a === void 0 ? void 0 : _a.redirectUrl) || \"\",\n                connectionParams: connectionParams,\n                labels: labels || ((_b = data.config) === null || _b === void 0 ? void 0 : _b.labels) || [],\n            });\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n}\n\nconst removeTrailingSlashIfExists = (str) => str.replace(/\\/+$/, \"\");\n\n/**\n * Class representing the details required to initialize and configure the API client.\n */\nclass AxiosBackendClient {\n    /**\n     * Creates an instance of apiClientDetails.\n     * @param {string} apiKey - The API key for client initialization.\n     * @param {string} baseUrl - The base URL for the API client.\n     * @param {string} runtime - The runtime environment identifier.\n     * @throws Will throw an error if the API key is not provided.\n     */\n    constructor(apiKey, baseUrl, runtime) {\n        this.runtime = runtime || \"\";\n        this.apiKey = apiKey;\n        this.baseUrl = removeTrailingSlashIfExists(baseUrl);\n        this.instance = clientAxios.createClient(clientAxios.createConfig({\n            baseURL: this.baseUrl,\n            headers: {\n                // common: {\n                \"X-API-KEY\": `${this.apiKey}`,\n                \"X-SOURCE\": \"js_sdk\",\n                \"X-RUNTIME\": this.runtime,\n                // }\n            },\n        }));\n        if (!apiKey) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.API_KEY_UNAVAILABLE, {\n                message: \"API key is not available\",\n                description: \"The API key required for authentication is not provided. You can get the API key from the Composio dashboard.\",\n                possibleFix: \"Please provide the API key in the constructor\",\n            });\n        }\n        // Validate baseUrl\n        if (!baseUrl.startsWith(\"http://\") && !baseUrl.startsWith(\"https://\")) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.BASE_URL_NOT_REACHABLE, {\n                message: `🔗 Base URL ${baseUrl} is not valid`,\n                description: \"The composio backend URL provided is not valid\",\n            });\n        }\n        this.initializeApiClient();\n    }\n    /**\n     * Retrieves the client ID from the user's information.\n     * @returns {Promise<string>} A promise that resolves to the client ID.\n     * @throws Will throw an error if the HTTP request fails.\n     */\n    async getClientId() {\n        var _a;\n        try {\n            const { data } = await apiClient.clientAuth.getUserInfo({\n                client: this.instance,\n            });\n            return ((_a = data === null || data === void 0 ? void 0 : data.client) === null || _a === void 0 ? void 0 : _a.id) || \"\";\n        }\n        catch (error) {\n            throw CEG.handleAllError(error);\n        }\n    }\n    /**\n     * Initializes the API client with the provided configuration.\n     * @private\n     */\n    initializeApiClient() {\n        this.instance.setConfig({\n            baseURL: removeTrailingSlashIfExists(this.baseUrl),\n            headers: {\n                common: {\n                    \"X-API-KEY\": `${this.apiKey}`,\n                    \"X-SOURCE\": \"js_sdk\",\n                    \"X-RUNTIME\": this.runtime,\n                },\n            },\n            throwOnError: true,\n        });\n        // setAxiosClientConfig(this.instance.instance);\n    }\n    getAxiosInstance() {\n        return this.instance.instance;\n    }\n}\n\n// File path helpers\nconst userDataPath = () => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const path = __webpack_require__(/*! path */ \"path\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const os = __webpack_require__(/*! os */ \"os\");\n        return path.join(os.homedir(), COMPOSIO_DIR, USER_DATA_FILE_NAME);\n    }\n    catch (_error) {\n        return null;\n    }\n};\nconst getUserDataJson = () => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const data = fs.readFileSync(userDataPath(), \"utf8\");\n        return JSON.parse(data);\n    }\n    catch (_error) {\n        return {};\n    }\n};\n// Axios configuration\nconst setAxiosClientConfig = (axiosClientInstance) => {\n    axiosClientInstance.interceptors.request.use((request) => {\n        var _a;\n        const body = request.data ? JSON.stringify(request.data) : \"\";\n        // set x-request-id header\n        const requestId = getUUID();\n        request.headers[\"x-request-id\"] = requestId;\n        request.metadata = {\n            startTime: Date.now(),\n            requestId,\n        };\n        logger.debug(`API Req [${(_a = request.method) === null || _a === void 0 ? void 0 : _a.toUpperCase()}] ${request.url}, x-request-id: ${requestId}`, {\n            ...(body && { body }),\n            query: request.params,\n        });\n        return request;\n    });\n    axiosClientInstance.interceptors.response.use((response) => {\n        var _a, _b, _c;\n        const method = (_a = response.config.method) === null || _a === void 0 ? void 0 : _a.toUpperCase();\n        const responseSize = Math.round(JSON.stringify(response.data).length / 1024);\n        const requestStartTime = (_b = response.config\n            .metadata) === null || _b === void 0 ? void 0 : _b.startTime;\n        const responseTime = requestStartTime ? Date.now() - requestStartTime : 0;\n        const status = response.status;\n        const requestId = response.headers[\"x-request-id\"] ||\n            ((_c = response.config.metadata) === null || _c === void 0 ? void 0 : _c.requestId);\n        // @ts-expect-error Error with metadata type\n        response[\"metadata\"] = {\n            responseTime,\n            responseSize,\n            requestId,\n        };\n        logger.debug(`API Res [${method}] ${response.config.url} - ${status} - ${responseSize} KB ${responseTime}ms`);\n        return response;\n    }, (error) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        const requestStartTime = (_b = (_a = error.config) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b.startTime;\n        const requestStartTimeId = (_d = (_c = error.config) === null || _c === void 0 ? void 0 : _c.metadata) === null || _d === void 0 ? void 0 : _d.requestId;\n        const responseTime = requestStartTime ? Date.now() - requestStartTime : 0;\n        const status = ((_e = error.response) === null || _e === void 0 ? void 0 : _e.status) || \"Unknown\";\n        const length = ((_g = JSON.stringify((_f = error.response) === null || _f === void 0 ? void 0 : _f.data)) === null || _g === void 0 ? void 0 : _g.length) || 0;\n        const responseSize = Math.round(length / 1024);\n        const requestId = ((_j = (_h = error.response) === null || _h === void 0 ? void 0 : _h.headers) === null || _j === void 0 ? void 0 : _j[\"x-request-id\"]) || requestStartTimeId;\n        const metadata = {\n            responseTime,\n            responseSize,\n            requestId,\n        };\n        // @ts-expect-error Error with metadata type\n        error.metadata = metadata;\n        logger.debug(`API Error [${status}] ${(_l = (_k = error.config) === null || _k === void 0 ? void 0 : _k.method) === null || _l === void 0 ? void 0 : _l.toUpperCase()} ${(_m = error.config) === null || _m === void 0 ? void 0 : _m.url} - ${status} - ${responseTime}ms, x-request-id: ${requestId}`, {\n            headers: (_o = error.response) === null || _o === void 0 ? void 0 : _o.headers,\n            data: (_p = error.response) === null || _p === void 0 ? void 0 : _p.data,\n            error: error.message,\n            responseTime,\n        });\n        return Promise.reject(error);\n    });\n};\n// Client configuration functions\nfunction getSDKConfig(baseUrl, apiKey) {\n    const userData = getUserDataJson();\n    const { api_key: apiKeyFromUserConfig, base_url: baseURLFromUserConfig } = userData;\n    const baseURLParsed = baseUrl ||\n        getEnvVariable(\"COMPOSIO_BASE_URL\") ||\n        baseURLFromUserConfig ||\n        DEFAULT_BASE_URL;\n    const apiKeyParsed = apiKey || getEnvVariable(\"COMPOSIO_API_KEY\") || apiKeyFromUserConfig || \"\";\n    return { baseURL: baseURLParsed, apiKey: apiKeyParsed };\n}\n\nconst isNewerVersion = (v1, v2) => {\n    const parts1 = v1.split(\".\").map(Number);\n    const parts2 = v2.split(\".\").map(Number);\n    for (let i = 0; i < 3; i++) {\n        if (parts1[i] > parts2[i])\n            return true;\n        if (parts1[i] < parts2[i])\n            return false;\n    }\n    return false;\n};\n\nclass Composio {\n    /**\n     * Initializes a new instance of the Composio class.\n     *\n     * @param {Object} config - Configuration object for the Composio SDK\n     * @param {string} [config.apiKey] - The API key for authenticating with the Composio backend. Can also be set locally in an environment variable.\n     * @param {string} [config.baseUrl] - The base URL for the Composio backend. By default, it is set to the production URL.\n     * @param {string} [config.runtime] - The runtime environment for the SDK.\n     * @param {boolean} [config.allowTracing] - Whether to allow tracing for the SDK.\n     */\n    constructor(config = {}) {\n        this.fileName = \"js/src/sdk/index.ts\";\n        // Parse the base URL and API key, falling back to environment variables or defaults if not provided\n        const { baseURL: baseURLParsed, apiKey: apiKeyParsed } = getSDKConfig(config === null || config === void 0 ? void 0 : config.baseUrl, config === null || config === void 0 ? void 0 : config.apiKey);\n        if (IS_DEVELOPMENT_OR_CI) {\n            logger.info(`Initializing Composio w API Key: [REDACTED] and baseURL: ${baseURLParsed}`);\n        }\n        ComposioSDKContext.apiKey = apiKeyParsed;\n        ComposioSDKContext.baseURL = baseURLParsed;\n        ComposioSDKContext.frameworkRuntime = config === null || config === void 0 ? void 0 : config.runtime;\n        ComposioSDKContext.composioVersion = COMPOSIO_VERSION;\n        ComposioSDKContext.allowTracing = config === null || config === void 0 ? void 0 : config.allowTracing;\n        // by default, generate a sessionId unless allowTracing is explicitly set to false\n        ComposioSDKContext.sessionId =\n            (config === null || config === void 0 ? void 0 : config.allowTracing) !== false ? getUUID() : undefined;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_INITIALIZED, {});\n        if (!apiKeyParsed) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.API_KEY_UNAVAILABLE, {\n                message: \"🔑 API Key is not provided\",\n                description: \"You need to provide it in the constructor or as an environment variable COMPOSIO_API_KEY\",\n                possibleFix: \"Please provide a valid API Key. You can get it from https://app.composio.dev/settings OR Check if you are passing it as an object in the constructor like - { apiKey: 'your-api-key' }\",\n            });\n        }\n        logger.info(`Initializing Composio w API Key: [REDACTED] and baseURL: ${baseURLParsed}`);\n        // Initialize the BackendClient with the parsed API key and base URL.\n        this.backendClient = new AxiosBackendClient(apiKeyParsed, baseURLParsed, config === null || config === void 0 ? void 0 : config.runtime);\n        setAxiosClientConfig(this.backendClient.getAxiosInstance());\n        // Instantiate models with dependencies as needed.\n        this.connectedAccounts = new ConnectedAccounts(this.backendClient, this.backendClient.instance);\n        this.triggers = new Triggers(this.backendClient, this.backendClient.instance);\n        this.apps = new Apps(this.backendClient, this.backendClient.instance);\n        this.actions = new Actions(this.backendClient, this.backendClient.instance);\n        this.integrations = new Integrations(this.backendClient, this.backendClient.instance);\n        this.activeTriggers = new ActiveTriggers(this.backendClient, this.backendClient.instance);\n        this.checkForLatestVersionFromNPM();\n    }\n    /**\n     * Checks for the latest version of the Composio SDK from NPM.\n     * If a newer version is available, it logs a warning to the console.\n     */\n    async checkForLatestVersionFromNPM() {\n        try {\n            const packageName = \"composio-core\";\n            const currentVersionFromPackageJson = COMPOSIO_VERSION;\n            const response = await axios.get(`https://registry.npmjs.org/${packageName}/latest`);\n            const latestVersion = response.data.version;\n            if (isNewerVersion(latestVersion, currentVersionFromPackageJson) &&\n                !IS_DEVELOPMENT_OR_CI) {\n                logger.info(`🚀 Upgrade available! Your composio-core version (${currentVersionFromPackageJson}) is behind. Latest version: ${latestVersion}.`);\n            }\n        }\n        catch (_error) {\n            // Ignore and do nothing\n        }\n    }\n    /**\n     * Retrieves an Entity instance associated with a given ID.\n     *\n     * @param {string} [id='default'] - The ID of the entity to retrieve.\n     * @returns {Entity} An instance of the Entity class.\n     */\n    getEntity(id = \"default\") {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getEntity\",\n            file: this.fileName,\n            params: { id },\n        });\n        return new Entity(this.backendClient, id);\n    }\n    async getExpectedParamsForUser(params) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getExpectedParamsForUser\",\n            file: this.fileName,\n            params: params,\n        });\n        const { app } = params;\n        let { integrationId } = params;\n        if (integrationId === null && app === null) {\n            throw new Error(\"Both `integration_id` and `app` cannot be None\");\n        }\n        if (!integrationId) {\n            try {\n                const integrations = await this.integrations.list({\n                    appName: app,\n                    showDisabled: false,\n                });\n                if (params.authScheme && integrations) {\n                    integrations.items = integrations.items.filter((integration) => integration.authScheme === params.authScheme);\n                }\n                integrationId = (_a = integrations === null || integrations === void 0 ? void 0 : integrations.items[0]) === null || _a === void 0 ? void 0 : _a.id;\n            }\n            catch (_) {\n                // do nothing\n            }\n        }\n        let integration = integrationId\n            ? await this.integrations.get({\n                integrationId: integrationId,\n            })\n            : undefined;\n        if (integration) {\n            return {\n                expectedInputFields: integration.expectedInputFields,\n                integrationId: integration.id,\n                authScheme: integration.authScheme,\n            };\n        }\n        const appInfo = await this.apps.get({\n            appKey: app.toLocaleLowerCase(),\n        });\n        const preferredAuthScheme = [\n            \"OAUTH2\",\n            \"OAUTH1\",\n            \"API_KEY\",\n            \"BASIC\",\n            \"BEARER_TOKEN\",\n            \"BASIC_WITH_JWT\",\n        ];\n        let schema = params.authScheme;\n        if (!schema) {\n            for (const scheme of preferredAuthScheme) {\n                if ((_b = appInfo.auth_schemes) === null || _b === void 0 ? void 0 : _b.map((_authScheme) => _authScheme.mode).includes(scheme)) {\n                    schema = scheme;\n                    break;\n                }\n            }\n        }\n        const hasTestConnectors = ((_d = (_c = appInfo.testConnectors) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0;\n        const authSchemeFields = (_f = (_e = appInfo.auth_schemes) === null || _e === void 0 ? void 0 : _e.find((_authScheme) => _authScheme.mode === schema)) === null || _f === void 0 ? void 0 : _f.fields;\n        const requiredCustomerFields = (_h = (_g = authSchemeFields === null || authSchemeFields === void 0 ? void 0 : authSchemeFields.filter((field) => !field.expected_from_customer)) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0;\n        const areNoFieldsRequiredForIntegration = hasTestConnectors || requiredCustomerFields === 0;\n        if (!areNoFieldsRequiredForIntegration) {\n            throw new Error(`No default credentials available for this app, please create new integration by going to app.composio.dev or through CLI - composio add ${appInfo.key}`);\n        }\n        const timestamp = new Date().toISOString().replace(/[-:.]/g, \"\");\n        const hasRelevantTestConnectors = params.authScheme\n            ? ((_k = (_j = appInfo.testConnectors) === null || _j === void 0 ? void 0 : _j.filter((connector) => connector.authScheme === params.authScheme)) === null || _k === void 0 ? void 0 : _k.length) > 0\n            : ((_l = appInfo.testConnectors) === null || _l === void 0 ? void 0 : _l.length) > 0;\n        if (hasRelevantTestConnectors) {\n            integration = await this.integrations.create({\n                appId: appInfo.appId,\n                name: `integration_${timestamp}`,\n                authScheme: schema,\n                authConfig: {},\n                useComposioAuth: true,\n            });\n            return {\n                expectedInputFields: integration === null || integration === void 0 ? void 0 : integration.expectedInputFields,\n                integrationId: integration === null || integration === void 0 ? void 0 : integration.id,\n                authScheme: integration === null || integration === void 0 ? void 0 : integration.authScheme,\n            };\n        }\n        if (!schema) {\n            throw new Error(`No supported auth scheme found for \\`${String(app)}\\`, ` +\n                \"Please create an integration and use the ID to \" +\n                \"get the expected parameters.\");\n        }\n        integration = await this.integrations.create({\n            appId: appInfo.appId,\n            name: `integration_${timestamp}`,\n            authScheme: schema,\n            authConfig: {},\n            useComposioAuth: false,\n        });\n        if (!integration) {\n            throw new Error(\"An unexpected error occurred while creating the integration, please create an integration manually and use its ID to get the expected parameters\");\n        }\n        return {\n            expectedInputFields: integration.expectedInputFields,\n            integrationId: integration.id,\n            authScheme: integration.authScheme,\n        };\n    }\n}\n\n/*\n    This is the schema for the raw action to be stored locally\n    Also returned by the API\n*/\nz.z.object({\n    name: z.z.string(),\n    display_name: z.z.string(),\n    description: z.z.string(),\n    appKey: z.z.string(),\n    appId: z.z.string(),\n    appName: z.z.string(),\n    logo: z.z.string(),\n    enabled: z.z.boolean(),\n    tags: z.z.array(z.z.string()),\n    parameters: z.z.object({\n        type: z.z.string(),\n        title: z.z.string(),\n        description: z.z.string(),\n        required: z.z.array(z.z.string()),\n        properties: z.z.record(z.z.any()),\n    }),\n    response: z.z.record(z.z.any()),\n    metadata: z.z.object({\n        name: z.z.string(),\n        toolName: z.z.string().optional(),\n    }),\n});\n/*\n    This is the schema for the params object in the ExecuteAction function\n*/\nconst ZExecuteActionParams = z.z.object({\n    action: z.z.string(),\n    params: z.z.record(z.z.any()).optional(),\n    entityId: z.z.string().optional(),\n    nlaText: z.z.string().optional(),\n    connectedAccountId: z.z.string().optional(),\n    config: z.z\n        .object({\n        labels: z.z.array(z.z.string()).optional(),\n    })\n        .optional(),\n});\nconst ZToolSchemaFilter = z.z.object({\n    actions: z.z.array(z.z.string()).optional(),\n    apps: z.z.array(z.z.string()).optional(),\n    tags: z.z.array(z.z.string()).optional(),\n    useCase: z.z.string().optional(),\n    useCaseLimit: z.z.number().optional(),\n    filterByAvailableApps: z.z.boolean().optional(),\n    integrationId: z.z.string().optional(),\n});\n\nclass ActionRegistry {\n    constructor(client) {\n        this.client = client;\n        this.customActions = new Map();\n    }\n    async createAction(options) {\n        var _a;\n        const { callback } = options;\n        if (typeof callback !== \"function\") {\n            throw new Error(\"Callback must be a function\");\n        }\n        if (!options.actionName) {\n            throw new Error(\"You must provide actionName for this action\");\n        }\n        if (!options.inputParams) {\n            options.inputParams = z.z.object({});\n        }\n        const params = options.inputParams;\n        const actionName = options.actionName || callback.name || \"\";\n        const paramsSchema = (await zodToJsonSchema.zodToJsonSchema(params, {\n            name: \"input\",\n        }));\n        const _params = paramsSchema.definitions.input.properties;\n        const composioSchema = {\n            name: actionName,\n            description: options.description,\n            parameters: {\n                title: actionName,\n                type: \"object\",\n                description: options.description,\n                required: paramsSchema.definitions.input.required || [],\n                properties: _params,\n            },\n            response: {\n                type: \"object\",\n                title: \"Response for \" + actionName,\n                properties: [],\n            },\n        };\n        this.customActions.set(((_a = options.actionName) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) || \"\", {\n            metadata: options,\n            schema: composioSchema,\n        });\n        return composioSchema;\n    }\n    async getActions({ actions, }) {\n        const actionsArr = [];\n        for (const name of actions) {\n            const lowerCaseName = name.toLowerCase();\n            if (this.customActions.has(lowerCaseName)) {\n                const action = this.customActions.get(lowerCaseName);\n                actionsArr.push(action.schema);\n            }\n        }\n        return actionsArr;\n    }\n    async getAllActions() {\n        return Array.from(this.customActions.values()).map((action) => action.schema);\n    }\n    async getToolName({ action, }) {\n        var _a;\n        if (!action) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                message: \"Action name is required\",\n                description: \"Please provide an action name to get its tool name\",\n            });\n        }\n        const lowerCaseName = action.toLowerCase();\n        return (_a = this.customActions.get(lowerCaseName)) === null || _a === void 0 ? void 0 : _a.metadata.toolName;\n    }\n    async executeAction(name, inputParams, metadata) {\n        const lowerCaseName = name.toLocaleLowerCase();\n        if (!this.customActions.has(lowerCaseName)) {\n            throw new Error(`Action with name ${name} does not exist`);\n        }\n        const action = this.customActions.get(lowerCaseName);\n        if (!action) {\n            throw new Error(`Action with name ${name} could not be retrieved`);\n        }\n        const { callback, toolName } = action.metadata || {};\n        let authCredentials = {};\n        if (toolName) {\n            const entity = await this.client.getEntity(metadata.entityId);\n            const connection = await entity.getConnection({\n                app: toolName,\n                connectedAccountId: metadata.connectionId,\n            });\n            if (!connection) {\n                throw new Error(`Connection with app name ${toolName} and entityId ${metadata.entityId} not found`);\n            }\n            const connectionParams = connection.connectionParams;\n            authCredentials = {\n                headers: connectionParams === null || connectionParams === void 0 ? void 0 : connectionParams.headers,\n                queryParams: connectionParams === null || connectionParams === void 0 ? void 0 : connectionParams.queryParams,\n                baseUrl: (connectionParams === null || connectionParams === void 0 ? void 0 : connectionParams.baseUrl) || (connectionParams === null || connectionParams === void 0 ? void 0 : connectionParams.base_url),\n            };\n        }\n        if (typeof callback !== \"function\") {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.COMMON.INVALID_PARAMS_PASSED, {\n                message: \"Callback must be a function\",\n                description: \"Please provide a valid callback function\",\n            });\n        }\n        const executeRequest = async (data) => {\n            try {\n                const { data: res } = await apiClient.actionsV2.executeWithHttpClient({\n                    client: this.client.backendClient.instance,\n                    body: {\n                        ...data,\n                        connectedAccountId: metadata === null || metadata === void 0 ? void 0 : metadata.connectionId,\n                    },\n                });\n                return res;\n            }\n            catch (error) {\n                throw CEG.handleAllError(error);\n            }\n        };\n        return await callback(inputParams, authCredentials, (data) => executeRequest(data));\n    }\n}\n\n/**\n * Gets the Composio directory.\n * @param createDirIfNotExists - Whether to create the directory if it doesn't exist.\n * @returns The path to the Composio directory.\n */\nconst getComposioDir = (createDirIfNotExists = false) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const os = __webpack_require__(/*! os */ \"os\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const path = __webpack_require__(/*! path */ \"path\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const composioDir = path.join(os.homedir(), COMPOSIO_DIR);\n        if (createDirIfNotExists && !fs.existsSync(composioDir)) {\n            fs.mkdirSync(composioDir, { recursive: true });\n        }\n        return composioDir;\n    }\n    catch (_error) {\n        return null;\n    }\n};\n/**\n * Gets the Composio temporary files directory.\n * @param createDirIfNotExists - Whether to create the directory if it doesn't exist.\n * @returns The path to the Composio temporary files directory.\n */\nconst getComposioTempFilesDir = (createDirIfNotExists = false) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const os = __webpack_require__(/*! os */ \"os\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const path = __webpack_require__(/*! path */ \"path\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const composioFilesDir = path.join(os.homedir(), COMPOSIO_DIR, TEMP_FILES_DIRECTORY_NAME);\n        if (createDirIfNotExists && !fs.existsSync(composioFilesDir)) {\n            fs.mkdirSync(composioFilesDir, { recursive: true });\n        }\n        return composioFilesDir;\n    }\n    catch (_error) {\n        return null;\n    }\n};\n/**\n * Saves a file to the Composio directory.\n * @param file - The name of the file to save.\n * @param content - The content of the file to save. Should be a string.\n * @param isTempFile - Whether the file is a temporary file.\n * @returns The path to the saved file.\n */\nconst saveFile = (file, content, isTempFile = false) => {\n    try {\n        const path = __webpack_require__(/*! path */ \"path\");\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        const fs = __webpack_require__(/*! fs */ \"fs\");\n        const composioFilesDir = isTempFile\n            ? getComposioTempFilesDir(true)\n            : getComposioDir(true);\n        const filePath = path.join(composioFilesDir, path.basename(file));\n        if (Buffer.isBuffer(content)) {\n            fs.writeFileSync(filePath, content);\n        }\n        else {\n            fs.writeFileSync(filePath, content, \"utf8\");\n        }\n        return filePath;\n    }\n    catch (_error) {\n        return null;\n    }\n};\n\nconst readFileContent = async (path) => {\n    try {\n        const content = (__webpack_require__(/*! fs */ \"fs\").readFileSync)(path);\n        return {\n            content: content.toString(\"base64\"),\n            mimeType: \"application/octet-stream\",\n        };\n    }\n    catch (error) {\n        throw new Error(`Error reading file at ${path}: ${error}`);\n    }\n};\nconst readFileContentFromURL = async (path) => {\n    const response = await axios.get(path, {\n        responseType: \"arraybuffer\",\n    });\n    const content = Buffer.from(response.data);\n    const mimeType = response.headers[\"content-type\"] || \"application/octet-stream\";\n    return {\n        content: content.toString(\"base64\"),\n        mimeType,\n    };\n};\nconst uploadFileToS3 = async (content, actionName, appName, mimeType, client) => {\n    var _a;\n    const extension = mimeType.split(\"/\")[1] || \"bin\";\n    const response = await apiClient.actionsV2.createFileUploadUrl({\n        client: client,\n        body: {\n            action: actionName,\n            app: appName,\n            filename: `${actionName}_${Date.now()}.${extension}`,\n            mimetype: mimeType,\n            md5: crypto\n                .createHash(\"md5\")\n                .update(Buffer.from(content, \"base64\"))\n                .digest(\"hex\"),\n        },\n        path: {\n            fileType: \"request\",\n        },\n    });\n    const data = response.data;\n    const signedURL = data.url;\n    const s3key = data.key;\n    try {\n        const buffer = Buffer.from(content, \"base64\");\n        await axios.put(signedURL, buffer, {\n            headers: {\n                \"Content-Type\": mimeType,\n                \"Content-Length\": buffer.length,\n            },\n        });\n    }\n    catch (e) {\n        const error = e;\n        if (error instanceof axios.AxiosError && ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 403) {\n            return signedURL;\n        }\n        throw new Error(`Error uploading file to S3: ${error}`);\n    }\n    return s3key;\n};\nconst getFileDataAfterUploadingToS3 = async (path, actionName, client) => {\n    const isURL = path.startsWith(\"http\");\n    const fileData = isURL\n        ? await readFileContentFromURL(path)\n        : await readFileContent(path);\n    const s3key = await uploadFileToS3(fileData.content, actionName, actionName, fileData.mimeType, client);\n    return {\n        name: pathModule.basename(path) || `${actionName}_${Date.now()}`,\n        mimetype: fileData.mimeType,\n        s3key: s3key,\n    };\n};\nconst downloadFileFromS3 = async ({ actionName, s3Url, mimeType, }) => {\n    const response = await axios.get(s3Url, {\n        responseType: \"arraybuffer\",\n    });\n    const extension = mimeType.split(\"/\")[1] || \"txt\";\n    const fileName = `${actionName}_${Date.now()}.${extension}`;\n    const filePath = saveFile(fileName, response.data, true);\n    return {\n        name: fileName,\n        mimeType: mimeType,\n        s3Key: s3Url,\n        filePath: filePath,\n    };\n};\n\nconst FILE_SUFFIX = \"_schema_parsed_file\";\nconst convertFileSchemaProperty = (key, property) => {\n    if (!property.file_uploadable) {\n        return property;\n    }\n    return {\n        keyName: `${key}${FILE_SUFFIX}`,\n        type: \"string\",\n        description: property.description,\n    };\n};\nconst processFileUpload = async (params, actionName, client) => {\n    const result = { ...params };\n    for (const [key, value] of Object.entries(result)) {\n        if (!key.endsWith(FILE_SUFFIX))\n            continue;\n        const originalKey = key.replace(FILE_SUFFIX, \"\");\n        const fileData = await getFileDataAfterUploadingToS3(value, actionName, client);\n        result[originalKey] = fileData;\n        delete result[key];\n    }\n    return result;\n};\nconst FILE_INPUT_PROCESSOR = async ({ params, actionName, client, }) => {\n    return processFileUpload(params, actionName, client);\n};\nconst FILE_DOWNLOADABLE_PROCESSOR = async ({ actionName, toolResponse, }) => {\n    const result = JSON.parse(JSON.stringify(toolResponse));\n    for (const [key, value] of Object.entries(toolResponse.data)) {\n        const fileData = value;\n        if (!(fileData === null || fileData === void 0 ? void 0 : fileData.s3url))\n            continue;\n        const downloadedFile = await downloadFileFromS3({\n            actionName,\n            s3Url: fileData.s3url,\n            mimeType: fileData.mimetype || \"application/txt\",\n        });\n        result.data[key] = {\n            uri: downloadedFile.filePath,\n            s3url: fileData.s3url,\n            mimeType: downloadedFile.mimeType,\n        };\n    }\n    return result;\n};\nconst FILE_SCHEMA_PROCESSOR = ({ toolSchema }) => {\n    const { properties, required: requiredProps = [] } = toolSchema.parameters;\n    const newProperties = { ...properties };\n    const newRequired = [...requiredProps];\n    for (const [key, property] of Object.entries(newProperties)) {\n        if (!property.file_uploadable)\n            continue;\n        const { type, keyName, description } = convertFileSchemaProperty(key, property);\n        newProperties[keyName] = {\n            title: property.title,\n            type,\n            description,\n        };\n        if (requiredProps.includes(key)) {\n            newRequired[newRequired.indexOf(key)] = keyName;\n        }\n        delete newProperties[key];\n    }\n    return {\n        ...toolSchema,\n        parameters: {\n            ...toolSchema.parameters,\n            properties: newProperties,\n            required: newRequired,\n        },\n    };\n};\n\nclass ComposioToolSet {\n    /**\n     * Creates a new instance of ComposioToolSet\n     * @param {Object} config - Configuration object\n     * @param {string|null} config.apiKey - API key for authentication\n     * @param {string|null} config.baseUrl - Base URL for API requests\n     * @param {string|null} config.runtime - Runtime environment\n     * @param {string} config.entityId - Entity ID for operations\n     * @param {Record<string, string>} config.connectedAccountIds - Map of app names to their connected account IDs\n     * @param {boolean} config.allowTracing - Whether to allow tracing for the SDK\n     */\n    constructor({ apiKey, baseUrl, runtime, entityId, connectedAccountIds, allowTracing, } = {}) {\n        this.entityId = \"default\";\n        this.connectedAccountIds = {};\n        this.internalProcessors = {\n            pre: [FILE_INPUT_PROCESSOR],\n            post: [FILE_DOWNLOADABLE_PROCESSOR],\n            schema: [FILE_SCHEMA_PROCESSOR],\n        };\n        this.userDefinedProcessors = {};\n        const clientApiKey = apiKey ||\n            getEnvVariable(\"COMPOSIO_API_KEY\") ||\n            getUserDataJson().api_key;\n        this.apiKey = clientApiKey;\n        this.client = new Composio({\n            apiKey: this.apiKey,\n            baseUrl: baseUrl || undefined,\n            runtime: runtime,\n            allowTracing: allowTracing || false,\n        });\n        this.runtime = runtime || null;\n        this.backendClient = this.client.backendClient;\n        this.connectedAccounts = this.client.connectedAccounts;\n        this.apps = this.client.apps;\n        this.actions = this.client.actions;\n        this.triggers = this.client.triggers;\n        this.integrations = this.client.integrations;\n        this.activeTriggers = this.client.activeTriggers;\n        this.connectedAccountIds = connectedAccountIds || {};\n        this.userActionRegistry = new ActionRegistry(this.client);\n        if (entityId && connectedAccountIds) {\n            logger.warn(\"When both entity and connectedAccountIds are provided, preference will be given to connectedAccountIds\");\n        }\n        if (connectedAccountIds) {\n            this.connectedAccountIds = connectedAccountIds;\n        }\n        if (entityId) {\n            this.entityId = entityId;\n        }\n    }\n    async getActionsSchema(filters = {}, _entityId) {\n        return this.getToolsSchema({\n            actions: filters.actions || [],\n        }, _entityId);\n    }\n    async getToolsSchema(filters, _entityId, _integrationId) {\n        var _a, _b;\n        const parsedFilters = ZToolSchemaFilter.parse(filters);\n        let actions = parsedFilters.actions;\n        if (_integrationId) {\n            const integration = await this.integrations.get({\n                integrationId: _integrationId,\n            });\n            if (integration === null || integration === void 0 ? void 0 : integration.limitedActions) {\n                if (!actions) {\n                    actions = [...integration.limitedActions];\n                }\n                else {\n                    const limitedActionsUppercase = integration.limitedActions.map((action) => action.toUpperCase());\n                    actions = actions.filter((action) => limitedActionsUppercase.includes(action.toUpperCase()));\n                }\n            }\n        }\n        const appActions = await this.client.actions.list({\n            apps: (_a = parsedFilters.apps) === null || _a === void 0 ? void 0 : _a.join(\",\"),\n            tags: (_b = parsedFilters.tags) === null || _b === void 0 ? void 0 : _b.join(\",\"),\n            useCase: parsedFilters.useCase,\n            actions: actions === null || actions === void 0 ? void 0 : actions.join(\",\"),\n            usecaseLimit: parsedFilters.useCaseLimit,\n            filterByAvailableApps: parsedFilters.filterByAvailableApps,\n        });\n        const customActions = await this.userActionRegistry.getAllActions();\n        const toolsWithCustomActions = customActions.filter((action) => {\n            const { name: actionName } = action || {};\n            return ((!filters.actions ||\n                filters.actions.some((name) => name.toLowerCase() === (actionName === null || actionName === void 0 ? void 0 : actionName.toLowerCase()))) &&\n                (!filters.tags ||\n                    filters.tags.some((tag) => tag.toLowerCase() === \"custom\")));\n        });\n        const toolsActions = [\n            ...((appActions === null || appActions === void 0 ? void 0 : appActions.items) || []),\n            ...toolsWithCustomActions,\n        ];\n        const allSchemaProcessor = [\n            ...this.internalProcessors.schema,\n            ...(this.userDefinedProcessors.schema\n                ? [this.userDefinedProcessors.schema]\n                : []),\n        ];\n        const processedTools = [];\n        // Iterate over the tools and process them\n        for (const tool of toolsActions) {\n            let schema = tool;\n            // Process the schema with all the processors\n            for (const processor of allSchemaProcessor) {\n                schema = await processor({\n                    actionName: schema === null || schema === void 0 ? void 0 : schema.name,\n                    toolSchema: schema,\n                });\n            }\n            processedTools.push(schema);\n        }\n        return processedTools;\n    }\n    async createAction(options) {\n        return this.userActionRegistry.createAction(options);\n    }\n    isCustomAction(action) {\n        return this.userActionRegistry\n            .getActions({ actions: [action] })\n            .then((actions) => actions.length > 0);\n    }\n    async getEntity(entityId) {\n        return this.client.getEntity(entityId);\n    }\n    async executeAction(functionParams) {\n        var _a;\n        const { action, params: inputParams = {}, entityId = this.entityId, nlaText = \"\", connectedAccountId, } = ZExecuteActionParams.parse({\n            action: functionParams.actionName || functionParams.action,\n            params: functionParams.params,\n            entityId: functionParams.entityId,\n            nlaText: functionParams.nlaText,\n            connectedAccountId: functionParams.connectedAccountId,\n        });\n        if (!entityId && !connectedAccountId) {\n            throw CEG.getCustomError(COMPOSIO_SDK_ERROR_CODES.SDK.NO_CONNECTED_ACCOUNT_FOUND, {\n                message: `No entityId or connectedAccountId provided`,\n                description: `Please provide either entityId or connectedAccountId`,\n            });\n        }\n        let params = inputParams || {};\n        const allInputProcessor = [\n            ...this.internalProcessors.pre,\n            ...(this.userDefinedProcessors.pre\n                ? [this.userDefinedProcessors.pre]\n                : []),\n        ];\n        for (const processor of allInputProcessor) {\n            params = await processor({\n                params: params,\n                actionName: action,\n                client: this.client.backendClient.instance,\n            });\n        }\n        // Custom actions are always executed in the host/local environment for JS SDK\n        if (await this.isCustomAction(action)) {\n            let accountId = connectedAccountId;\n            if (!accountId) {\n                const toolName = await this.userActionRegistry.getToolName({ action });\n                const connectedAccounts = await this.client.connectedAccounts.list({\n                    appNames: toolName,\n                    user_uuid: entityId,\n                    status: \"ACTIVE\",\n                    showActiveOnly: true,\n                });\n                accountId = (_a = connectedAccounts === null || connectedAccounts === void 0 ? void 0 : connectedAccounts.items[0]) === null || _a === void 0 ? void 0 : _a.id;\n            }\n            // allows the user to use custom actions and tools without a connected account\n            if (!accountId) {\n                logger.warn(\"No connected account found for the user. If your custom action requires a connected account, please double check if you have active accounts connected to it.\");\n            }\n            return this.userActionRegistry.executeAction(action, params, {\n                entityId: entityId,\n                connectionId: accountId,\n            });\n        }\n        const data = await this.client.getEntity(entityId).execute({\n            actionName: action,\n            params: params,\n            text: nlaText,\n            connectedAccountId: connectedAccountId,\n        });\n        return this.processResponse(data, {\n            action: action,\n            entityId: entityId,\n        });\n    }\n    async processResponse(data, meta) {\n        const allOutputProcessor = [\n            ...this.internalProcessors.post,\n            ...(this.userDefinedProcessors.post\n                ? [this.userDefinedProcessors.post]\n                : []),\n        ];\n        // Dirty way to avoid copy\n        let dataToReturn = JSON.parse(JSON.stringify(data));\n        for (const processor of allOutputProcessor) {\n            dataToReturn = await processor({\n                actionName: meta.action,\n                toolResponse: dataToReturn,\n            });\n        }\n        return dataToReturn;\n    }\n    async addSchemaProcessor(processor) {\n        if (typeof processor === \"function\") {\n            this.userDefinedProcessors.schema = processor;\n        }\n        else {\n            throw new Error(\"Invalid processor type\");\n        }\n        return this;\n    }\n    async addPreProcessor(processor) {\n        if (typeof processor === \"function\") {\n            this.userDefinedProcessors.pre = processor;\n        }\n        else {\n            throw new Error(\"Invalid processor type\");\n        }\n        return this;\n    }\n    async addPostProcessor(processor) {\n        if (typeof processor === \"function\") {\n            this.userDefinedProcessors.post = processor;\n        }\n        else {\n            throw new Error(\"Invalid processor type\");\n        }\n        return this;\n    }\n    async removePreProcessor() {\n        delete this.userDefinedProcessors.pre;\n    }\n    async removePostProcessor() {\n        delete this.userDefinedProcessors.post;\n    }\n    async removeSchemaProcessor() {\n        delete this.userDefinedProcessors.schema;\n    }\n}\n\nconst COMPOSIO_BASE_URL = \"https://backend.composio.dev\";\n\n/**\n * CloudflareToolSet provides integration with Cloudflare Workers AI\n * for executing AI tool calls and handling responses\n */\nclass CloudflareToolSet extends ComposioToolSet {\n    /**\n     * Initialize a new CloudflareToolSet instance\n     *\n     * @param config Configuration options including API key, base URL, entity ID and workspace config\n     */\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || COMPOSIO_BASE_URL,\n            runtime: null,\n            entityId: config.entityId || CloudflareToolSet.DEFAULT_ENTITY_ID,\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n        this.fileName = \"js/src/frameworks/cloudflare.ts\";\n    }\n    /**\n     * Retrieve available tools based on provided filters\n     *\n     * @param filters Optional filters for actions, apps, tags and use cases\n     * @returns Promise resolving to array of AI text generation tools\n     */\n    async getTools(filters) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTools\",\n            file: this.fileName,\n            params: filters,\n        });\n        const actions = await this.getToolsSchema(filters);\n        return (actions.map((action) => {\n            // Format the action schema for Cloudflare Workers AI\n            const formattedSchema = {\n                name: action.name,\n                description: action.description,\n                parameters: action.parameters,\n            };\n            const tool = {\n                type: \"function\",\n                function: formattedSchema,\n            };\n            return tool;\n        }) || []);\n    }\n    /**\n     * Execute a single tool call\n     *\n     * @param tool The tool to execute with name and arguments\n     * @param entityId Optional entity ID to execute the tool for\n     * @returns Promise resolving to stringified tool execution result\n     */\n    async executeToolCall(tool, entityId = null) {\n        var _a, _b, _c;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"executeToolCall\",\n            file: this.fileName,\n            params: { tool, entityId },\n        });\n        const toolSchema = await this.getToolsSchema({\n            actions: [tool.name],\n        });\n        const appName = (_b = (_a = toolSchema[0]) === null || _a === void 0 ? void 0 : _a.appName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n        const connectedAccountId = appName && ((_c = this.connectedAccountIds) === null || _c === void 0 ? void 0 : _c[appName]);\n        return JSON.stringify(await this.executeAction({\n            action: tool.name,\n            params: typeof tool.arguments === \"string\"\n                ? JSON.parse(tool.arguments)\n                : tool.arguments,\n            entityId: entityId || this.entityId,\n            connectedAccountId: connectedAccountId,\n        }));\n    }\n    /**\n     * Handle tool calls from AI text generation output\n     *\n     * @param result The AI text generation output containing tool calls\n     * @param entityId Optional entity ID to execute the tools for\n     * @returns Promise resolving to array of tool execution results\n     */\n    async handleToolCall(result, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"handleToolCall\",\n            file: this.fileName,\n            params: { result, entityId },\n        });\n        const outputs = [];\n        if (\"tool_calls\" in result && Array.isArray(result.tool_calls)) {\n            for (const tool_call of result.tool_calls) {\n                if (tool_call.name) {\n                    outputs.push(await this.executeToolCall(tool_call, entityId));\n                }\n            }\n        }\n        return outputs;\n    }\n}\n// Class constants\nCloudflareToolSet.FRAMEWORK_NAME = \"cloudflare\";\nCloudflareToolSet.DEFAULT_ENTITY_ID = \"default\";\n\nclass LangchainToolSet extends ComposioToolSet {\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || COMPOSIO_BASE_URL,\n            runtime: (config === null || config === void 0 ? void 0 : config.runtime) || LangchainToolSet.FRAMEWORK_NAME,\n            entityId: config.entityId || LangchainToolSet.DEFAULT_ENTITY_ID,\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n        this.fileName = \"js/src/frameworks/langchain.ts\";\n    }\n    _wrapTool(schema, entityId = null) {\n        var _a;\n        const action = schema[\"name\"];\n        const description = schema[\"description\"];\n        const appName = (_a = schema[\"appName\"]) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n        const func = async (...kwargs) => {\n            var _a;\n            const connectedAccountId = appName && ((_a = this.connectedAccountIds) === null || _a === void 0 ? void 0 : _a[appName]);\n            return JSON.stringify(await this.executeAction({\n                action,\n                params: kwargs[0],\n                entityId: entityId || this.entityId,\n                connectedAccountId: connectedAccountId,\n            }));\n        };\n        const parameters = jsonSchemaToModel(schema[\"parameters\"]);\n        // @TODO: Add escriiption an other stuff here\n        return new tools.DynamicStructuredTool({\n            name: action,\n            description,\n            schema: parameters,\n            func: func,\n        });\n    }\n    async getTools(filters = {}, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTools\",\n            file: this.fileName,\n            params: { filters, entityId },\n        });\n        const tools = await this.getToolsSchema(filters, entityId, filters.integrationId);\n        return tools.map((tool) => this._wrapTool(tool, entityId || this.entityId));\n    }\n}\n/**\n * Composio toolset for Langchain framework.\n *\n */\nLangchainToolSet.FRAMEWORK_NAME = \"langchain\";\nLangchainToolSet.DEFAULT_ENTITY_ID = \"default\";\n\nclass LangGraphToolSet extends LangchainToolSet {\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || COMPOSIO_BASE_URL,\n            entityId: config.entityId || LangGraphToolSet.DEFAULT_ENTITY_ID,\n            runtime: LangGraphToolSet.FRAMEWORK_NAME,\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n    }\n}\n/**\n * Composio toolset for Langgraph framework.\n *\n */\nLangGraphToolSet.FRAMEWORK_NAME = \"langGraph\";\nLangGraphToolSet.DEFAULT_ENTITY_ID = \"default\";\n\nclass OpenAIToolSet extends ComposioToolSet {\n    /**\n     * Composio toolset for OpenAI framework.\n     *\n     * Example:\n     * ```typescript\n     *\n     * ```\n     */\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || COMPOSIO_BASE_URL,\n            runtime: OpenAIToolSet.FRAMEWORK_NAME,\n            entityId: config.entityId || OpenAIToolSet.DEFAULT_ENTITY_ID,\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n        this.fileName = \"js/src/frameworks/openai.ts\";\n    }\n    async getTools(filters, entityId) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTools\",\n            file: this.fileName,\n            params: filters,\n        });\n        const mainActions = await this.getToolsSchema(filters, entityId, filters.integrationId);\n        return (mainActions.map((action) => {\n            const formattedSchema = {\n                name: action.name,\n                description: action.description,\n                parameters: action.parameters,\n            };\n            const tool = {\n                type: \"function\",\n                function: formattedSchema,\n            };\n            return tool;\n        }) || []);\n    }\n    async executeToolCall(tool, entityId = null) {\n        var _a, _b, _c;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"executeToolCall\",\n            file: this.fileName,\n            params: { tool, entityId },\n        });\n        const toolSchema = await this.getToolsSchema({\n            actions: [tool.function.name],\n        });\n        const appName = (_b = (_a = toolSchema[0]) === null || _a === void 0 ? void 0 : _a.appName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n        const connectedAccountId = appName && ((_c = this.connectedAccountIds) === null || _c === void 0 ? void 0 : _c[appName]);\n        return JSON.stringify(await this.executeAction({\n            action: tool.function.name,\n            params: JSON.parse(tool.function.arguments),\n            entityId: entityId || this.entityId,\n            connectedAccountId: connectedAccountId,\n        }));\n    }\n    async handleToolCall(chatCompletion, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"handleToolCall\",\n            file: this.fileName,\n            params: { chatCompletion, entityId },\n        });\n        const outputs = [];\n        for (const message of chatCompletion.choices) {\n            if (message.message.tool_calls) {\n                outputs.push(await this.executeToolCall(message.message.tool_calls[0], entityId));\n            }\n        }\n        return outputs;\n    }\n    async handleAssistantMessage(run, entityId = null) {\n        var _a, _b;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"handleAssistantMessage\",\n            file: this.fileName,\n            params: { run, entityId },\n        });\n        const tool_calls = ((_b = (_a = run.required_action) === null || _a === void 0 ? void 0 : _a.submit_tool_outputs) === null || _b === void 0 ? void 0 : _b.tool_calls) || [];\n        const tool_outputs = await Promise.all(tool_calls.map(async (tool_call) => {\n            logger.debug(`Executing tool call with ID: ${tool_call.function.name} and parameters: ${JSON.stringify(tool_call.function.arguments)}`);\n            const tool_response = await this.executeToolCall(tool_call, entityId || this.entityId);\n            logger.debug(`Received tool response: ${JSON.stringify(tool_response)}`);\n            return {\n                tool_call_id: tool_call.id,\n                output: JSON.stringify(tool_response),\n            };\n        }));\n        return tool_outputs;\n    }\n    async *waitAndHandleAssistantStreamToolCalls(client, runStream, thread, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"waitAndHandleAssistantStreamToolCalls\",\n            file: this.fileName,\n            params: { client, runStream, thread, entityId },\n        });\n        let runId = null;\n        // Start processing the runStream events\n        for await (const event of runStream) {\n            yield event; // Yield each event from the stream as it arrives\n            if (event.event === \"thread.run.created\") {\n                const { id } = event.data;\n                runId = id;\n            }\n            if (!runId) {\n                continue;\n            }\n            // Handle the 'requires_action' event\n            if (event.event === \"thread.run.requires_action\") {\n                const toolOutputs = await this.handleAssistantMessage(event.data, entityId);\n                // Submit the tool outputs\n                await client.beta.threads.runs.submitToolOutputs(thread.id, runId, {\n                    tool_outputs: toolOutputs,\n                });\n            }\n            // Break if the run status becomes inactive\n            if ([\n                \"thread.run.completed\",\n                \"thread.run.failed\",\n                \"thread.run.cancelled\",\n                \"thread.run.expired\",\n            ].includes(event.event)) {\n                break;\n            }\n        }\n        if (!runId) {\n            throw new Error(\"No run ID found\");\n        }\n        // Handle any final actions after the stream ends\n        let finalRun = await client.beta.threads.runs.retrieve(thread.id, runId);\n        while ([\"queued\", \"in_progress\", \"requires_action\"].includes(finalRun.status)) {\n            if (finalRun.status === \"requires_action\") {\n                const toolOutputs = await this.handleAssistantMessage(finalRun, entityId);\n                // Submit tool outputs\n                finalRun = await client.beta.threads.runs.submitToolOutputs(thread.id, runId, {\n                    tool_outputs: toolOutputs,\n                });\n            }\n            else {\n                // Update the run status\n                finalRun = await client.beta.threads.runs.retrieve(thread.id, runId);\n                await new Promise((resolve) => setTimeout(resolve, 500)); // Wait before rechecking\n            }\n        }\n    }\n    async waitAndHandleAssistantToolCalls(client, run, thread, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"waitAndHandleAssistantToolCalls\",\n            file: this.fileName,\n            params: { client, run, thread, entityId },\n        });\n        while ([\"queued\", \"in_progress\", \"requires_action\"].includes(run.status)) {\n            logger.debug(`Current run status: ${run.status}`);\n            const tool_outputs = await this.handleAssistantMessage(run, entityId || this.entityId);\n            if (run.status === \"requires_action\") {\n                logger.debug(`Submitting tool outputs for run ID: ${run.id} in thread ID: ${thread.id}`);\n                run = await client.beta.threads.runs.submitToolOutputs(thread.id, run.id, {\n                    tool_outputs: tool_outputs,\n                });\n            }\n            else {\n                run = await client.beta.threads.runs.retrieve(thread.id, run.id);\n                await new Promise((resolve) => setTimeout(resolve, 500));\n            }\n        }\n        return run;\n    }\n}\nOpenAIToolSet.FRAMEWORK_NAME = \"openai\";\nOpenAIToolSet.DEFAULT_ENTITY_ID = \"default\";\n\nconst ZExecuteToolCallParams = z.z.object({\n    actions: z.z.array(z.z.string()).optional(),\n    apps: z.z.array(z.z.string()).optional(),\n    params: z.z.record(z.z.any()).optional(),\n    entityId: z.z.string().optional(),\n    useCase: z.z.string().optional(),\n    usecaseLimit: z.z.number().optional(),\n    connectedAccountId: z.z.string().optional(),\n    tags: z.z.array(z.z.string()).optional(),\n    filterByAvailableApps: z.z.boolean().optional().default(false),\n});\nclass VercelAIToolSet extends ComposioToolSet {\n    constructor(config = {}) {\n        super({\n            apiKey: config.apiKey || null,\n            baseUrl: config.baseUrl || null,\n            runtime: \"vercel-ai\",\n            entityId: config.entityId || \"default\",\n            connectedAccountIds: config.connectedAccountIds,\n            allowTracing: config.allowTracing || false,\n        });\n        this.fileName = \"js/src/frameworks/vercel.ts\";\n    }\n    generateVercelTool(schema, entityId = null) {\n        return ai.tool({\n            description: schema.description,\n            // @ts-ignore the type are JSONSchemV7. Internally it's resolved\n            parameters: ai.jsonSchema(schema.parameters),\n            execute: async (params) => {\n                return await this.executeToolCall({\n                    name: schema.name,\n                    arguments: JSON.stringify(params),\n                }, entityId || this.entityId);\n            },\n        });\n    }\n    // change this implementation\n    async getTools(filters, entityId = null) {\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"getTools\",\n            file: this.fileName,\n            params: filters,\n        });\n        const { apps, tags, useCase, usecaseLimit, filterByAvailableApps, actions, } = ZExecuteToolCallParams.parse(filters);\n        const actionsList = await this.getToolsSchema({\n            apps,\n            actions,\n            tags,\n            useCase,\n            useCaseLimit: usecaseLimit,\n            filterByAvailableApps,\n        }, entityId, filters.integrationId);\n        const tools = {};\n        actionsList.forEach((actionSchema) => {\n            tools[actionSchema.name] = this.generateVercelTool(actionSchema, entityId);\n        });\n        return tools;\n    }\n    async executeToolCall(tool, entityId = null) {\n        var _a, _b, _c;\n        TELEMETRY_LOGGER.manualTelemetry(TELEMETRY_EVENTS.SDK_METHOD_INVOKED, {\n            method: \"executeToolCall\",\n            file: this.fileName,\n            params: { tool, entityId },\n        });\n        const toolSchema = await this.getToolsSchema({\n            actions: [tool.name],\n        });\n        const appName = (_b = (_a = toolSchema[0]) === null || _a === void 0 ? void 0 : _a.appName) === null || _b === void 0 ? void 0 : _b.toLowerCase();\n        const connectedAccountId = appName && ((_c = this.connectedAccountIds) === null || _c === void 0 ? void 0 : _c[appName]);\n        return JSON.stringify(await this.executeAction({\n            action: tool.name,\n            params: typeof tool.arguments === \"string\"\n                ? JSON.parse(tool.arguments)\n                : tool.arguments,\n            entityId: entityId || this.entityId,\n            connectedAccountId: connectedAccountId,\n        }));\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-require-imports\nconst { APPS, ACTIONS } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/composio-core/constants.js\");\n\nexports.ACTIONS = ACTIONS;\nexports.APPS = APPS;\nexports.COMPOSIO_SDK_ERROR_CODES = COMPOSIO_SDK_ERROR_CODES;\nexports.CloudflareToolSet = CloudflareToolSet;\nexports.Composio = Composio;\nexports.ComposioError = ComposioError;\nexports.ComposioToolSet = ComposioToolSet;\nexports.ConnectionRequest = ConnectionRequest;\nexports.LangGraphToolSet = LangGraphToolSet;\nexports.LangchainToolSet = LangchainToolSet;\nexports.OpenAIToolSet = OpenAIToolSet;\nexports.VercelAIToolSet = VercelAIToolSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvY29tcG9zaW8tY29yZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsNkRBQU87QUFDM0IsV0FBVyxtQkFBTyxDQUFDLDhEQUFNO0FBQ3pCLFFBQVEsbUJBQU8sQ0FBQyxrREFBSztBQUNyQixrQkFBa0IsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDakQsc0JBQXNCLG1CQUFPLENBQUMscUZBQW9CO0FBQ2xELGFBQWEsbUJBQU8sQ0FBQyxzQkFBUTtBQUM3QixpQkFBaUIsbUJBQU8sQ0FBQyxrQkFBTTtBQUMvQixZQUFZLG1CQUFPLENBQUMsNkVBQXVCO0FBQzNDLFNBQVMsbUJBQU8sQ0FBQyxpREFBSTs7QUFFckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsMEJBQTBCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQkFBMEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQkFBMEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQkFBMEI7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDBCQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFdBQVc7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVyxJQUFJLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsU0FBUyxHQUFHLFlBQVksU0FBUywwQkFBMEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFNBQVM7QUFDdkM7QUFDQSxxQkFBcUIsYUFBYTtBQUNsQyxpQkFBaUIsYUFBYSxFQUFFLFdBQVc7QUFDM0MsZ0JBQWdCLEtBQUs7QUFDckIsbUJBQW1CLFlBQVk7QUFDL0IsbUJBQW1CO0FBQ25COztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUCxpQ0FBaUMsMEJBQTBCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsRUFBRSxtQkFBTyxDQUFDLG9DQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVMsR0FBRyxZQUFZLFNBQVMsMEJBQTBCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2REFBNkQ7QUFDekUsWUFBWSwyRkFBMkY7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxVQUFVO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEdBQUc7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3RELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsY0FBYztBQUN0RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVM7QUFDNUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1CQUFtQjtBQUNoRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxtQkFBbUI7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsbUJBQW1CLEVBQUUsWUFBWTtBQUM1RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLENBQUM7QUFDRDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLHFFQUFxRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLG9FQUFhOztBQUUvQyxlQUFlO0FBQ2YsWUFBWTtBQUNaLGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekIsZ0JBQWdCO0FBQ2hCLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIscUJBQXFCO0FBQ3JCLHVCQUF1QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBZG1pblxcT25lRHJpdmVcXERlc2t0b3BcXGNvbXBvLWFwcFxcaW50ZWdyYXRpb24tY29tcG9zaW9cXGNvbXBvc2lvLWRhc2hib2FyZFxcbm9kZV9tb2R1bGVzXFxjb21wb3Npby1jb3JlXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcbnZhciB6ID0gcmVxdWlyZSgnem9kJyk7XG52YXIgY2xpZW50QXhpb3MgPSByZXF1aXJlKCdAaGV5LWFwaS9jbGllbnQtYXhpb3MnKTtcbnZhciB6b2RUb0pzb25TY2hlbWEgPSByZXF1aXJlKCd6b2QtdG8tanNvbi1zY2hlbWEnKTtcbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbnZhciBwYXRoTW9kdWxlID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIHRvb2xzID0gcmVxdWlyZSgnQGxhbmdjaGFpbi9jb3JlL3Rvb2xzJyk7XG52YXIgYWkgPSByZXF1aXJlKCdhaScpO1xuXG5jb25zdCBDT01QT1NJT19WRVJTSU9OID0gYDAuNS4zNWA7XG5cbmNvbnN0IGdldFVVSUQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHV1aWQudjQoKTtcbn07XG5cbmZ1bmN0aW9uIGpzb25TY2hlbWFQcm9wZXJ0aWVzVG9UU1R5cGVzKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS50eXBlKSB7XG4gICAgICAgIHJldHVybiB6Lm9iamVjdCh7fSk7XG4gICAgfVxuICAgIGxldCB6b2RUeXBlO1xuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICB6b2RUeXBlID0gelxuICAgICAgICAgICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAgICAgICAgIC5kZXNjcmliZSgodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIikgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5leGFtcGxlcyA/IGBcXG5FeGFtcGxlczogJHt2YWx1ZS5leGFtcGxlcy5qb2luKFwiLCBcIil9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICB6b2RUeXBlID0gelxuICAgICAgICAgICAgICAgIC5udW1iZXIoKVxuICAgICAgICAgICAgICAgIC5kZXNjcmliZSgodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIikgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5leGFtcGxlcyA/IGBcXG5FeGFtcGxlczogJHt2YWx1ZS5leGFtcGxlcy5qb2luKFwiLCBcIil9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICAgICAgem9kVHlwZSA9IHpcbiAgICAgICAgICAgICAgICAubnVtYmVyKClcbiAgICAgICAgICAgICAgICAuaW50KClcbiAgICAgICAgICAgICAgICAuZGVzY3JpYmUoKHZhbHVlLmRlc2NyaXB0aW9uIHx8IFwiXCIpICtcbiAgICAgICAgICAgICAgICAodmFsdWUuZXhhbXBsZXMgPyBgXFxuRXhhbXBsZXM6ICR7dmFsdWUuZXhhbXBsZXMuam9pbihcIiwgXCIpfWAgOiBcIlwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHpvZFR5cGUgPSB6XG4gICAgICAgICAgICAgICAgLmJvb2xlYW4oKVxuICAgICAgICAgICAgICAgIC5kZXNjcmliZSgodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIikgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5leGFtcGxlcyA/IGBcXG5FeGFtcGxlczogJHt2YWx1ZS5leGFtcGxlcy5qb2luKFwiLCBcIil9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIHpvZFR5cGUgPSB6XG4gICAgICAgICAgICAgICAgLmFycmF5KGpzb25TY2hlbWFQcm9wZXJ0aWVzVG9UU1R5cGVzKHZhbHVlLml0ZW1zKSlcbiAgICAgICAgICAgICAgICAuZGVzY3JpYmUoKHZhbHVlLmRlc2NyaXB0aW9uIHx8IFwiXCIpICtcbiAgICAgICAgICAgICAgICAodmFsdWUuZXhhbXBsZXMgPyBgXFxuRXhhbXBsZXM6ICR7dmFsdWUuZXhhbXBsZXMuam9pbihcIiwgXCIpfWAgOiBcIlwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgem9kVHlwZSA9IGpzb25TY2hlbWFUb01vZGVsKHZhbHVlKS5kZXNjcmliZSgodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIikgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5leGFtcGxlcyA/IGBcXG5FeGFtcGxlczogJHt2YWx1ZS5leGFtcGxlcy5qb2luKFwiLCBcIil9YCA6IFwiXCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICAgICAgem9kVHlwZSA9IHoubnVsbCgpLmRlc2NyaWJlKHZhbHVlLmRlc2NyaXB0aW9uIHx8IFwiXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIEpTT04gc2NoZW1hIHR5cGU6ICR7dmFsdWUudHlwZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHpvZFR5cGU7XG59XG5mdW5jdGlvbiBqc29uU2NoZW1hVG9Nb2RlbChqc29uU2NoZW1hKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGpzb25TY2hlbWEucHJvcGVydGllcztcbiAgICBjb25zdCByZXF1aXJlZEZpZWxkcyA9IGpzb25TY2hlbWEucmVxdWlyZWQgfHwgW107XG4gICAgaWYgKCFwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiB6Lm9iamVjdCh7fSk7XG4gICAgfVxuICAgIGNvbnN0IHpvZFNjaGVtYSA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgX10gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBfO1xuICAgICAgICBsZXQgem9kVHlwZTtcbiAgICAgICAgaWYgKHZhbHVlLmFueU9mKSB7XG4gICAgICAgICAgICBjb25zdCBhbnlPZlR5cGVzID0gdmFsdWUuYW55T2YubWFwKChzY2hlbWEpID0+IGpzb25TY2hlbWFQcm9wZXJ0aWVzVG9UU1R5cGVzKHNjaGVtYSkpO1xuICAgICAgICAgICAgem9kVHlwZSA9IHpcbiAgICAgICAgICAgICAgICAudW5pb24oYW55T2ZUeXBlcylcbiAgICAgICAgICAgICAgICAuZGVzY3JpYmUoKHZhbHVlLmRlc2NyaXB0aW9uIHx8IFwiXCIpICtcbiAgICAgICAgICAgICAgICAodmFsdWUuZXhhbXBsZXNcbiAgICAgICAgICAgICAgICAgICAgPyBgXFxuRXhhbXBsZXM6ICR7dmFsdWUuZXhhbXBsZXMuam9pbihcIiwgXCIpfWBcbiAgICAgICAgICAgICAgICAgICAgOiBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuYWxsT2YpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbE9mVHlwZXMgPSB2YWx1ZS5hbGxPZi5tYXAoKHNjaGVtYSkgPT4ganNvblNjaGVtYVByb3BlcnRpZXNUb1RTVHlwZXMoc2NoZW1hKSk7XG4gICAgICAgICAgICB6b2RUeXBlID0gelxuICAgICAgICAgICAgICAgIC5pbnRlcnNlY3Rpb24oYWxsT2ZUeXBlc1swXSwgYWxsT2ZUeXBlc1xuICAgICAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgc2NoZW1hKSA9PiBhY2MuYW5kKHNjaGVtYSksIGFsbE9mVHlwZXNbMF0pKVxuICAgICAgICAgICAgICAgIC5kZXNjcmliZSgodmFsdWUuZGVzY3JpcHRpb24gfHwgXCJcIikgK1xuICAgICAgICAgICAgICAgICh2YWx1ZS5leGFtcGxlc1xuICAgICAgICAgICAgICAgICAgICA/IGBcXG5FeGFtcGxlczogJHt2YWx1ZS5leGFtcGxlcy5qb2luKFwiLCBcIil9YFxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUudHlwZSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgem9kVHlwZSA9IGpzb25TY2hlbWFQcm9wZXJ0aWVzVG9UU1R5cGVzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHpvZFR5cGUgPSB6b2RUeXBlLmRlc2NyaWJlKHZhbHVlLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWlyZWRGaWVsZHMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgem9kU2NoZW1hW2tleV0gPSB6b2RUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgem9kU2NoZW1hW2tleV0gPSB6b2RUeXBlLm9wdGlvbmFsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHoub2JqZWN0KHpvZFNjaGVtYSk7XG59XG5jb25zdCBnZXRFbnZWYXJpYWJsZSA9IChuYW1lLCBkZWZhdWx0VmFsdWUgPSB1bmRlZmluZWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnZbbmFtZV0gfHwgZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG59O1xuXG4vLyBEZWZpbmUgbG9nIGxldmVscyB3aXRoIGNvcnJlc3BvbmRpbmcgcHJpb3JpdGllc1xuY29uc3QgTE9HX0xFVkVMUyA9IHtcbiAgICBzaWxlbnQ6IC0xLCAvLyBObyBsb2dzXG4gICAgZXJyb3I6IDAsIC8vIEhpZ2hlc3QgcHJpb3JpdHkgLSBjcml0aWNhbCBlcnJvcnNcbiAgICB3YXJuOiAxLCAvLyBXYXJuaW5nIG1lc3NhZ2VzXG4gICAgaW5mbzogMiwgLy8gR2VuZXJhbCBpbmZvcm1hdGlvblxuICAgIGRlYnVnOiAzLCAvLyBEZWJ1ZyBpbmZvcm1hdGlvblxufTtcbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IGxvZyBsZXZlbCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqIERlZmF1bHRzIHRvICdpbmZvJyBpZiBub3Qgc2V0IG9yIGludmFsaWQuXG4gKiBAcmV0dXJucyB7a2V5b2YgdHlwZW9mIExPR19MRVZFTFN9IFRoZSBjdXJyZW50IGxvZyBsZXZlbFxuICovXG5jb25zdCBnZXRMb2dMZXZlbCA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZW52TGV2ZWwgPSAoX2EgPSBnZXRFbnZWYXJpYWJsZShcIkNPTVBPU0lPX0xPR0dJTkdfTEVWRUxcIiwgXCJpbmZvXCIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZW52TGV2ZWwgJiYgZW52TGV2ZWwgaW4gTE9HX0xFVkVMU1xuICAgICAgICA/IGVudkxldmVsXG4gICAgICAgIDogXCJpbmZvXCI7XG59O1xuY29uc3QgYWRkVGltZXN0YW1wVG9NZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgcmV0dXJuIGAke3RpbWVzdGFtcH0gLSAke21lc3NhZ2V9YDtcbn07XG5jb25zdCBmb3JtYXRFcnJvck1lc3NhZ2UgPSAoYXJncykgPT4ge1xuICAgIHJldHVybiBhcmdzXG4gICAgICAgIC5tYXAoKGFyZykgPT4gKHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgPyBKU09OLnN0cmluZ2lmeShhcmcpIDogYXJnKSlcbiAgICAgICAgLmpvaW4oXCIgXCIpO1xufTtcbmNvbnN0IGdldExvZ2dlciA9ICgpID0+IHtcbiAgICBjb25zdCBsb2dnZXIgPSBjb25zb2xlO1xuICAgIGNvbnN0IGxvZ2dpbmdMZXZlbCA9IGdldExvZ0xldmVsKCk7XG4gICAgY29uc3QgbG9nTGV2ZWxWYWx1ZSA9IExPR19MRVZFTFNbbG9nZ2luZ0xldmVsXTtcbiAgICBjb25zdCBub29wID0gKCkgPT4geyB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yOiBsb2dMZXZlbFZhbHVlID49IExPR19MRVZFTFMuZXJyb3JcbiAgICAgICAgICAgID8gKC4uLmFyZ3MpID0+IGxvZ2dlci5lcnJvcihhZGRUaW1lc3RhbXBUb01lc3NhZ2UoZm9ybWF0RXJyb3JNZXNzYWdlKGFyZ3MpKSlcbiAgICAgICAgICAgIDogbm9vcCxcbiAgICAgICAgd2FybjogbG9nTGV2ZWxWYWx1ZSA+PSBMT0dfTEVWRUxTLndhcm5cbiAgICAgICAgICAgID8gKC4uLmFyZ3MpID0+IGxvZ2dlci53YXJuKGFkZFRpbWVzdGFtcFRvTWVzc2FnZShmb3JtYXRFcnJvck1lc3NhZ2UoYXJncykpKVxuICAgICAgICAgICAgOiBub29wLFxuICAgICAgICBpbmZvOiBsb2dMZXZlbFZhbHVlID49IExPR19MRVZFTFMuaW5mb1xuICAgICAgICAgICAgPyAoLi4uYXJncykgPT4gbG9nZ2VyLmluZm8oYWRkVGltZXN0YW1wVG9NZXNzYWdlKGZvcm1hdEVycm9yTWVzc2FnZShhcmdzKSkpXG4gICAgICAgICAgICA6IG5vb3AsXG4gICAgICAgIGRlYnVnOiBsb2dMZXZlbFZhbHVlID49IExPR19MRVZFTFMuZGVidWdcbiAgICAgICAgICAgID8gKC4uLmFyZ3MpID0+IGxvZ2dlci5kZWJ1ZyhhZGRUaW1lc3RhbXBUb01lc3NhZ2UoZm9ybWF0RXJyb3JNZXNzYWdlKGFyZ3MpKSlcbiAgICAgICAgICAgIDogbm9vcCxcbiAgICB9O1xufTtcbnZhciBsb2dnZXIgPSBnZXRMb2dnZXIoKTtcblxuY29uc3QgWkF1dGhNb2RlID0gei56LmVudW0oW1xuICAgIFwiT0FVVEgyXCIsXG4gICAgXCJPQVVUSDFcIixcbiAgICBcIk9BVVRIMUFcIixcbiAgICBcIkFQSV9LRVlcIixcbiAgICBcIkJBU0lDXCIsXG4gICAgXCJCRUFSRVJfVE9LRU5cIixcbiAgICBcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRcIixcbiAgICBcIk5PX0FVVEhcIixcbiAgICBcIkJBU0lDX1dJVEhfSldUXCIsXG5dKTtcbmNvbnN0IFpDcmVhdGVJbnRlZ3JhdGlvblBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIG5hbWU6IHouei5zdHJpbmcoKSxcbiAgICBhdXRoU2NoZW1lOiBaQXV0aE1vZGUub3B0aW9uYWwoKSxcbiAgICBhcHBVbmlxdWVLZXk6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGFwcElkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBmb3JjZU5ld0ludGVncmF0aW9uOiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgYXV0aENvbmZpZzogei56XG4gICAgICAgIC51bmlvbihbXG4gICAgICAgIHouei5yZWNvcmQoei56LnVua25vd24oKSksXG4gICAgICAgIHouei5vYmplY3Qoe1xuICAgICAgICAgICAgY2xpZW50X2lkOiB6Lnouc3RyaW5nKCksXG4gICAgICAgICAgICBjbGllbnRfc2VjcmV0OiB6Lnouc3RyaW5nKCksXG4gICAgICAgICAgICBhcGlfa2V5OiB6Lnouc3RyaW5nKCksXG4gICAgICAgICAgICBjb25zdW1lcl9rZXk6IHouei5zdHJpbmcoKSxcbiAgICAgICAgICAgIGNvbnN1bWVyX3NlY3JldDogei56LnN0cmluZygpLFxuICAgICAgICAgICAgYmFzZV91cmw6IHouei5zdHJpbmcoKSxcbiAgICAgICAgfSksXG4gICAgXSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgdXNlQ29tcG9zaW9BdXRoOiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFpTaW5nbGVJbnRlZ3JhdGlvblBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGludGVncmF0aW9uSWQ6IHouei5zdHJpbmcoKSxcbn0pO1xuY29uc3QgWkxpc3RJbnRlZ3JhdGlvbnNQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBwYWdlOiB6LnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICBwYWdlU2l6ZTogei56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgYXBwTmFtZTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgYXBwVW5pcXVlS2V5OiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBzaG93RGlzYWJsZWQ6IHouei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbn0pO1xuXG5jb25zdCBaRXhlY3V0ZUFjdGlvblBhcmFtcyQxID0gei56Lm9iamVjdCh7XG4gICAgYWN0aW9uTmFtZTogei56LnN0cmluZygpLFxuICAgIHBhcmFtczogei56LnJlY29yZCh6LnouYW55KCkpLm9wdGlvbmFsKCksXG4gICAgdGV4dDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgY29ubmVjdGVkQWNjb3VudElkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWkluaXRpYXRlQ29ubmVjdGlvblBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGFwcE5hbWU6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGF1dGhDb25maWc6IHouei5yZWNvcmQoei56LmFueSgpKS5vcHRpb25hbCgpLFxuICAgIGludGVncmF0aW9uSWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGF1dGhNb2RlOiBaQXV0aE1vZGUub3B0aW9uYWwoKSxcbiAgICBjb25uZWN0aW9uUGFyYW1zOiB6LnoucmVjb3JkKHouei5hbnkoKSkub3B0aW9uYWwoKSxcbiAgICBjb25maWc6IHouelxuICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgbGFiZWxzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgICAgICByZWRpcmVjdFVybDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgfSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgcmVkaXJlY3RVcmk6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGxhYmVsczogei56LmFycmF5KHouei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWkNvbm5lY3Rpb25QYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGFwcDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFpUcmlnZ2VyU3Vic2NyaWJlUGFyYW0gPSB6Lnoub2JqZWN0KHtcbiAgICBhcHA6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGFwcE5hbWU6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHRyaWdnZXJOYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgY29uZmlnOiB6LnoucmVjb3JkKHouei5hbnkoKSksXG59KTtcblxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHN0cmluZ2lmeSBvYmplY3RzIGlmIG5lZWRlZFxuY29uc3Qgc2VyaWFsaXplVmFsdWUgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgPyBKU09OLnN0cmluZ2lmeShvYmopIDogb2JqO1xufTtcblxuLy8gQ29uc3RhbnRzXG5jb25zdCBDT01QT1NJT19ESVIgPSBcIi5jb21wb3Npb1wiO1xuY29uc3QgVVNFUl9EQVRBX0ZJTEVfTkFNRSA9IFwidXNlcl9kYXRhLmpzb25cIjtcbmNvbnN0IFRFTVBfRklMRVNfRElSRUNUT1JZX05BTUUgPSBcImZpbGVzXCI7XG5jb25zdCBERUZBVUxUX0JBU0VfVVJMID0gXCJodHRwczovL2JhY2tlbmQuY29tcG9zaW8uZGV2XCI7XG5jb25zdCBURUxFTUVUUllfVVJMID0gXCJodHRwczovL2FwcC5jb21wb3Npby5kZXZcIjtcbmNvbnN0IElTX0RFVkVMT1BNRU5UX09SX0NJID0gcHJvY2Vzcy5lbnYuREVWRUxPUE1FTlQgfHwgcHJvY2Vzcy5lbnYuQ0kgfHwgZmFsc2U7XG5cbi8qKlxuICogU2VuZHMgYSByZXBvcnRpbmcgcGF5bG9hZCB0byB0aGUgdGVsZW1ldHJ5IHNlcnZlciB1c2luZyBhIGNoaWxkIHByb2Nlc3MuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGludGVuZGVkIGZvciB1c2UgaW4gTm9kZS5qcyBlbnZpcm9ubWVudHMuXG4gKlxuICogQHBhcmFtIHthbnl9IHJlcG9ydGluZ1BheWxvYWQgLSBUaGUgcGF5bG9hZCB0byBiZSBzZW50IHRvIHRoZSB0ZWxlbWV0cnkgc2VydmVyLlxuICovXG5mdW5jdGlvbiBzZW5kUHJvY2Vzc1JlcShpbmZvKSB7XG4gICAgaWYgKElTX0RFVkVMT1BNRU5UX09SX0NJKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgSGl0dGluZyAke2luZm8udXJsfVske2luZm8ubWV0aG9kfV0gd2l0aCAke3NlcmlhbGl6ZVZhbHVlKGluZm8uZGF0YSl9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGluZm8udXJsKTtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcImh0dHBzXCIgOiBcImh0dHBcIjtcbiAgICAgICAgY29uc3QgcG9ydCA9IHVybC5wb3J0IHx8ICh1cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyA0NDMgOiA4MCk7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbXG4gICAgICAgICAgICBcIi1lXCIsXG4gICAgICAgICAgICBgXG4gICAgICBjb25zdCBodHRwID0gcmVxdWlyZSgnJHtwcm90b2NvbH0nKTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGhvc3RuYW1lOiAnJHt1cmwuaG9zdG5hbWV9JyxcbiAgICAgICAgcGF0aDogJyR7dXJsLnBhdGhuYW1lfSR7dXJsLnNlYXJjaH0nLFxuICAgICAgICBwb3J0OiAke3BvcnR9LFxuICAgICAgICBtZXRob2Q6ICcke2luZm8ubWV0aG9kfScsXG4gICAgICAgIGhlYWRlcnM6ICR7SlNPTi5zdHJpbmdpZnkoaW5mby5oZWFkZXJzKX1cbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHJlcSA9IGh0dHAucmVxdWVzdChvcHRpb25zLCAocmVzKSA9PiB7XG4gICAgICAgIHJlcy5vbignZGF0YScsICgpID0+IHt9KTtcbiAgICAgICAgcmVzLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXEub24oJ2Vycm9yJywgKCkgPT4ge1xuICAgICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgICB9KTtcblxuICAgICAgcmVxLndyaXRlKEpTT04uc3RyaW5naWZ5KCR7SlNPTi5zdHJpbmdpZnkoaW5mby5kYXRhKX0pKTtcbiAgICAgIHJlcS5lbmQoKTtcbiAgICAgIGAsXG4gICAgICAgIF07XG4gICAgICAgIC8vIFVzZSBzcGF3biB3aXRoIGRldGFjaGVkIG9wdGlvbiBpbnN0ZWFkIG9mIHNwYXduU3luYyB0byBtYWtlIGl0IG5vbi1ibG9ja2luZ1xuICAgICAgICBjb25zdCB7IHNwYXduIH0gPSByZXF1aXJlKFwiY2hpbGRfcHJvY2Vzc1wiKTtcbiAgICAgICAgc3Bhd24oXCJub2RlXCIsIGFyZ3MsIHtcbiAgICAgICAgICAgIHN0ZGlvOiBcImlnbm9yZVwiLFxuICAgICAgICAgICAgZGV0YWNoZWQ6IHRydWUsXG4gICAgICAgICAgICBzaGVsbDogZmFsc2UsXG4gICAgICAgIH0pLnVucmVmKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRXJyb3Igc2VuZGluZyBlcnJvciB0byB0ZWxlbWV0cnlcIiwgZXJyb3IpO1xuICAgICAgICAvLyBETyBOT1RISU5HXG4gICAgfVxufVxuLyoqXG4gKiBTZW5kcyBhIHJlcG9ydGluZyBwYXlsb2FkIHRvIHRoZSB0ZWxlbWV0cnkgc2VydmVyIHVzaW5nIFhNTEh0dHBSZXF1ZXN0LlxuICogVGhpcyBmdW5jdGlvbiBpcyBpbnRlbmRlZCBmb3IgdXNlIGluIGJyb3dzZXIgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwYXJhbSB7YW55fSByZXBvcnRpbmdQYXlsb2FkIC0gVGhlIHBheWxvYWQgdG8gYmUgc2VudCB0byB0aGUgdGVsZW1ldHJ5IHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gc2VuZEJyb3dzZXJSZXEoaW5mbykge1xuICAgIGlmIChJU19ERVZFTE9QTUVOVF9PUl9DSSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoYEhpdHRpbmcgJHtpbmZvLnVybH1bJHtpbmZvLm1ldGhvZH1dIHdpdGggJHtzZXJpYWxpemVWYWx1ZShpbmZvLmRhdGEpfWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IFhNTEh0dHBSZXF1ZXN0IG9iamVjdFxuICAgICAgICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgLy8gT3BlbiBhIG5ldyBQT1NUIHJlcXVlc3QgdG8gdGhlIHRlbGVtZXRyeSBzZXJ2ZXJcbiAgICAgICAgeGhyLm9wZW4oaW5mby5tZXRob2QsIGluZm8udXJsLCB0cnVlKTtcbiAgICAgICAgLy8gU2V0IHRoZSByZXF1ZXN0IGhlYWRlciB0byBpbmRpY2F0ZSBKU09OIGNvbnRlbnRcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBPYmplY3QuZW50cmllcyhpbmZvLmhlYWRlcnMgfHwge30pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEZWZpbmUgdGhlIG9ubG9hZCBldmVudCBoYW5kbGVyXG4gICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBMb2cgdGhlIHJlc3BvbnNlIGlmIHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsXG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKHhoci5yZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFNlbmQgdGhlIHJlcG9ydGluZyBwYXlsb2FkIGFzIGEgSlNPTiBzdHJpbmdcbiAgICAgICAgeGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkoaW5mby5kYXRhKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJFcnJvciBzZW5kaW5nIGVycm9yIHRvIHRlbGVtZXRyeVwiLCBlcnJvcik7XG4gICAgICAgIC8vIERPIE5PVEhJTkdcbiAgICB9XG59XG5cbi8qXG4gICAgQ29tcG9zaW9Db250ZXh0IGNsYXNzIHByb3ZpZGVzIGEgZ2xvYmFsIGNvbnRleHQgZm9yIHN0b3JpbmcgU0RLIGNvbmZpZ3VyYXRpb24uXG4gICAgVGhpcyBzaW5nbGV0b24gY2xhc3MgbWFpbnRhaW5zIGVzc2VudGlhbCBTREsgc2V0dGluZ3MgbGlrZSBBUEkga2V5IGFuZCBiYXNlIFVSTC5cbiAgICBJdCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBBUEkga2V5IGFuZCBiYXNlIFVSTCBpbiBhIGdsb2JhbCBjb250ZXh0IHNvIHRoYXQgaXQgY2FuIGJlIGFjY2Vzc2VkIGJ5IG90aGVyIG1vZHVsZXMgd2l0aG91dCBoYXZpbmcgdG8gcGFzcyB0aGUgY29uZmlndXJhdGlvbiBhcm91bmQuXG5cbiAgICBXYXJuaW5nOiBDYW4gY2F1c2UgcHJvYmxlbXMgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGUgU0RLIHJ1bm5pbmcgaW4gdGhlIHNhbWUgcHJvY2Vzcy5cbiovXG5jbGFzcyBDb21wb3Npb1NES0NvbnRleHQge1xufVxuQ29tcG9zaW9TREtDb250ZXh0LnNvdXJjZSA9IFwiamF2YXNjcmlwdFwiO1xuXG5hc3luYyBmdW5jdGlvbiBsb2dFcnJvcihwYXlsb2FkKSB7XG4gICAgY29uc3QgaXNUZWxlbWV0cnlEaXNhYmxlZCA9IGdldEVudlZhcmlhYmxlKFwiVEVMRU1FVFJZX0RJU0FCTEVEXCIsIFwiZmFsc2VcIikgPT09IFwidHJ1ZVwiO1xuICAgIGlmIChpc1RlbGVtZXRyeURpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgY29uc3QgcmVwb3J0aW5nUGF5bG9hZCA9IGdlbmVyYXRlUmVwb3J0aW5nUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgY29uc3QgcmVxUGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGRhdGE6IHJlcG9ydGluZ1BheWxvYWQsXG4gICAgICAgICAgICB1cmw6IGAke1RFTEVNRVRSWV9VUkx9L2FwaS9zZGtfbWV0cmljcy9lcnJvcmAsXG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgYXdhaXQgc2VuZEJyb3dzZXJSZXEocmVxUGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBzZW5kUHJvY2Vzc1JlcShyZXFQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKFwiRXJyb3Igc2VuZGluZyBlcnJvciB0byB0ZWxlbWV0cnlcIiwgZXJyb3IpO1xuICAgICAgICAvLyBETyBOT1RISU5HXG4gICAgfVxufVxuZnVuY3Rpb24gZ2VuZXJhdGVSZXBvcnRpbmdQYXlsb2FkKHBheWxvYWQpIHtcbiAgICBjb25zdCB7IGFwaUtleSwgYmFzZVVSTCwgY29tcG9zaW9WZXJzaW9uLCBmcmFtZXdvcmtSdW50aW1lLCBzb3VyY2UgfSA9IENvbXBvc2lvU0RLQ29udGV4dDtcbiAgICBjb25zdCB7IGVycm9yX2lkLCBlcnJvcl9jb2RlLCBkZXNjcmlwdGlvbiwgbWVzc2FnZSwgcG9zc2libGVfZml4LCBvcmlnaW5hbF9lcnJvciwgY3VycmVudF9zdGFjaywgfSA9IHBheWxvYWQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3JfaWQsXG4gICAgICAgIGVycm9yX2NvZGUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBlcnJvcl9tZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBwb3NzaWJsZV9maXgsXG4gICAgICAgIG9yaWdpbmFsX2Vycm9yLFxuICAgICAgICBjdXJyZW50X3N0YWNrLFxuICAgICAgICBzZGtfbWV0YToge1xuICAgICAgICAgICAgcGxhdGZvcm06IHByb2Nlc3MucGxhdGZvcm0sXG4gICAgICAgICAgICB2ZXJzaW9uOiBjb21wb3Npb1ZlcnNpb24sXG4gICAgICAgICAgICBiYXNlVVJMLFxuICAgICAgICAgICAgYXBpS2V5LFxuICAgICAgICAgICAgZnJhbWV3b3JrUnVudGltZSxcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEN1c3RvbSBlcnJvciBjbGFzcyBmb3IgQ29tcG9zaW8gdGhhdCBwcm92aWRlcyByaWNoIGVycm9yIGRldGFpbHMsIHRyYWNraW5nLCBhbmQgaW1wcm92ZWQgZGVidWdnaW5nXG4gKi9cbmNsYXNzIENvbXBvc2lvRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyQ29kZSwgbWVzc2FnZSwgZGVzY3JpcHRpb24sIHBvc3NpYmxlRml4LCBtZXRhZGF0YSwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEVuc3VyZSBtZXNzYWdlIGlzIG5ldmVyIGVtcHR5XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgfHwgXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkXCIpO1xuICAgICAgICAvLyBhZGRpdGlvbmFsIG1ldGFkYXRhIGFib3V0IHRoZSBlcnJvclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0ge307XG4gICAgICAgIC8vIEVuc3VyZSBwcm9wZXIgcHJvdG90eXBlIGNoYWluIGZvciBpbnN0YW5jZW9mIGNoZWNrc1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkNvbXBvc2lvRXJyb3JcIjtcbiAgICAgICAgdGhpcy5lcnJDb2RlID0gZXJyQ29kZTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLnBvc3NpYmxlRml4ID0gcG9zc2libGVGaXg7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMuZXJyb3JJZCA9IGdldFVVSUQoKTtcbiAgICAgICAgbGV0IG9yaWdpbmFsRXJyb3JTdHJpbmcgPSBcIlwiO1xuICAgICAgICAvLyBPbmx5IHByaW50IG9yaWdpbmFsIGVycm9yIGlmIENPTVBPU0lPX0xPR0dJTkdfTEVWRUwgaXMgZGVidWdcbiAgICAgICAgaWYgKG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFcnJvclN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvcmlnaW5hbEVycm9yID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3JpZ2luYWxFcnJvcikpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9yaWdpbmFsRXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2UpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yU3RyaW5nID0gU3RyaW5nKG9yaWdpbmFsRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldExvZ0xldmVsKCkgPT09IFwiZGVidWdcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yU3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgaW4gY2FzZSBvZiBpbmZvIG9yIGRlYnVnLCB3ZSB3aWxsIGxvZyB0aGUgZXJyb3JcbiAgICAgICAgaWYgKExPR19MRVZFTFNbZ2V0TG9nTGV2ZWwoKV0gPj0gMikge1xuICAgICAgICAgICAgbG9nZ2VyLmluZm8oYPCfmoAgW0luZm9dIEdpdmUgRmVlZGJhY2sgLyBHZXQgSGVscDogaHR0cHM6Ly9kdWIuY29tcG9zaW8uZGV2L2Rpc2NvcmQgYCk7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhg8J+QmyBbSW5mb10gQ3JlYXRlIGEgbmV3IGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vQ29tcG9zaW9IUS9jb21wb3Npby9pc3N1ZXMgYCk7XG4gICAgICAgICAgICBpZiAoZ2V0TG9nTGV2ZWwoKSAhPT0gXCJkZWJ1Z1wiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmluZm8oYOKblCBbSW5mb10gSWYgeW91IG5lZWQgdG8gZGVidWcgdGhpcyBlcnJvciwgc2V0IGVudiB2YXJpYWJsZSBDT01QT1NJT19MT0dHSU5HX0xFVkVMPWRlYnVnYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbG9nRXJyb3Ioe1xuICAgICAgICAgICAgZXJyb3JfaWQ6IHRoaXMuZXJyb3JJZCxcbiAgICAgICAgICAgIGVycm9yX2NvZGU6IHRoaXMuZXJyQ29kZSxcbiAgICAgICAgICAgIG9yaWdpbmFsX2Vycm9yOiBvcmlnaW5hbEVycm9yU3RyaW5nLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24gfHwgXCJcIixcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhIHx8IHt9LFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgcG9zc2libGVfZml4OiB0aGlzLnBvc3NpYmxlRml4IHx8IFwiXCIsXG4gICAgICAgICAgICBjdXJyZW50X3N0YWNrOiAoKF9hID0gdGhpcy5zdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiXFxuXCIpKSB8fCBbXSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENhcHR1cmUgc3RhY2sgdHJhY2UsIGV4Y2x1ZGluZyBjb25zdHJ1Y3RvciBjYWxsXG4gICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICBnZXQgb3JpZ2luYWxFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbmFsRXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb21wbGV0ZSBvYmplY3QgcmVwcmVzZW50YXRpb24gZm9yIGxvZ2dpbmcvc2VyaWFsaXphdGlvblxuICAgICAqIEluY2x1ZGVzIGFsbCBlcnJvciBkZXRhaWxzIGFuZCBtZXRhZGF0YVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGVycm9yT2JqID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZXJyb3JJZDogdGhpcy5lcnJvcklkLFxuICAgICAgICAgICAgY29kZTogdGhpcy5lcnJDb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwb3NzaWJsZUZpeDogdGhpcy5wb3NzaWJsZUZpeCxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdGhpcy50aW1lc3RhbXAsXG4gICAgICAgICAgICBzdGFjazogKF9hID0gdGhpcy5zdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICAgICAgb3JpZ2luYWxTdGFjazogKF9jID0gKF9iID0gdGhpcy5vcmlnaW5hbEVycm9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RhY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gUmVtb3ZlIHVuZGVmaW5lZC9udWxsIHByb3BlcnRpZXNcbiAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGVycm9yT2JqKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxufVxuXG5jb25zdCBDT01QT1NJT19TREtfRVJST1JfQ09ERVMgPSB7XG4gICAgQkFDS0VORDoge1xuICAgICAgICBOT1RfRk9VTkQ6IFwiQkFDS0VORDo6Tk9UX0ZPVU5EXCIsXG4gICAgICAgIFJBVEVfTElNSVQ6IFwiQkFDS0VORDo6UkFURV9MSU1JVFwiLFxuICAgICAgICBCQURfUkVRVUVTVDogXCJCQUNLRU5EOjpCQURfUkVRVUVTVFwiLFxuICAgICAgICBVTkFVVEhPUklaRUQ6IFwiQkFDS0VORDo6VU5BVVRIT1JJWkVEXCIsXG4gICAgICAgIFNFUlZFUl9FUlJPUjogXCJCQUNLRU5EOjpTRVJWRVJfRVJST1JcIixcbiAgICAgICAgU0VSVkVSX1VOQVZBSUxBQkxFOiBcIkJBQ0tFTkQ6OlNFUlZFUl9VTkFWQUlMQUJMRVwiLFxuICAgICAgICBTRVJWRVJfVU5SRUFDSEFCTEU6IFwiQkFDS0VORDo6U0VSVkVSX1VOUkVBQ0hBQkxFXCIsXG4gICAgICAgIFVOS05PV046IFwiQkFDS0VORDo6VU5LTk9XTlwiLFxuICAgIH0sXG4gICAgQ09NTU9OOiB7XG4gICAgICAgIEFQSV9LRVlfVU5BVkFJTEFCTEU6IFwiQ09NTU9OOjpBUElfS0VZX0lOVkFMSURcIixcbiAgICAgICAgQkFTRV9VUkxfTk9UX1JFQUNIQUJMRTogXCJDT01NT046OkJBU0VfVVJMX05PVF9SRUFDSEFCTEVcIixcbiAgICAgICAgVU5LTk9XTjogXCJDT01NT046OkVSUk9SX0NPREVfTk9UX0RFRklORURcIixcbiAgICAgICAgU0VSVkVSX1VOQVZBSUxBQkxFOiBcIkNPTU1PTjo6U0VSVkVSX1VOQVZBSUxBQkxFXCIsXG4gICAgICAgIFJFUVVFU1RfVElNRU9VVDogXCJDT01NT046OlJFUVVFU1RfVElNRU9VVFwiLFxuICAgICAgICBSRVFVRVNUX0FCT1JURUQ6IFwiQ09NTU9OOjpSRVFVRVNUX0FCT1JURURcIixcbiAgICAgICAgSU5WQUxJRF9QQVJBTVNfUEFTU0VEOiBcIkNPTU1PTjo6SU5WQUxJRF9QQVJBTVNfUEFTU0VEXCIsXG4gICAgfSxcbiAgICBTREs6IHtcbiAgICAgICAgTk9fQ09OTkVDVEVEX0FDQ09VTlRfRk9VTkQ6IFwiU0RLOjpOT19DT05ORUNURURfQUNDT1VOVF9GT1VORFwiLFxuICAgICAgICBGQUlMRURfVE9fSU5JVElBVEVfQ09OTkVDVElPTjogXCJTREs6OkZBSUxFRF9UT19JTklUSUFURV9DT05ORUNUSU9OXCIsXG4gICAgICAgIElOVkFMSURfUEFSQU1FVEVSOiBcIlNESzo6SU5WQUxJRF9QQVJBTUVURVJcIixcbiAgICB9LFxufTtcbmNvbnN0IEJBU0VfRVJST1JfQ09ERV9JTkZPID0ge1xuICAgIFtDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5OT1RfRk9VTkRdOiB7XG4gICAgICAgIG1lc3NhZ2U6IFwi8J+UjSBBUEkgbm90IGZvdW5kXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgaXMgbWlzc2luZ1wiLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJFbnN1cmUgdGhlIHJlc291cmNlIGlkIG9yIHJlc291cmNlIGlkZW50aWZpZXIgaXMgY29ycmVjdCBhbmQgdmFsaWQgYXMgYmFja2VuZCByZXR1cm5lZCA0MDRcIixcbiAgICB9LFxuICAgIFtDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5CQURfUkVRVUVTVF06IHtcbiAgICAgICAgbWVzc2FnZTogXCLwn5qrIEJhZCBSZXF1ZXN0LiBUaGUgcmVxdWVzdCB3YXMgbWFsZm9ybWVkIG9yIGluY29ycmVjdFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgcG9zc2libGVGaXg6IFwiQ2hlY2sgeW91ciBwYXJhbWV0ZXJzIGFuZCByZXF1ZXN0IGZvcm1hdCwgYXMgdGhlIGJhY2tlbmQgcmV0dXJuZWQgYSA0MDAgZXJyb3IuXCIsXG4gICAgfSxcbiAgICBbQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuVU5BVVRIT1JJWkVEXToge1xuICAgICAgICBtZXNzYWdlOiBcIvCflJEgQWNjZXNzIERlbmllZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3UgZG8gbm90IGhhdmUgdGhlIG5lY2Vzc2FyeSBjcmVkZW50aWFscy5cIixcbiAgICAgICAgcG9zc2libGVGaXg6IFwiRW5zdXJlIHlvdXIgQVBJIGtleSBpcyBjb3JyZWN0IGFuZCBoYXMgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zLlwiLFxuICAgIH0sXG4gICAgW0NPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uUkVRVUVTVF9USU1FT1VUXToge1xuICAgICAgICBtZXNzYWdlOiBcIvCflZIgUmVxdWVzdCBUaW1lb3V0XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSByZXF1ZXN0IHRpbWVkIG91dCB3aGlsZSB3YWl0aW5nIGZvciBhIHJlc3BvbnNlLlwiLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLiBJZiB0aGUgaXNzdWUgcGVyc2lzdHMsIGNvbnRhY3Qgc3VwcG9ydCBvciBjaGVjayB5b3VyIG5ldHdvcmsgY29ubmVjdGlvbi5cIixcbiAgICB9LFxuICAgIFtDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5TRVJWRVJfRVJST1JdOiB7XG4gICAgICAgIG1lc3NhZ2U6IFwi8J+SpSBPb3BzISBJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiWW91ciByZXF1ZXN0IGNvdWxkIG5vdCBiZSBwcm9jZXNzZWQgZHVlIHRvIGFuIGludGVybmFsIHNlcnZlciBlcnJvci5cIixcbiAgICAgICAgcG9zc2libGVGaXg6IFwiUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4gSWYgdGhlIGlzc3VlIHBlcnNpc3RzLCBjb250YWN0IHN1cHBvcnQuXCIsXG4gICAgfSxcbiAgICBbQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuUkFURV9MSU1JVF06IHtcbiAgICAgICAgbWVzc2FnZTogXCLij7HvuI8gQVBJIFJhdGUgTGltaXQgRXhjZWVkZWRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiWW91IGhhdmUgZXhjZWVkZWQgdGhlIHJhdGUgbGltaXQgZm9yIHJlcXVlc3RzLlwiLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJQbGVhc2Ugd2FpdCBhIGJpdCBiZWZvcmUgdHJ5aW5nIHlvdXIgcmVxdWVzdCBhZ2Fpbi5cIixcbiAgICB9LFxuICAgIFtDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLkFQSV9LRVlfVU5BVkFJTEFCTEVdOiB7XG4gICAgICAgIG1lc3NhZ2U6IFwi8J+UkSBBUEkgS2V5IE1pc3Npbmcgb3IgSW52YWxpZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgQVBJIGtleSBwcm92aWRlZCBpcyBtaXNzaW5nIG9yIGluY29ycmVjdC5cIixcbiAgICAgICAgcG9zc2libGVGaXg6IFwiRW5zdXJlIHRoYXQgeW91ciBBUEkga2V5IGlzIHBhc3NlZCB0byBjbGllbnQgb3Igc2V0IGluIENPTVBPU0lPX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUuXCIsXG4gICAgfSxcbiAgICBbQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuU0VSVkVSX1VOQVZBSUxBQkxFXToge1xuICAgICAgICBtZXNzYWdlOiBcIvCfmqsgU2VydmVyIFVuYXZhaWxhYmxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBzZXJ2ZXIgaXMgY3VycmVudGx5IHVuYWJsZSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuXCIsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIlBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuIElmIHRoZSBpc3N1ZSBwZXJzaXN0cywgY29udGFjdCBzdXBwb3J0LlwiLFxuICAgIH0sXG4gICAgW0NPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uQkFTRV9VUkxfTk9UX1JFQUNIQUJMRV06IHtcbiAgICAgICAgbWVzc2FnZTogXCLwn5SXIEJhc2UgVVJMIGlzIG5vdCB2YWxpZFwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgYmFzZSBVUkwgcHJvdmlkZWQgaXMgbm90IHZhbGlkLlwiLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJFbnN1cmUgdGhhdCB0aGUgYmFzZSBVUkwgaXMgY29ycmVjdCBhbmQgYWNjZXNzaWJsZS5cIixcbiAgICB9LFxuICAgIFtDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLklOVkFMSURfUEFSQU1TX1BBU1NFRF06IHtcbiAgICAgICAgbWVzc2FnZTogXCLwn5WSIEludmFsaWQgcGFyYW1ldGVycyBwYXNzZWRcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGhlIHBhcmFtZXRlcnMgcGFzc2VkIGFyZSBpbnZhbGlkXCIsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIlBsZWFzZSBjaGVjayB0aGUgZXJyb3IgbWVzc2FnZSBmb3IgbW9yZSBkZXRhaWxzXCIsXG4gICAgfSxcbiAgICBVTktOT1dOOiB7XG4gICAgICAgIG1lc3NhZ2U6IG51bGwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJDb250YWN0IG91ciBzdXBwb3J0IHRlYW0gd2l0aCB0aGUgZXJyb3IgZGV0YWlscyBmb3IgZnVydGhlciBhc3Npc3RhbmNlLlwiLFxuICAgIH0sXG4gICAgW0NPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlVOS05PV05dOiB7XG4gICAgICAgIG1lc3NhZ2U6IG51bGwsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBudWxsLFxuICAgICAgICBwb3NzaWJsZUZpeDogXCJDb250YWN0IG91ciBzdXBwb3J0IHRlYW0gd2l0aCB0aGUgZXJyb3IgZGV0YWlscyBmb3IgZnVydGhlciBhc3Npc3RhbmNlLlwiLFxuICAgIH0sXG59O1xuY29uc3QgQVBJX1RPX1NES19FUlJPUl9DT0RFID0ge1xuICAgIDQwMDogQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuQkFEX1JFUVVFU1QsXG4gICAgNDAxOiBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5VTkFVVEhPUklaRUQsXG4gICAgNDA0OiBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5OT1RfRk9VTkQsXG4gICAgNDA4OiBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLlJFUVVFU1RfVElNRU9VVCxcbiAgICA0Mjk6IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlJBVEVfTElNSVQsXG4gICAgNTAwOiBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5TRVJWRVJfRVJST1IsXG4gICAgNTAyOiBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5TRVJWRVJfVU5BVkFJTEFCTEUsXG59O1xuXG5jb25zdCBnZXRBUElFcnJvckRldGFpbHMgPSAoYXhpb3NFcnJvcikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2wsIF9tLCBfbywgX3AsIF9xO1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSAoX2EgPSBheGlvc0Vycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdHVzO1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHN0YXR1c0NvZGVcbiAgICAgICAgPyBBUElfVE9fU0RLX0VSUk9SX0NPREVbc3RhdHVzQ29kZV1cbiAgICAgICAgOiBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5VTktOT1dOO1xuICAgIGNvbnN0IHByZWRlZmluZWRFcnJvciA9IEJBU0VfRVJST1JfQ09ERV9JTkZPW2Vycm9yQ29kZV07XG4gICAgY29uc3QgZGVmYXVsdEVycm9yRGV0YWlscyA9IHtcbiAgICAgICAgbWVzc2FnZTogYXhpb3NFcnJvci5tZXNzYWdlLFxuICAgICAgICBkZXNjcmlwdGlvbjogKChfYyA9IChfYiA9IGF4aW9zRXJyb3IgPT09IG51bGwgfHwgYXhpb3NFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXhpb3NFcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tZXNzYWdlKSB8fCBheGlvc0Vycm9yLm1lc3NhZ2UsXG4gICAgICAgIHBvc3NpYmxlRml4OiBcIlBsZWFzZSBjaGVjayB0aGUgcGFyYW1ldGVycyB5b3UgYXJlIHBhc3NpbmcgdG8gdGhlIEFQSVwiLFxuICAgIH07XG4gICAgY29uc3QgbWV0YWRhdGEgPSBnZW5lcmF0ZU1ldGFkYXRhRnJvbUF4aW9zRXJyb3IoYXhpb3NFcnJvcik7XG4gICAgY29uc3QgZXJyb3JOYW1lRnJvbUJFID0gKF9lID0gKF9kID0gYXhpb3NFcnJvciA9PT0gbnVsbCB8fCBheGlvc0Vycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBheGlvc0Vycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZGF0YSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm5hbWU7XG4gICAgY29uc3QgZXJyb3JUeXBlRnJvbUJFID0gKF9nID0gKF9mID0gYXhpb3NFcnJvciA9PT0gbnVsbCB8fCBheGlvc0Vycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBheGlvc0Vycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZGF0YSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnR5cGU7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gKF9qID0gKF9oID0gYXhpb3NFcnJvciA9PT0gbnVsbCB8fCBheGlvc0Vycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBheGlvc0Vycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZGF0YSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLm1lc3NhZ2U7XG4gICAgbGV0IGdlbmVyaWNNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBoYXNOb3RSZWNlaXZlZFJlc3BvbnNlRnJvbUJFID0gZXJyb3JDb2RlID09PSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5VTkFVVEhPUklaRUQgfHxcbiAgICAgICAgZXJyb3JDb2RlID09PSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5SQVRFX0xJTUlUIHx8XG4gICAgICAgIGVycm9yQ29kZSA9PT0gQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuU0VSVkVSX1VOQVZBSUxBQkxFIHx8XG4gICAgICAgIGVycm9yQ29kZSA9PT0gQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuU0VSVkVSX1VOUkVBQ0hBQkxFO1xuICAgIGlmIChoYXNOb3RSZWNlaXZlZFJlc3BvbnNlRnJvbUJFKSB7XG4gICAgICAgIGdlbmVyaWNNZXNzYWdlID0gcHJlZGVmaW5lZEVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCgoX2sgPSBheGlvc0Vycm9yLmNvbmZpZykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmJhc2VVUkwpICYmICgoX2wgPSBheGlvc0Vycm9yLmNvbmZpZykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnVybCkpIHtcbiAgICAgICAgZ2VuZXJpY01lc3NhZ2UgPSBgJHtlcnJvck5hbWVGcm9tQkUgfHwgcHJlZGVmaW5lZEVycm9yLm1lc3NhZ2V9ICR7ZXJyb3JUeXBlRnJvbUJFID8gYC0gJHtlcnJvclR5cGVGcm9tQkV9YCA6IFwiXCJ9IG9uICR7KChfbSA9IGF4aW9zRXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20uYmFzZVVSTCkgKyAoKF9vID0gYXhpb3NFcnJvci5jb25maWcpID09PSBudWxsIHx8IF9vID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfby51cmwpfWA7XG4gICAgfVxuICAgIHN3aXRjaCAoZXJyb3JDb2RlKSB7XG4gICAgICAgIGNhc2UgQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuQkFEX1JFUVVFU1Q6XG4gICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uRXJyb3JzID0gKF9xID0gKF9wID0gYXhpb3NFcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9wLmRhdGEpID09PSBudWxsIHx8IF9xID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcS5kZXRhaWxzO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkRXJyb3JzID0gQXJyYXkuaXNBcnJheSh2YWxpZGF0aW9uRXJyb3JzKVxuICAgICAgICAgICAgICAgID8gdmFsaWRhdGlvbkVycm9ycy5tYXAoKGVycikgPT4gSlNPTi5zdHJpbmdpZnkoZXJyKSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uRXJyb3JzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZ2VuZXJpY01lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBWYWxpZGF0aW9uIEVycm9yczogJHtmb3JtYXR0ZWRFcnJvcnN9YCxcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQbGVhc2UgY2hlY2sgdGhlIHJlcXVlc3QgcGFyYW1ldGVycyBhbmQgZW5zdXJlIHRoZXkgYXJlIGNvcnJlY3QuXCIsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELk5PVF9GT1VORDpcbiAgICAgICAgY2FzZSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5VTkFVVEhPUklaRUQ6XG4gICAgICAgIGNhc2UgQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuU0VSVkVSX0VSUk9SOlxuICAgICAgICBjYXNlIENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlNFUlZFUl9VTkFWQUlMQUJMRTpcbiAgICAgICAgY2FzZSBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5SQVRFX0xJTUlUOlxuICAgICAgICBjYXNlIENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlVOS05PV046XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGdlbmVyaWNNZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBlcnJvck1lc3NhZ2UgfHwgcHJlZGVmaW5lZEVycm9yLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHBvc3NpYmxlRml4OiBwcmVkZWZpbmVkRXJyb3IucG9zc2libGVGaXggfHxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEVycm9yRGV0YWlscy5wb3NzaWJsZUZpeCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2VuZXJpY01lc3NhZ2UgfHwgYXhpb3NFcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBlcnJvck1lc3NhZ2UgfHwgcHJlZGVmaW5lZEVycm9yLmRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgY29uc3QgcG9zc2libGVGaXggPSBwcmVkZWZpbmVkRXJyb3IucG9zc2libGVGaXggfHxcbiAgICAgICAgICAgICAgICBkZWZhdWx0RXJyb3JEZXRhaWxzLnBvc3NpYmxlRml4IHx8XG4gICAgICAgICAgICAgICAgXCJcIjtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGdlbmVyYXRlTWV0YWRhdGFGcm9tQXhpb3NFcnJvciA9IChheGlvc0Vycm9yKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgIGNvbnN0IHsgcmVxdWVzdElkLCAuLi5yZXN0TWV0YWRhdGEgfSA9IGF4aW9zRXJyb3IubWV0YWRhdGEgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVsbFVybDogKChfYiA9IChfYSA9IGF4aW9zRXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmFzZVVSTCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogXCJcIikgKyAoKF9kID0gKF9jID0gYXhpb3NFcnJvci5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51cmwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IFwiXCIpLFxuICAgICAgICBtZXRob2Q6ICgoX2YgPSAoX2UgPSBheGlvc0Vycm9yLmNvbmZpZykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm1ldGhvZCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogXCJcIikudG9VcHBlckNhc2UoKSxcbiAgICAgICAgc3RhdHVzQ29kZTogKF9nID0gYXhpb3NFcnJvci5yZXNwb25zZSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnN0YXR1cyxcbiAgICAgICAgcmVxdWVzdElkOiByZXF1ZXN0SWQgPyBgJHtyZXF1ZXN0SWR9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWV0YWRhdGE6IHJlc3RNZXRhZGF0YSxcbiAgICB9O1xufTtcblxuY2xhc3MgQ0VHIHtcbiAgICBzdGF0aWMgaGFuZGxlQWxsRXJyb3IoZXJyb3IsIHNob3VsZFRocm93ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29tcG9zaW9FcnJvcikge1xuICAgICAgICAgICAgaWYgKHNob3VsZFRocm93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiUGFzc2VkIGVycm9yIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBFcnJvclwiKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIHouWm9kRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHpvZEVycm9yID0gdGhpcy5yZXR1cm5ab2RFcnJvcihlcnJvcik7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB6b2RFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB6b2RFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0F4aW9zRXJyb3IgPSBlcnJvci5pc0F4aW9zRXJyb3I7XG4gICAgICAgIGlmICghaXNBeGlvc0Vycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBjdXN0b21FcnJvciA9IHRoaXMuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5VTktOT1dOLCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQbGVhc2UgY2hlY2sgZXJyb3IgbWVzc2FnZSBhbmQgc3RhY2sgdHJhY2VcIixcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgICAgICAgIHRocm93IGN1c3RvbUVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1c3RvbUVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaXNSZXNwb25zZU5vdFByZXNlbnQgPSAhKFwicmVzcG9uc2VcIiBpbiBlcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNSZXNwb25zZU5vdFByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub25SZXNwb25zZUVycm9yID0gdGhpcy5oYW5kbGVOb25SZXNwb25zZUF4aW9zRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBub25SZXNwb25zZUVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9uUmVzcG9uc2VFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaUVycm9yID0gdGhpcy50aHJvd0FQSUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgICAgICAgIHRocm93IGFwaUVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFwaUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBoYW5kbGVOb25SZXNwb25zZUF4aW9zRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZnVsbFVybCA9ICgoKF9hID0gZXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmFzZVVSTCkgfHwgXCJcIikgKyAoKChfYiA9IGVycm9yLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVybCkgfHwgXCJcIik7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gZ2VuZXJhdGVNZXRhZGF0YUZyb21BeGlvc0Vycm9yKGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRUNPTk5SRUZVU0VEXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21wb3Npb0Vycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uQkFTRV9VUkxfTk9UX1JFQUNIQUJMRSwgYEVDT05OUkVGVVNFRCBmb3IgJHtmdWxsVXJsfWAsIFwiXCIsIFwiTWFrZSBzdXJlOlxcbjEuIFRoZSBiYXNlIFVSTCBpcyBjb3JyZWN0IGFuZCBpcyBhY2Nlc3NpYmxlXFxuMi4gWW91ciBuZXR3b3JrIGNvbm5lY3Rpb24gaXMgc3RhYmxlXFxuMy4gVGhlcmUgYXJlIG5vIGZpcmV3YWxsIHJ1bGVzIGJsb2NraW5nIHRoZSBjb25uZWN0aW9uXCIsIG1ldGFkYXRhLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRVRJTUVET1VUXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb21wb3Npb0Vycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uUkVRVUVTVF9USU1FT1VULCBgRUNPTk5BQk9SVEVEIGZvciAke2Z1bGxVcmx9YCwgYFJlcXVlc3QgdG8gJHtmdWxsVXJsfSB0aW1lZCBvdXQgYWZ0ZXIgdGhlIGNvbmZpZ3VyZWQgdGltZW91dCBwZXJpb2QuIFRoaXMgY291bGQgYmUgZHVlIHRvIHNsb3cgbmV0d29yayBjb25kaXRpb25zLCBzZXJ2ZXIgcGVyZm9ybWFuY2UgaXNzdWVzLCBvciB0aGUgcmVxdWVzdCBiZWluZyB0b28gbGFyZ2UuIEVycm9yIGNvZGU6IEVUSU1FRE9VVGAsIFwiVHJ5OlxcbjEuIENoZWNraW5nIHlvdXIgbmV0d29yayBzcGVlZCBhbmQgc3RhYmlsaXR5XFxuMi4gSW5jcmVhc2luZyB0aGUgcmVxdWVzdCB0aW1lb3V0IHNldHRpbmcgaWYgbmVlZGVkXFxuMy4gQnJlYWtpbmcgdXAgbGFyZ2UgcmVxdWVzdHMgaW50byBzbWFsbGVyIGNodW5rc1xcbjQuIFJldHJ5aW5nIHRoZSByZXF1ZXN0IHdoZW4gbmV0d29yayBjb25kaXRpb25zIGltcHJvdmVcXG41LiBDb250YWN0IHRlY2hAY29tcG9zaW8uZGV2IGlmIHRoZSBpc3N1ZSBwZXJzaXN0c1wiLCBtZXRhZGF0YSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVDT05OQUJPUlRFRFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQ29tcG9zaW9FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLlJFUVVFU1RfQUJPUlRFRCwgZXJyb3IubWVzc2FnZSwgXCJUaGUgcmVxdWVzdCB3YXMgYWJvcnRlZCBkdWUgdG8gYSB0aW1lb3V0IG9yIG90aGVyIG5ldHdvcmstcmVsYXRlZCBpc3N1ZXMuIFRoaXMgY291bGQgYmUgZHVlIHRvIG5ldHdvcmsgaW5zdGFiaWxpdHksIHNlcnZlciBpc3N1ZXMsIG9yIHRoZSByZXF1ZXN0IGJlaW5nIHRvbyBsYXJnZS4gRXJyb3IgY29kZTogRUNPTk5BQk9SVEVEXCIsIFwiVHJ5OlxcbjEuIENoZWNraW5nIHlvdXIgbmV0d29yayBzcGVlZCBhbmQgc3RhYmlsaXR5XFxuMi4gSW5jcmVhc2luZyB0aGUgcmVxdWVzdCB0aW1lb3V0IHNldHRpbmcgaWYgbmVlZGVkXFxuMy4gQnJlYWtpbmcgdXAgbGFyZ2UgcmVxdWVzdHMgaW50byBzbWFsbGVyIGNodW5rc1xcbjQuIFJldHJ5aW5nIHRoZSByZXF1ZXN0IHdoZW4gbmV0d29yayBjb25kaXRpb25zIGltcHJvdmVcXG41LiBDb250YWN0IHRlY2hAY29tcG9zaW8uZGV2IGlmIHRoZSBpc3N1ZSBwZXJzaXN0c1wiLCBtZXRhZGF0YSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBDb21wb3Npb0Vycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5CQUNLRU5ELlNFUlZFUl9VTlJFQUNIQUJMRSwgZXJyb3IubWVzc2FnZSB8fFxuICAgICAgICAgICAgXCJTZXJ2ZXIgaXMgdW5yZWFjaGFibGUuIFBsZWFzZSBjb250YWN0IHRlY2hAY29tcG9zaW8uZGV2IHdpdGggdGhlIGVycm9yIGRldGFpbHMuXCIsIFwiU2VydmVyIGlzIHVucmVhY2hhYmxlLiBQbGVhc2UgY29udGFjdCB0ZWNoQGNvbXBvc2lvLmRldiB3aXRoIHRoZSBlcnJvciBkZXRhaWxzLlwiLCBcIlBsZWFzZSBjb250YWN0IHRlY2hAY29tcG9zaW8uZGV2IHdpdGggdGhlIGVycm9yIGRldGFpbHMuXCIsIG1ldGFkYXRhLCBlcnJvcik7XG4gICAgfVxuICAgIHN0YXRpYyB0aHJvd0FQSUVycm9yKGVycm9yKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9ICgoX2EgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpIHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGVycm9yQ29kZSA9IHN0YXR1c0NvZGVcbiAgICAgICAgICAgID8gQVBJX1RPX1NES19FUlJPUl9DT0RFW3N0YXR1c0NvZGVdIHx8XG4gICAgICAgICAgICAgICAgQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuVU5LTk9XTlxuICAgICAgICAgICAgOiBDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5VTktOT1dOO1xuICAgICAgICBjb25zdCBlcnJvckRldGFpbHMgPSBnZXRBUElFcnJvckRldGFpbHMoZXJyb3IpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGdlbmVyYXRlTWV0YWRhdGFGcm9tQXhpb3NFcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IG5ldyBDb21wb3Npb0Vycm9yKGVycm9yQ29kZSwgZXJyb3JEZXRhaWxzLm1lc3NhZ2UsIGVycm9yRGV0YWlscy5kZXNjcmlwdGlvbiwgZXJyb3JEZXRhaWxzLnBvc3NpYmxlRml4LCBtZXRhZGF0YSwgZXJyb3IpO1xuICAgIH1cbiAgICBzdGF0aWMgcmV0dXJuWm9kRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5JTlZBTElEX1BBUkFNU19QQVNTRUQ7XG4gICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSBcIlRoZSBwYXJhbWV0ZXJzIHBhc3NlZCBhcmUgaW52YWxpZFwiO1xuICAgICAgICBjb25zdCBwb3NzaWJsZUZpeCA9IFwiUGxlYXNlIGNoZWNrIGVycm9yIG1lc3NhZ2UgZm9yIG1vcmUgZGV0YWlsc1wiO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IHtcbiAgICAgICAgICAgIGlzc3VlczogZXJyb3IuaXNzdWVzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2lvRXJyb3IoZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2UsIGVycm9yRGVzY3JpcHRpb24sIHBvc3NpYmxlRml4LCBtZXRhZGF0YSwgZXJyb3IpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q3VzdG9tRXJyb3IobWVzc2FnZUNvZGUsIHsgbWVzc2FnZSwgdHlwZSwgc3VidHlwZSwgZGVzY3JpcHRpb24sIHBvc3NpYmxlRml4LCBvcmlnaW5hbEVycm9yLCBtZXRhZGF0YSwgfSkge1xuICAgICAgICBjb25zdCBmaW5hbEVycm9yQ29kZSA9ICEhbWVzc2FnZUNvZGUgPyBtZXNzYWdlQ29kZSA6IGAke3R5cGV9Ojoke3N1YnR5cGV9YDtcbiAgICAgICAgY29uc3QgZXJyb3JEZXRhaWxzID0gQkFTRV9FUlJPUl9DT0RFX0lORk9bZmluYWxFcnJvckNvZGVdIHx8IEJBU0VfRVJST1JfQ09ERV9JTkZPLlVOS05PV047XG4gICAgICAgIGNvbnN0IGZpbmFsTWVzc2FnZSA9IG1lc3NhZ2UgfHwgZXJyb3JEZXRhaWxzLm1lc3NhZ2UgfHwgXCJcIjtcbiAgICAgICAgY29uc3QgZmluYWxEZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8IGVycm9yRGV0YWlscy5kZXNjcmlwdGlvbiB8fCB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGZpbmFsUG9zc2libGVGaXggPSBwb3NzaWJsZUZpeCB8fCBlcnJvckRldGFpbHMucG9zc2libGVGaXggfHwgXCJcIjtcbiAgICAgICAgdGhyb3cgbmV3IENvbXBvc2lvRXJyb3IobWVzc2FnZUNvZGUsIGZpbmFsTWVzc2FnZSwgZmluYWxEZXNjcmlwdGlvbiwgZmluYWxQb3NzaWJsZUZpeCwgbWV0YWRhdGEsIG9yaWdpbmFsRXJyb3IpO1xuICAgIH1cbn1cblxuY2xhc3MgQmF0Y2hQcm9jZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRpbWUgPSAyMDAwLCBiYXRjaFNpemUgPSAxMDAsIHByb2Nlc3NCYXRjaENhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuYmF0Y2ggPSBbXTtcbiAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuYmF0Y2ggPSBbXTtcbiAgICAgICAgdGhpcy50aW1lID0gdGltZTtcbiAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgIHRoaXMucHJvY2Vzc0JhdGNoQ2FsbGJhY2sgPSBwcm9jZXNzQmF0Y2hDYWxsYmFjaztcbiAgICB9XG4gICAgcHVzaEl0ZW0oaXRlbSkge1xuICAgICAgICB0aGlzLmJhdGNoLnB1c2goaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoLmxlbmd0aCA+PSB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzQmF0Y2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy50aW1lcikge1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wcm9jZXNzQmF0Y2goKSwgdGhpcy50aW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzQmF0Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0JhdGNoQ2FsbGJhY2sodGhpcy5iYXRjaCk7XG4gICAgICAgICAgICB0aGlzLmJhdGNoID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgX2E7XG5jbGFzcyBURUxFTUVUUllfTE9HR0VSIHtcbiAgICBzdGF0aWMgY3JlYXRlVGVsZW1ldHJ5V3JhcHBlcihtZXRob2QsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgZXZlbnROYW1lOiBtZXRob2QubmFtZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB7IGNsYXNzTmFtZSwgYXJncyB9LFxuICAgICAgICAgICAgICAgIHNka19tZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwaUtleTogQ29tcG9zaW9TREtDb250ZXh0LmFwaUtleSxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVSTDogQ29tcG9zaW9TREtDb250ZXh0LmJhc2VVUkwsXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvc2lvVmVyc2lvbjogQ29tcG9zaW9TREtDb250ZXh0LmNvbXBvc2lvVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZnJhbWV3b3JrUnVudGltZTogQ29tcG9zaW9TREtDb250ZXh0LmZyYW1ld29ya1J1bnRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogQ29tcG9zaW9TREtDb250ZXh0LnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkOiBDb21wb3Npb1NES0NvbnRleHQuc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICBpc0Jyb3dzZXI6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfYS5iYXRjaFByb2Nlc3Nvci5wdXNoSXRlbShwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QoLi4uYXJncyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBzZW5kVGVsZW1ldHJ5KHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgaXNUZWxlbWV0cnlEaXNhYmxlZCA9IGdldEVudlZhcmlhYmxlKFwiVEVMRU1FVFJZX0RJU0FCTEVEXCIsIFwiZmFsc2VcIikgPT09IFwidHJ1ZVwiO1xuICAgICAgICBpZiAoaXNUZWxlbWV0cnlEaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IGAke1RFTEVNRVRSWV9VUkx9L2FwaS9zZGtfbWV0cmljcy90ZWxlbWV0cnlgO1xuICAgICAgICBjb25zdCByZXFQYXlsb2FkID0ge1xuICAgICAgICAgICAgZGF0YTogcGF5bG9hZCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIGF3YWl0IHNlbmRCcm93c2VyUmVxKHJlcVBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXdhaXQgc2VuZFByb2Nlc3NSZXEocmVxUGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIG1hbnVhbFRlbGVtZXRyeShldmVudE5hbWUsIGRhdGEpIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGV2ZW50TmFtZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBzZGtfbWV0YToge1xuICAgICAgICAgICAgICAgIGFwaUtleTogQ29tcG9zaW9TREtDb250ZXh0LmFwaUtleSxcbiAgICAgICAgICAgICAgICBiYXNlVVJMOiBDb21wb3Npb1NES0NvbnRleHQuYmFzZVVSTCxcbiAgICAgICAgICAgICAgICBjb21wb3Npb1ZlcnNpb246IENvbXBvc2lvU0RLQ29udGV4dC5jb21wb3Npb1ZlcnNpb24sXG4gICAgICAgICAgICAgICAgZnJhbWV3b3JrUnVudGltZTogQ29tcG9zaW9TREtDb250ZXh0LmZyYW1ld29ya1J1bnRpbWUsXG4gICAgICAgICAgICAgICAgc291cmNlOiBDb21wb3Npb1NES0NvbnRleHQuc291cmNlLFxuICAgICAgICAgICAgICAgIGlzQnJvd3NlcjogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIF9hLmJhdGNoUHJvY2Vzc29yLnB1c2hJdGVtKHBheWxvYWQpO1xuICAgIH1cbiAgICBzdGF0aWMgd3JhcEZ1bmN0aW9uRm9yVGVsZW1ldHJ5KGZ1bmMsIGNsYXNzTmFtZSkge1xuICAgICAgICByZXR1cm4gX2EuY3JlYXRlVGVsZW1ldHJ5V3JhcHBlcihmdW5jLCBjbGFzc05hbWUpO1xuICAgIH1cbn1cbl9hID0gVEVMRU1FVFJZX0xPR0dFUjtcblRFTEVNRVRSWV9MT0dHRVIuYmF0Y2hQcm9jZXNzb3IgPSBuZXcgQmF0Y2hQcm9jZXNzb3IoMTAwLCAxMCwgYXN5bmMgKGRhdGEpID0+IHtcbiAgICBhd2FpdCBfYS5zZW5kVGVsZW1ldHJ5KGRhdGEpO1xufSk7XG5cbnZhciBURUxFTUVUUllfRVZFTlRTO1xuKGZ1bmN0aW9uIChURUxFTUVUUllfRVZFTlRTKSB7XG4gICAgVEVMRU1FVFJZX0VWRU5UU1tcIlNES19JTklUSUFMSVpFRFwiXSA9IFwiU0RLX0lOSVRJQUxJWkVEXCI7XG4gICAgVEVMRU1FVFJZX0VWRU5UU1tcIlNES19NRVRIT0RfSU5WT0tFRFwiXSA9IFwiU0RLX01FVEhPRF9JTlZPS0VEXCI7XG4gICAgVEVMRU1FVFJZX0VWRU5UU1tcIkNMSV9JTlZPS0VEXCJdID0gXCJDTElfSU5WT0tFRFwiO1xufSkoVEVMRU1FVFJZX0VWRU5UUyB8fCAoVEVMRU1FVFJZX0VWRU5UUyA9IHt9KSk7XG5cbi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSBAaGV5LWFwaS9vcGVuYXBpLXRzXG5jb25zdCBjbGllbnQgPSBjbGllbnRBeGlvcy5jcmVhdGVDbGllbnQoY2xpZW50QXhpb3MuY3JlYXRlQ29uZmlnKCkpO1xuY2xhc3MgQ2xpZW50U2VydmljZSB7XG4gICAgLyoqXG4gICAgICogR2V0IHVzZXIgaW5mb1xuICAgICAqIEdldCBjbGllbnQgaW5mb1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRVc2VySW5mbyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY2xpZW50L2F1dGgvY2xpZW50X2luZm9cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBuZXcgcHJvamVjdFxuICAgICAqIEFkZCBhIG5ldyBwcm9qZWN0IHRvIHRoZSBjbGllbnQncyBvcmdhbml6YXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUHJvamVjdChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2NsaWVudC9hdXRoL3Byb2plY3QvYWRkXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgcHJvamVjdFxuICAgICAqIERlbGV0ZSBhIHByb2plY3QgZnJvbSB0aGUgY2xpZW50J3Mgb3JnYW5pemF0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGRlbGV0ZVByb2plY3Qob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5kZWxldGUoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2NsaWVudC9hdXRoL3Byb2plY3QvZGVsZXRlL3twcm9qZWN0SWR9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcHJvamVjdHNcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UHJvamVjdHMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2NsaWVudC9hdXRoL3Byb2plY3RzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgb3JnIGFwaSBrZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0T3JnQXBpS2V5KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jbGllbnQvYXV0aC9vcmcvYXBpX2tleVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZSBvcmcgYXBpIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyByZWdlbmVyYXRlT3JnQXBpS2V5KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY2xpZW50L2F1dGgvb3JnL2FwaV9rZXkvcmVnZW5lcmF0ZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBBcGlLZXlzU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYXBpIGtleVxuICAgICAqL1xuICAgIHN0YXRpYyBnZW5lcmF0ZUFwaUtleShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2FwaV9rZXlzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFwaSBrZXlzXG4gICAgICovXG4gICAgc3RhdGljIGxpc3RBcGlLZXlzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9hcGlfa2V5c1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFwaSBrZXlcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlQXBpS2V5KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZGVsZXRlKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9hcGlfa2V5cy97aWR9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEFwcHNTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBMaXN0IGFwcCBjYXRlZ29yaWVzXG4gICAgICogTGlzdCBvZiBhdmFpbGFibGUgYXBwIGNhdGVnb3JpZXMsIGNhbiBiZSB1c2VkIHRvIGZpbHRlciBhcHBzLlxuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0QXBwQ2F0ZWdvcmllcyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvYXBwcy9saXN0L2NhdGVnb3JpZXNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXBwIGVudW1zXG4gICAgICogTGlzdCBhcHAgZW51bXNcbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdEFwcEVudW1zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9hcHBzL2xpc3QvZW51bXNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYXBwc1xuICAgICAqIExpc3QgYWxsIGFwcHMgYmFzZWQgb24gdGhlIGdpdmVuIGZpbHRlcnMsIGlmIGFueS4gVGhpcyB3aWxsIHJldHVybiBhbGwgYXZhaWxhYmxlIGFwcHMgaWYgbm8gZmlsdGVycyBhcmUgcHJvdmlkZWQuXG4gICAgICovXG4gICAgc3RhdGljIGdldEFwcHMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2FwcHNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzaW5nbGUgYXBwXG4gICAgICogR2V0IGFwcCBkZXRhaWxzXG4gICAgICovXG4gICAgc3RhdGljIGdldEFwcChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvYXBwcy97YXBwTmFtZX1cIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgSW50ZWdyYXRpb25zU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGNvbm5lY3RvclxuICAgICAqIENyZWF0ZSBhIG5ldyBjb25uZWN0b3JcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29ubmVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvaW50ZWdyYXRpb25zXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBjb25uZWN0b3JzXG4gICAgICogTGlzdCBhbGwgY29ubmVjdG9yc1xuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0QWxsQ29ubmVjdG9ycyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvaW50ZWdyYXRpb25zXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY29ubmVjdG9yIGluZm9cbiAgICAgKiBHZXQgY29ubmVjdG9yIGluZm9cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29ubmVjdG9ySW5mbyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvaW50ZWdyYXRpb25zL3tpbnRlZ3JhdGlvbklkfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kaWZ5IGNvbm5lY3RvclxuICAgICAqIE1vZGlmeSBhIGNvbm5lY3RvclxuICAgICAqL1xuICAgIHN0YXRpYyBtb2RpZnlDb25uZWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wYXRjaCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvaW50ZWdyYXRpb25zL3tpbnRlZ3JhdGlvbklkfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGNvbm5lY3RvclxuICAgICAqIERlbGV0ZSBhIGNvbm5lY3RvclxuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVDb25uZWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5kZWxldGUoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2ludGVncmF0aW9ucy97aW50ZWdyYXRpb25JZH1cIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQWN0aW9uc1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIExpc3QgYWN0aW9uIGVudW1zXG4gICAgICogTGlzdCBhY3Rpb24gZW51bXNcbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdEFjdGlvbkVudW1zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9hY3Rpb25zL2xpc3QvZW51bXNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWN0aW9uIHRhZ3NcbiAgICAgKiBMaXN0IGFsbCB0aGUgYWN0aW9uIHRhZ3MgYXZhaWxhYmxlIGluIGNvbXBvc2lvXG4gICAgICovXG4gICAgc3RhdGljIGxpc3RBY3Rpb25UYWdzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9hY3Rpb25zL2xpc3QvdGFnc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhY3Rpb24gZW51bXNcbiAgICAgKiBMaXN0IGFjdGlvbiBlbnVtc1xuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0QWN0aW9uRW51bXMxKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9hY3Rpb25zL2xpc3QvZW51bXNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWN0aW9ucyB3aXRoIGNvbXBsZXRlIGRldGFpbHNcbiAgICAgKiBMaXN0IGFuZCBmaWx0ZXIgYWxsIHRoZSBhY3Rpb25zIGF2YWlsYWJsZSBpbiBjb21wb3Npbywgd2l0aCBhbGwgdGhlIGRldGFpbHMgbmVlZGVkIGZvciBtYW51YWwgYWN0aW9uIGV4ZWN1dGlvbiBvciB0aHJvdWdoIGZ1bmN0aW9uLWNhbGxpbmcuXG4gICAgICovXG4gICAgc3RhdGljIGxpc3RBY3Rpb25zVjIob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2FjdGlvbnNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWN0aW9uc1xuICAgICAqIFJldHJpZXZlIGEgbGlzdCBvZiBhbGwgYWN0aW9ucyBiYXNlZCBvbiBxdWVyeSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHN0YXRpYyBsaXN0QWN0aW9uc01pbmltYWxWMihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvYWN0aW9ucy9saXN0L2FsbFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhbiBhY3Rpb25cbiAgICAgKiBFeGVjdXRlIGFuIGFjdGlvbi4gU3VwcG9ydCBib3RoIGNvbm5lY3RlZCBhY2NvdW50IGFuZCBubyBhdXRoIGF1dGguXG4gICAgICovXG4gICAgc3RhdGljIGV4ZWN1dGVBY3Rpb25WMihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2FjdGlvbnMve2FjdGlvbklkfS9leGVjdXRlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWN0aW9uIGlucHV0c1xuICAgICAqIEdldCB0aGUgaW5wdXRzIGZvciBhbiBhY3Rpb24gd2l0aCBOTEFcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QWN0aW9uSW5wdXRzVjIob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9hY3Rpb25zL3thY3Rpb25JZH0vZXhlY3V0ZS9nZXQuaW5wdXRzXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2luZ2xlIGFjdGlvblxuICAgICAqIEdldCBhY3Rpb24gZGV0YWlscywgaW5jbHVkaW5nIHRoZSBpbnB1dCBhbmQgcmVzcG9uc2Ugc2NoZW1hLiBUaGlzIGlzIHZlcnkgdXNlZnVsIGZvciBzZXR0aW5nIHVwZnVuY3Rpb24vdG9vbCBjYWxsaW5nIHdpdGggY29tcG9zaW8gYWN0aW9ucy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QWN0aW9uVjIob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2FjdGlvbnMve2FjdGlvbklkfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSB3aXRoIEhUVFAgQ2xpZW50XG4gICAgICogVXNlIGNvbXBvc2lvIGFzIGEgaHR0cCBjbGllbnQgdG8gbWFrZSByZXF1ZXN0IHRvIHRoZSBjb25uZWN0ZWQgYWNjb3VudCBzZXJ2aWNlIG9uIHlvdXIgYmVoYWxmLCB3aXRob3V0IG1hbmFnaW5nIGF1dGhlbnRpY2F0aW9uIG9uIHlvdXIgc2lkZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZXhlY3V0ZVdpdGhIdHRwQ2xpZW50KG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvYWN0aW9ucy9wcm94eVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWR2YW5jZWQgdXNlIGNhc2Ugc2VhcmNoXG4gICAgICogUGVyZm9ybSB1c2UgY2FzZSBzZWFyY2guXG4gICAgICovXG4gICAgc3RhdGljIGFkdmFuY2VkVXNlQ2FzZVNlYXJjaChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvYWN0aW9ucy9zZWFyY2gvYWR2YW5jZWRcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdXNlciBmaWxlc1xuICAgICAqL1xuICAgIHN0YXRpYyB2Mkxpc3RVc2VyRmlsZXMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL2FjdGlvbnMvZmlsZXMvbGlzdFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGZpbGUgdXBsb2FkIHVybFxuICAgICAqIENyZWF0ZSBmaWxlIHVwbG9hZCBVUkwgZm9yIGFjdGlvbiBleGVjdXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZpbGVVcGxvYWRVcmwob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9hY3Rpb25zL2ZpbGVzL3VwbG9hZC97ZmlsZVR5cGV9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIENvbm5lY3Rpb25zU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogTGlzdCBjb25uZWN0aW9uc1xuICAgICAqIEdldCBhbGwgY29ubmVjdGlvbnMgaW4gdGhlIGN1cnJlbnQgcHJvamVjdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdENvbm5lY3Rpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jb25uZWN0ZWRBY2NvdW50c1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgY29ubmVjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBpbml0aWF0ZUNvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jb25uZWN0ZWRBY2NvdW50c1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbm5lY3Rpb24gZGF0YVxuICAgICAqIFVwZGF0ZSBjb25uZWN0aW9uIGRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgdXBkYXRlQ29ubmVjdGlvbkRhdGEob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wYXRjaCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY29ubmVjdGVkQWNjb3VudHMve2Nvbm5lY3RlZEFjY291bnRJZH0vZGF0YVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVpbml0aWF0ZSBjb25uZWN0aW9uXG4gICAgICogUmVpbml0aWF0ZSBhbiBleGlzdGluZyBjb25uZWN0aW9uIHRvIGdldCBuZXcgY3JlZGVudGlhbHNcbiAgICAgKi9cbiAgICBzdGF0aWMgcmVpbml0aWF0ZUNvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jb25uZWN0ZWRBY2NvdW50cy97Y29ubmVjdGVkQWNjb3VudElkfS9yZWluaXRpYXRlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2luZ2xlIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY29ubmVjdGVkQWNjb3VudHMve2Nvbm5lY3RlZEFjY291bnRJZH1cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBjb25uZWN0aW9uXG4gICAgICogRGVsZXRlIGEgY29ubmVjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBkZWxldGVDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZGVsZXRlKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jb25uZWN0ZWRBY2NvdW50cy97Y29ubmVjdGVkQWNjb3VudElkfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IEF1dGggY3JlZGVudGlhbHNcbiAgICAgKiBHZXQgYXV0aGVudGljYXRpb24gY3JkZW50aWFscyBmb3IgdGhlIGNvbm5lY3RlZCBhY2NvdW50LCBpLmUgYWxsIHRoZSBoZWFkZXJzLCBxdWVyeSBwYXJhbWV0ZXJzLCBldGMuIHRoYXQgYXJlIHJlcXVpcmVkIHRvIG1ha2UgcmVxdWVzdHMgdG8gdGhlIHRoaXJkLXBhcnR5IHNlcnZpY2UgZGlyZWN0bHkuXG4gICAgICovXG4gICAgc3RhdGljIGdldENvbm5lY3Rpb25JbmZvKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jb25uZWN0ZWRBY2NvdW50cy97Y29ubmVjdGVkQWNjb3VudElkfS9pbmZvXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIGNvbm5lY3Rpb25cbiAgICAgKiBEaXNhYmxlIGEgY29ubmVjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBkaXNhYmxlQ29ubmVjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL2Nvbm5lY3RlZEFjY291bnRzL3tjb25uZWN0ZWRBY2NvdW50SWR9L2Rpc2FibGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBjb25uZWN0aW9uXG4gICAgICogRW5hYmxlIGEgY29ubmVjdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBlbmFibGVDb25uZWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY29ubmVjdGVkQWNjb3VudHMve2Nvbm5lY3RlZEFjY291bnRJZH0vZW5hYmxlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFRyaWdnZXJzU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogTGlzdCB0cmlnZ2Vyc1xuICAgICAqIExpc3QgdHJpZ2dlcnNcbiAgICAgKi9cbiAgICBzdGF0aWMgbGlzdFRyaWdnZXJzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS90cmlnZ2Vyc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB0cmlnZ2VyIGVudW1zXG4gICAgICogTGlzdCB0cmlnZ2VyIGVudW1zXG4gICAgICovXG4gICAgc3RhdGljIGxpc3RUcmlnZ2VyRW51bXMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL3RyaWdnZXJzL2xpc3QvZW51bXNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBuZXcgd2ViaG9va1xuICAgICAqIFVwZGF0ZSBpc05ld1dlYmhvb2tcbiAgICAgKi9cbiAgICBzdGF0aWMgdXBkYXRlTmV3V2ViaG9vayhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL3RyaWdnZXJzL3VwZGF0ZV93ZWJob29rX2Zvcm1hdFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRyaWdnZXJcbiAgICAgKiBFbmFibGVzIGEgdHJpZ2dlciBmb3IgYSBjb25uZWN0ZWQgYWNjb3VudCBhbmQgc3BlY2lmaWMgdHJpZ2dlciBuYW1lLlxuICAgICAqL1xuICAgIHN0YXRpYyBlbmFibGVUcmlnZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvZW5hYmxlL3tjb25uZWN0ZWRBY2NvdW50SWR9L3t0cmlnZ2VyTmFtZX1cIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY3RpdmUgdHJpZ2dlcnNcbiAgICAgKiBMaXN0cyBhY3RpdmUgdHJpZ2dlcnMgYmFzZWQgb24gcXVlcnkgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0QWN0aXZlVHJpZ2dlcnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL3RyaWdnZXJzL2FjdGl2ZV90cmlnZ2Vyc1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3dpdGNoIHRyaWdnZXIgaW5zdGFuY2Ugc3RhdHVzXG4gICAgICogU3dpdGNoZXMgdGhlIHN0YXR1cyBvZiBhIHRyaWdnZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIHN3aXRjaFRyaWdnZXJJbnN0YW5jZVN0YXR1cyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBhdGNoKHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS90cmlnZ2Vycy9pbnN0YW5jZS97dHJpZ2dlcklkfS9zdGF0dXNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgdHJpZ2dlclxuICAgICAqIERpc2FibGVzIGEgc3BlY2lmaWVkIHRyaWdnZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgc3RhdGljIGRpc2FibGVUcmlnZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvZGlzYWJsZS97dHJpZ2dlckluc3RhbmNlSWR9XCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdHJpZ2dlclxuICAgICAqIERlbGV0ZXMgYSBzcGVjaWZpZWQgdHJpZ2dlciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZGVsZXRlVHJpZ2dlcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmRlbGV0ZSh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvdHJpZ2dlcnMvaW5zdGFuY2Uve3RyaWdnZXJJbnN0YW5jZUlkfVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGNhbGxiYWNrIHVybFxuICAgICAqIFNldHMgYSB1bml2ZXJzYWwgY2FsbGJhY2sgVVJMIGZvciB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIHN0YXRpYyBzZXRDYWxsYmFja1VybChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL3RyaWdnZXJzL3NldF9jYWxsYmFja191cmxcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB3ZWJob29rIHVybFxuICAgICAqIFJldHJpZXZlcyB0aGUgdW5pdmVyc2FsIGNhbGxiYWNrIFVSTCBzZXQgZm9yIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgc3RhdGljIGdldFdlYmhvb2tVcmwob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL3RyaWdnZXJzL2NhbGxiYWNrX3VybFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGxvZ3NcbiAgICAgKiBGZXRjaGVzIGxvZ3MgYmFzZWQgb24gY29ubmVjdGlvbiBhbmQgaW50ZWdyYXRpb24gZGV0YWlscy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VHJpZ2dlckxvZ3Mob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YxL3RyaWdnZXJzL2xvZ3NcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0cmlnZ2VyIGluZm9cbiAgICAgKiBHZXQgVHJpZ2dlciBJbmZvXG4gICAgICovXG4gICAgc3RhdGljIGdldFRyaWdnZXJJbmZvVjIob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIHVybDogXCIvYXBpL3YyL3RyaWdnZXJzL3t0cmlnZ2VyTmFtZX1cIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQ2xpU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNsaSBjb2RlIGV4Y2hhbmdlXG4gICAgICovXG4gICAgc3RhdGljIGdlbmVyYXRlQ2xpU2Vzc2lvbihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY2xpL2dlbmVyYXRlLWNsaS1zZXNzaW9uXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgY2xpIGNvZGVcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0Q2xpQ29kZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICgoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2xpZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjbGllbnQpLmdldCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvY2xpL2dldC1jbGktY29kZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNsaSBjb2RlIHZlcmlmaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyB2ZXJpZnlDbGlDb2RlKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9jbGkvdmVyaWZ5LWNsaS1jb2RlXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIExvZ3NTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBHZXQgbG9nc1xuICAgICAqIExpc3QgbG9nc1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXRMb2dzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92MS9sb2dzL1wiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUG9zdCBsb2dzXG4gICAgICogQWRkIG5ldyBsb2dzXG4gICAgICovXG4gICAgc3RhdGljIHBvc3RMb2dzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjEvbG9ncy9cIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgSW50ZWdyYXRpb25zVjJTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBTZWFyY2ggY29ubmVjdG9yXG4gICAgICogU2VhcmNoIGZvciBhIGNvbm5lY3RvclxuICAgICAqL1xuICAgIHN0YXRpYyBzZWFyY2hDb25uZWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9pbnRlZ3JhdGlvbnMvc2VhcmNoLWJ5LWZpbHRlcnNcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBjb25uZWN0b3JcbiAgICAgKiBDcmVhdGUgYSBuZXcgY29ubmVjdG9yXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUNvbm5lY3RvclYyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvaW50ZWdyYXRpb25zL2NyZWF0ZVwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IG9yIGNyZWF0ZSBjb25uZWN0b3JcbiAgICAgKiBHZXQgb3IgY3JlYXRlIGEgY29ubmVjdG9yXG4gICAgICovXG4gICAgc3RhdGljIGdldE9yQ3JlYXRlQ29ubmVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jbGllbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNsaWVudCkucG9zdCh7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgdXJsOiBcIi9hcGkvdjIvaW50ZWdyYXRpb25zL2dldC1vci1jcmVhdGVcIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQ29ubmVjdGlvbnN2MlNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGNvbm5lY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5pdGlhdGVDb25uZWN0aW9uVjIob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNsaWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB1cmw6IFwiL2FwaS92Mi9jb25uZWN0ZWRBY2NvdW50cy9pbml0aWF0ZUNvbm5lY3Rpb25cIixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG52YXIgYXBpQ2xpZW50ID0ge1xuICAgIGxvZ3M6IExvZ3NTZXJ2aWNlLFxuICAgIGFjdGlvbnNWMTogQWN0aW9uc1NlcnZpY2UsXG4gICAgYWN0aW9uc1YyOiBBY3Rpb25zU2VydmljZSxcbiAgICBhcGlLZXlzOiBBcGlLZXlzU2VydmljZSxcbiAgICBjbGllbnRBdXRoOiBDbGllbnRTZXJ2aWNlLFxuICAgIGNsaTogQ2xpU2VydmljZSxcbiAgICBhcHBDb25uZWN0b3I6IEludGVncmF0aW9uc1NlcnZpY2UsXG4gICAgYXBwQ29ubmVjdG9yVjI6IEludGVncmF0aW9uc1YyU2VydmljZSxcbiAgICBhcHBzOiBBcHBzU2VydmljZSxcbiAgICBjb25uZWN0aW9uczogQ29ubmVjdGlvbnNTZXJ2aWNlLFxuICAgIGNvbm5lY3Rpb25zVjI6IENvbm5lY3Rpb25zdjJTZXJ2aWNlLFxuICAgIHRyaWdnZXJzOiBUcmlnZ2Vyc1NlcnZpY2UsXG59O1xuXG5jb25zdCBaQWN0aW9uR2V0UGFyYW1zID0gei56Lm9iamVjdCh7XG4gICAgYWN0aW9uTmFtZTogei56LnN0cmluZygpLFxufSk7XG5jb25zdCBaR2V0TGlzdEFjdGlvbnNQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBhcHBzOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIkNvbW1hIHNlcGFyYXRlZCBhcHAgbmFtZXNcIiksXG4gICAgYWN0aW9uczogei56LnN0cmluZygpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJDb21tYSBzZXBhcmF0ZWQgYWN0aW9uIG5hbWVzXCIpLFxuICAgIHRhZ3M6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQ29tbWEgc2VwYXJhdGVkIHRhZyBuYW1lc1wiKSxcbiAgICB1c2VDYXNlOiB6Lnouc3RyaW5nKCkubnVsbGFibGUoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVXNlIGNhc2UgbmFtZVwiKSxcbiAgICB1c2VjYXNlTGltaXQ6IHouei5udW1iZXIoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiTGltaXQgZm9yIHVzZSBjYXNlXCIpLFxuICAgIHNob3dBbGw6IHouei5ib29sZWFuKCkub3B0aW9uYWwoKS5kZXNjcmliZShcIlNob3cgYWxsIGFjdGlvbnNcIiksXG4gICAgc2hvd0VuYWJsZWRPbmx5OiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCkuZGVzY3JpYmUoXCJTaG93IGVuYWJsZWQgYWN0aW9uc1wiKSxcbiAgICBmaWx0ZXJJbXBvcnRhbnRBY3Rpb25zOiB6LnpcbiAgICAgICAgLmJvb2xlYW4oKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAuZGVzY3JpYmUoXCJGaWx0ZXIgaW1wb3J0YW50IGFjdGlvbnNcIiksXG4gICAgZmlsdGVyQnlBdmFpbGFibGVBcHBzOiB6LnpcbiAgICAgICAgLmJvb2xlYW4oKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAuZGVzY3JpYmUoXCJGaWx0ZXIgYWN0aW9ucyBieSBhdmFpbGFibGUgYXBwc1wiKSxcbn0pO1xuY29uc3QgWlBhcmFtZXRlciA9IHouei5vYmplY3Qoe1xuICAgIG5hbWU6IHouei5zdHJpbmcoKSxcbiAgICBpbjogei56LmVudW0oW1wicXVlcnlcIiwgXCJoZWFkZXJcIl0pLFxuICAgIHZhbHVlOiB6Lnouc3RyaW5nKCksXG59KTtcbmNvbnN0IFpDdXN0b21BdXRoUGFyYW1zID0gei56Lm9iamVjdCh7XG4gICAgYmFzZV91cmw6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHBhcmFtZXRlcnM6IHouei5hcnJheShaUGFyYW1ldGVyKSxcbiAgICBib2R5OiB6LnoucmVjb3JkKHouei51bmtub3duKCkpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFpFeGVjdXRlUGFyYW1zID0gei56Lm9iamVjdCh7XG4gICAgYWN0aW9uTmFtZTogei56LnN0cmluZygpLFxuICAgIHJlcXVlc3RCb2R5OiB6Lnoub2JqZWN0KHtcbiAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgaW5wdXQ6IHouei5yZWNvcmQoei56LnVua25vd24oKSkub3B0aW9uYWwoKSxcbiAgICAgICAgYXBwTmFtZTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIHRleHQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBhdXRoQ29uZmlnOiBaQ3VzdG9tQXV0aFBhcmFtcy5vcHRpb25hbCgpLFxuICAgICAgICBhbGxvd1RyYWNpbmc6IHouei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgc2Vzc2lvbkluZm86IHouelxuICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICBzZXNzaW9uSWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgfSksXG59KTtcbmNvbnN0IFpGaW5kQWN0aW9uRW51bXNCeVVzZUNhc2VQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBhcHBzOiB6LnouYXJyYXkoei56LnN0cmluZygpKSxcbiAgICB1c2VDYXNlOiB6Lnouc3RyaW5nKCksXG4gICAgbGltaXQ6IHouei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIGZpbHRlckJ5QXZhaWxhYmxlQXBwczogei56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxufSk7XG5jb25zdCBaRXhlY3V0ZVJlcXVlc3RQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHouei5zdHJpbmcoKSxcbiAgICBlbmRwb2ludDogei56LnN0cmluZygpLFxuICAgIG1ldGhvZDogei56LmVudW0oW1wiR0VUXCIsIFwiUE9TVFwiLCBcIlBVVFwiLCBcIlBBVENIXCIsIFwiREVMRVRFXCJdKSxcbiAgICBwYXJhbWV0ZXJzOiB6LnouYXJyYXkoWlBhcmFtZXRlciksXG4gICAgYm9keTogei56LnJlY29yZCh6LnoudW5rbm93bigpKS5vcHRpb25hbCgpLFxufSk7XG5cbmNsYXNzIEFjdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKGJhY2tlbmRDbGllbnQsIGNsaWVudCkge1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gXCJqcy9zcmMvc2RrL21vZGVscy9hY3Rpb25zLnRzXCI7XG4gICAgICAgIHRoaXMuYmFja2VuZENsaWVudCA9IGJhY2tlbmRDbGllbnQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBvZiBhIHNwZWNpZmljIGFjdGlvbiBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0gYnkgcHJvdmlkaW5nIGl0cyBhY3Rpb24gbmFtZS5cbiAgICAgKlxuICAgICAqIFRoZSByZXNwb25zZSBpbmNsdWRlcyB0aGUgYWN0aW9uJ3MgbmFtZSwgZGlzcGxheSBuYW1lLCBkZXNjcmlwdGlvbiwgaW5wdXQgcGFyYW1ldGVycywgZXhwZWN0ZWQgcmVzcG9uc2UsIGFzc29jaWF0ZWQgYXBwIGluZm9ybWF0aW9uLCBhbmQgZW5hYmxlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dldEFjdGlvbkRhdGF9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGlvbkl0ZW1HZXRSZXNbMF0+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGV0YWlscyBvZiB0aGUgYWN0aW9uLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldChkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWkFjdGlvbkdldFBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhd2FpdCBhcGlDbGllbnQuYWN0aW9uc1YyLmdldEFjdGlvblYyKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uSWQ6IHBhcnNlZERhdGEuYWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9ucy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgYWN0aW9ucyBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIGZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIGF2YWlsYWJsZSBhY3Rpb25zLiBJdCBzdXBwb3J0cyBwYWdpbmF0aW9uIHRvIGhhbmRsZSBsYXJnZSBudW1iZXJzIG9mIGFjdGlvbnMuIFRoZSByZXNwb25zZSBpbmNsdWRlcyBhbiBhcnJheSBvZiBhY3Rpb24gb2JqZWN0cywgZWFjaCBjb250YWluaW5nIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIGFjdGlvbidzIG5hbWUsIGRpc3BsYXkgbmFtZSwgZGVzY3JpcHRpb24sIGlucHV0IHBhcmFtZXRlcnMsIGV4cGVjdGVkIHJlc3BvbnNlLCBhc3NvY2lhdGVkIGFwcCBpbmZvcm1hdGlvbiwgYW5kIGVuYWJsZWQgc3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtHZXRMaXN0QWN0aW9uc0RhdGF9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGlvbnNMaXN0UmVzcG9uc2VEVE8+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbGlzdCBvZiBhbGwgYWN0aW9ucy5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KGRhdGEgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwibGlzdFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpHZXRMaXN0QWN0aW9uc1BhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGxldCBhcHBzID0gcGFyc2VkRGF0YS5hcHBzO1xuICAgICAgICAgICAgLy8gVGhyb3cgZXJyb3IgaWYgdXNlciBoYXMgcHJvdmlkZWQgYm90aCBmaWx0ZXJCeUF2YWlsYWJsZUFwcHMgYW5kIGFwcHNcbiAgICAgICAgICAgIGlmICgoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmZpbHRlckJ5QXZhaWxhYmxlQXBwcykgJiYgKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5hcHBzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggZmlsdGVyQnlBdmFpbGFibGVBcHBzIGFuZCBhcHBzIGNhbm5vdCBiZSBwcm92aWRlZCB0b2dldGhlclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuZmlsdGVyQnlBdmFpbGFibGVBcHBzKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9kbzogVG8gY3JlYXRlIGEgbmV3IEFQSSB0byBnZXQgYWxsIGludGVncmF0ZWQgYXBwcyBmb3IgYSB1c2VyIGluc3RlYWQgb2YgZmV0Y2hpbmcgYWxsIGFwcHNcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlZ3JhdGVkQXBwcyA9IGF3YWl0IGFwaUNsaWVudC5hcHBDb25uZWN0b3IubGlzdEFsbENvbm5lY3RvcnMoKTtcbiAgICAgICAgICAgICAgICBhcHBzID0gKF9hID0gaW50ZWdyYXRlZEFwcHMuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLml0ZW1zLm1hcCgoYXBwKSA9PiBhcHAgPT09IG51bGwgfHwgYXBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHAuYXBwTmFtZSkuam9pbihcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5hY3Rpb25zVjIubGlzdEFjdGlvbnNWMih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zOiBkYXRhLmFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGFwcHM6IGFwcHMsXG4gICAgICAgICAgICAgICAgICAgIHNob3dBbGw6IGRhdGEuc2hvd0FsbCxcbiAgICAgICAgICAgICAgICAgICAgdGFnczogZGF0YS50YWdzLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJJbXBvcnRhbnRBY3Rpb25zOiBkYXRhLmZpbHRlckltcG9ydGFudEFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHNob3dFbmFibGVkT25seTogZGF0YS5zaG93RW5hYmxlZE9ubHksXG4gICAgICAgICAgICAgICAgICAgIHVzZWNhc2VMaW1pdDogZGF0YS51c2VjYXNlTGltaXQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB1c2VDYXNlOiBkYXRhLnVzZUNhc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGVzIGEgc3BlY2lmaWMgYWN0aW9uIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybS5cbiAgICAgKiBUaGlzIGRvZXNuJ3QgZXhlY3V0ZSB0aGUgbG9jYWwgYWN0aW9uIGFuZCBpcyB3cmFwcGVyIG92ZXIgYmFja2VuZC4gVHJ5IHRvIGNhbGwgdGhpcyBtZXRob2QgZGlyZWN0bHkgZnJvbSB0b29sc2V0XG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIHRyaWdnZXIgdGhlIGV4ZWN1dGlvbiBvZiBhbiBhY3Rpb24gYnkgcHJvdmlkaW5nIGl0cyBuYW1lIGFuZCB0aGUgbmVjZXNzYXJ5IGlucHV0IHBhcmFtZXRlcnMuIFRoZSByZXF1ZXN0IGluY2x1ZGVzIHRoZSBjb25uZWN0ZWQgYWNjb3VudCBJRCB0byBpZGVudGlmeSB0aGUgYXBwIGNvbm5lY3Rpb24gdG8gdXNlIGZvciB0aGUgYWN0aW9uLCBhbmQgdGhlIGlucHV0IHBhcmFtZXRlcnMgcmVxdWlyZWQgYnkgdGhlIGFjdGlvbi4gVGhlIHJlc3BvbnNlIHByb3ZpZGVzIGRldGFpbHMgYWJvdXQgdGhlIGV4ZWN1dGlvbiBzdGF0dXMgYW5kIHRoZSByZXNwb25zZSBkYXRhIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V4ZWN1dGVBY3Rpb25EYXRhfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY3Rpb25FeGVjdXRlUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZXhlY3V0aW9uIHN0YXR1cyBhbmQgcmVzcG9uc2UgZGF0YS5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBleGVjdXRlKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXhlY3V0ZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpFeGVjdXRlUGFyYW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZXMgfSA9IGF3YWl0IGFwaUNsaWVudC5hY3Rpb25zVjIuZXhlY3V0ZUFjdGlvblYyKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucGFyc2VkRGF0YS5yZXF1ZXN0Qm9keSxcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbkluZm86IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLigoKF9hID0gcGFyc2VkRGF0YS5yZXF1ZXN0Qm9keSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlc3Npb25JbmZvKSB8fCB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6ICgoX2MgPSAoX2IgPSBwYXJzZWREYXRhLnJlcXVlc3RCb2R5KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2Vzc2lvbkluZm8pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zZXNzaW9uSWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ29tcG9zaW9TREtDb250ZXh0LnNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dUcmFjaW5nOiBCb29sZWFuKENvbXBvc2lvU0RLQ29udGV4dCA9PT0gbnVsbCB8fCBDb21wb3Npb1NES0NvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IENvbXBvc2lvU0RLQ29udGV4dC5hbGxvd1RyYWNpbmcpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25JZDogcGFyc2VkRGF0YS5hY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmRzIGFsbCBhY3Rpb24gZW51bXMgYnkgdXNlIGNhc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZpbmRBY3Rpb25FbnVtc0J5VXNlQ2FzZVBhcmFtfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBY3Rpb25GaW5kQWN0aW9uRW51bXNCeVVzZUNhc2VSZXM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbGlzdCBvZiBhY3Rpb24gZW51bXMuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZmluZEFjdGlvbkVudW1zQnlVc2VDYXNlKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImZpbmRBY3Rpb25FbnVtc0J5VXNlQ2FzZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpGaW5kQWN0aW9uRW51bXNCeVVzZUNhc2VQYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlcyB9ID0gYXdhaXQgYXBpQ2xpZW50LmFjdGlvbnNWMi5hZHZhbmNlZFVzZUNhc2VTZWFyY2goe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBwczogKF9hID0gcGFyc2VkRGF0YS5hcHBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbihcIixcIiksXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0OiBwYXJzZWREYXRhLmxpbWl0IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyQnlBdmFpbGFibGVBcHBzOiBwYXJzZWREYXRhLmZpbHRlckJ5QXZhaWxhYmxlQXBwcyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgdXNlQ2FzZTogcGFyc2VkRGF0YS51c2VDYXNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXMuaXRlbXMubWFwKChpdGVtKSA9PiBpdGVtLmFjdGlvbnMpLmZsYXQoKSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSBhY3Rpb24gdXNpbmcgQ29tcG9zaW8gUHJveHlcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gdHJpZ2dlciB0aGUgZXhlY3V0aW9uIG9mIGFuIGFjdGlvbiBieSBwcm92aWRpbmcgaXRzIG5hbWUgYW5kIHRoZSBuZWNlc3NhcnkgaW5wdXQgcGFyYW1ldGVycy4gVGhlIHJlcXVlc3QgaW5jbHVkZXMgdGhlIGNvbm5lY3RlZCBhY2NvdW50IElEIHRvIGlkZW50aWZ5IHRoZSBhcHAgY29ubmVjdGlvbiB0byB1c2UgZm9yIHRoZSBhY3Rpb24sIGFuZCB0aGUgaW5wdXQgcGFyYW1ldGVycyByZXF1aXJlZCBieSB0aGUgYWN0aW9uLiBUaGUgcmVzcG9uc2UgcHJvdmlkZXMgZGV0YWlscyBhYm91dCB0aGUgZXhlY3V0aW9uIHN0YXR1cyBhbmQgdGhlIHJlc3BvbnNlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXhlY3V0ZUFjdGlvbkRhdGF9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGlvbkV4ZWN1dGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBleGVjdXRpb24gc3RhdHVzIGFuZCByZXNwb25zZSBkYXRhLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGVSZXF1ZXN0KGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJleGVjdXRlUmVxdWVzdFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpFeGVjdXRlUmVxdWVzdFBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzIH0gPSBhd2FpdCBhcGlDbGllbnQuYWN0aW9uc1YyLmV4ZWN1dGVXaXRoSHR0cENsaWVudCh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogcGFyc2VkRGF0YS5jb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBwYXJzZWREYXRhLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IHBhcnNlZERhdGEubWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJzZWREYXRhLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHBhcnNlZERhdGEuYm9keSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgWlRyaWdnZXJJdGVtUGFyYW0gPSB6Lnoub2JqZWN0KHtcbiAgICB0cmlnZ2VySWQ6IHouei5zdHJpbmcoKSxcbn0pO1xuY29uc3QgWkFjdGl2ZVRyaWdnZXJzUXVlcnkgPSB6Lnoub2JqZWN0KHtcbiAgICB0cmlnZ2VySWRzOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB0cmlnZ2VyTmFtZXM6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNvbm5lY3RlZEFjY291bnRJZHM6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGludGVncmF0aW9uSWRzOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBsaW1pdDogei56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgcGFnZTogei56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgc2hvd0Rpc2FibGVkOiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFpDb25uZWN0aW9uID0gei56Lm9iamVjdCh7XG4gICAgaWQ6IHouei5zdHJpbmcoKSxcbiAgICBpbnRlZ3JhdGlvbklkOiB6Lnouc3RyaW5nKCksXG4gICAgbWVtYmVySWQ6IHouei5zdHJpbmcoKSxcbiAgICBjbGllbnRVbmlxdWVVc2VySWQ6IHouei5zdHJpbmcoKSxcbiAgICBzdGF0dXM6IHouei5zdHJpbmcoKSxcbiAgICBkYXRhOiB6LnoucmVjb3JkKHouei51bmtub3duKCkpLFxuICAgIGRlbGV0ZWQ6IHouei5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICBlbmFibGVkOiB6LnouYm9vbGVhbigpLFxuICAgIGxhYmVsczogei56LmFycmF5KHouei51bmtub3duKCkpLFxuICAgIGNyZWF0ZWRBdDogei56LnN0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogei56LnN0cmluZygpLFxufSk7XG56Lnoub2JqZWN0KHtcbiAgICBpZDogei56LnN0cmluZygpLFxuICAgIGNvbm5lY3Rpb25JZDogei56LnN0cmluZygpLFxuICAgIHRyaWdnZXJOYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgdHJpZ2dlckRhdGE6IHouei5zdHJpbmcoKSxcbiAgICB0cmlnZ2VyQ29uZmlnOiB6LnoucmVjb3JkKHouei51bmtub3duKCkpLFxuICAgIHN0YXRlOiB6LnoucmVjb3JkKHouei51bmtub3duKCkpLFxuICAgIGNyZWF0ZWRBdDogei56LnN0cmluZygpLFxuICAgIHVwZGF0ZWRBdDogei56LnN0cmluZygpLFxuICAgIGRpc2FibGVkQXQ6IHouei5zdHJpbmcoKS5udWxsYWJsZSgpLFxuICAgIGRpc2FibGVkUmVhc29uOiB6Lnouc3RyaW5nKCkubnVsbGFibGUoKSxcbiAgICBjb25uZWN0aW9uOiBaQ29ubmVjdGlvbixcbn0pO1xuXG5jbGFzcyBBY3RpdmVUcmlnZ2VycyB7XG4gICAgY29uc3RydWN0b3IoYmFja2VuZENsaWVudCwgY2xpZW50KSB7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9zZGsvbW9kZWxzL2FjdGl2ZVRyaWdnZXJzLnRzXCI7XG4gICAgICAgIHRoaXMuYmFja2VuZENsaWVudCA9IGJhY2tlbmRDbGllbnQ7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKiogTWlzc2luZyB0eXBlICovXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGRldGFpbHMgb2YgYSBzcGVjaWZpYyBhY3RpdmUgdHJpZ2dlciBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0gYnkgcHJvdmlkaW5nIGl0cyB0cmlnZ2VyIG5hbWUuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzcG9uc2UgaW5jbHVkZXMgdGhlIHRyaWdnZXIncyBuYW1lLCBkZXNjcmlwdGlvbiwgaW5wdXQgcGFyYW1ldGVycywgZXhwZWN0ZWQgcmVzcG9uc2UsIGFzc29jaWF0ZWQgYXBwIGluZm9ybWF0aW9uLCBhbmQgZW5hYmxlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyaWdnZXJJdGVtUGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFRyaWdnZXJJdGVtUmVzPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGRldGFpbHMgb2YgdGhlIGFjdGl2ZSB0cmlnZ2VyLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldCh7IHRyaWdnZXJJZCB9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgdHJpZ2dlcklkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpUcmlnZ2VySXRlbVBhcmFtLnBhcnNlKHsgdHJpZ2dlcklkIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBhcGlDbGllbnQudHJpZ2dlcnMuZ2V0QWN0aXZlVHJpZ2dlcnMoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcklkczogYCR7cGFyc2VkRGF0YS50cmlnZ2VySWR9YCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnRyaWdnZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgYWxsIGFjdGl2ZSB0cmlnZ2VycyBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIGZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIGF2YWlsYWJsZSBhY3RpdmUgdHJpZ2dlcnMuIEl0IHN1cHBvcnRzIHBhZ2luYXRpb24gdG8gaGFuZGxlIGxhcmdlIG51bWJlcnMgb2YgdHJpZ2dlcnMuIFRoZSByZXNwb25zZSBpbmNsdWRlcyBhbiBhcnJheSBvZiB0cmlnZ2VyIG9iamVjdHMsIGVhY2ggY29udGFpbmluZyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB0cmlnZ2VyJ3MgbmFtZSwgZGVzY3JpcHRpb24sIGlucHV0IHBhcmFtZXRlcnMsIGV4cGVjdGVkIHJlc3BvbnNlLCBhc3NvY2lhdGVkIGFwcCBpbmZvcm1hdGlvbiwgYW5kIGVuYWJsZWQgc3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtHZXRBY3RpdmVUcmlnZ2Vyc0RhdGF9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFpBY3RpdmVUcmlnZ2VySXRlbVJlc1tdPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgYWxsIGFjdGl2ZSB0cmlnZ2Vycy5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KGRhdGEgPSB7fSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImxpc3RcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZERhdGEgPSBaQWN0aXZlVHJpZ2dlcnNRdWVyeS5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVzcG9uc2UgfSA9IGF3YWl0IGFwaUNsaWVudC50cmlnZ2Vycy5nZXRBY3RpdmVUcmlnZ2Vycyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBxdWVyeTogcGFyc2VkRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS50cmlnZ2VycztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgcHJldmlvdXNseSBkaXNhYmxlZCB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmlnZ2VySXRlbVBhcmFtfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7c3RhdHVzOiBzdHJpbmd9Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIG9mIHRoZSBlbmFibGUgcmVxdWVzdC5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBlbmFibGUoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImVuYWJsZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpUcmlnZ2VySXRlbVBhcmFtLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgYXdhaXQgYXBpQ2xpZW50LnRyaWdnZXJzLnN3aXRjaFRyaWdnZXJJbnN0YW5jZVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7IHRyaWdnZXJJZDogcGFyc2VkRGF0YS50cmlnZ2VySWQgfSxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgdGhlIHByZXZpb3VzbHkgZW5hYmxlZCB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmlnZ2VySXRlbVBhcmFtfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7c3RhdHVzOiBzdHJpbmd9Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIG9mIHRoZSBkaXNhYmxlIHJlcXVlc3QuXG4gICAgICovXG4gICAgYXN5bmMgZGlzYWJsZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZGlzYWJsZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpUcmlnZ2VySXRlbVBhcmFtLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgYXdhaXQgYXBpQ2xpZW50LnRyaWdnZXJzLnN3aXRjaFRyaWdnZXJJbnN0YW5jZVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXJzZWREYXRhLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnouei5vYmplY3Qoe1xuICAgIGFwcEtleTogei56LnN0cmluZygpLFxufSk7XG5jb25zdCBaR2V0UmVxdWlyZWRQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBhcHBJZDogei56LnN0cmluZygpLFxufSk7XG5jb25zdCBaR2V0UmVxdWlyZWRQYXJhbXNGb3JBdXRoU2NoZW1lID0gei56Lm9iamVjdCh7XG4gICAgYXBwSWQ6IHouei5zdHJpbmcoKSxcbiAgICBhdXRoU2NoZW1lOiB6Lnouc3RyaW5nKCksXG59KTtcbmNvbnN0IFpSZXF1aXJlZFBhcmFtc1Jlc3BvbnNlID0gei56Lm9iamVjdCh7XG4gICAgcmVxdWlyZWRfZmllbGRzOiB6LnouYXJyYXkoei56LnN0cmluZygpKSxcbiAgICBleHBlY3RlZF9mcm9tX3VzZXI6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLFxuICAgIG9wdGlvbmFsX2ZpZWxkczogei56LmFycmF5KHouei5zdHJpbmcoKSksXG59KTtcbnouei5vYmplY3Qoe1xuICAgIGF2YWlsYWJsZUF1dGhTY2hlbWVzOiB6LnouYXJyYXkoei56LnN0cmluZygpKSxcbiAgICBhdXRoU2NoZW1lczogei56LnJlY29yZCh6Lnouc3RyaW5nKCksIFpSZXF1aXJlZFBhcmFtc1Jlc3BvbnNlKSxcbn0pO1xuXG5jbGFzcyBBcHBzIHtcbiAgICBjb25zdHJ1Y3RvcihiYWNrZW5kQ2xpZW50LCBjbGllbnQpIHtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwianMvc3JjL3Nkay9tb2RlbHMvYXBwcy50c1wiO1xuICAgICAgICB0aGlzLmJhY2tlbmRDbGllbnQgPSBiYWNrZW5kQ2xpZW50O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgYXZhaWxhYmxlIGFwcHMgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gZXhwbG9yZSBhbmQgZGlzY292ZXIgdGhlIHN1cHBvcnRlZCBhcHBzLiBJdCByZXR1cm5zIGFuIGFycmF5IG9mIGFwcCBvYmplY3RzLCBlYWNoIGNvbnRhaW5pbmcgZXNzZW50aWFsIGRldGFpbHMgc3VjaCBhcyB0aGUgYXBwJ3Mga2V5LCBuYW1lLCBkZXNjcmlwdGlvbiwgbG9nbywgY2F0ZWdvcmllcywgYW5kIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8QXBwSXRlbUxpc3RSZXNwb25zZVtdPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgYWxsIGFwcHMuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgbGlzdCgpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJsaXN0XCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGFwaUNsaWVudC5hcHBzLmdldEFwcHMoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbEZpZWxkczogXCJhdXRoX3NjaGVtZXNcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5pdGVtcykgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBkZXRhaWxzIG9mIGEgc3BlY2lmaWMgYXBwIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyBjbGllbnRzIHRvIGZldGNoIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgYXBwIGJ5IHByb3ZpZGluZyBpdHMgdW5pcXVlIGtleS4gVGhlIHJlc3BvbnNlIGluY2x1ZGVzIHRoZSBhcHAncyBuYW1lLCBrZXksIHN0YXR1cywgZGVzY3JpcHRpb24sIGxvZ28sIGNhdGVnb3JpZXMsIGF1dGhlbnRpY2F0aW9uIHNjaGVtZXMsIGFuZCBvdGhlciBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXBwR2V0RGF0YVBhcmFtc30gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QsIGluY2x1ZGluZyB0aGUgYXBwJ3MgdW5pcXVlIGtleS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcHBJdGVtUmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGV0YWlscyBvZiB0aGUgYXBwLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldChkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0XCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlc3BvbnNlIH0gPSBhd2FpdCBhcGlDbGllbnQuYXBwcy5nZXRBcHAoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lOiBkYXRhLmFwcEtleSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFwcCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBmb3IgYSBzcGVjaWZpYyBhcHAgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gZmV0Y2ggdGhlIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGFwcCBieSBwcm92aWRpbmcgaXRzIHVuaXF1ZSBrZXkuIFRoZSByZXNwb25zZSBpbmNsdWRlcyB0aGUgYXBwJ3MgbmFtZSwga2V5LCBzdGF0dXMsIGRlc2NyaXB0aW9uLCBsb2dvLCBjYXRlZ29yaWVzLCBhdXRoZW50aWNhdGlvbiBzY2hlbWVzLCBhbmQgb3RoZXIgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXBwSWQgVGhlIHVuaXF1ZSBrZXkgb2YgdGhlIGFwcC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcHBSZXF1aXJlZFBhcmFtc0Z1bGxSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciB0aGUgYXBwLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVpcmVkUGFyYW1zKGFwcElkKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0UmVxdWlyZWRQYXJhbXNcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgYXBwSWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaR2V0UmVxdWlyZWRQYXJhbXMucGFyc2UoeyBhcHBJZCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFwcERhdGEgPSBhd2FpdCB0aGlzLmdldCh7IGFwcEtleTogYXBwSWQgfSk7XG4gICAgICAgICAgICBpZiAoIWFwcERhdGEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXBwIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGF1dGhTY2hlbWVzID0gYXBwRGF0YS5hdXRoX3NjaGVtZXM7XG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGVBdXRoU2NoZW1lcyA9IGF1dGhTY2hlbWVzID09PSBudWxsIHx8IGF1dGhTY2hlbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhdXRoU2NoZW1lcy5tYXAoKHNjaGVtZSkgPT4gc2NoZW1lID09PSBudWxsIHx8IHNjaGVtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1lLm1vZGUpO1xuICAgICAgICAgICAgY29uc3QgYXV0aFNjaGVtZXNPYmplY3QgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2NoZW1lIG9mIGF1dGhTY2hlbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IHNjaGVtZS5tb2RlO1xuICAgICAgICAgICAgICAgIGF1dGhTY2hlbWVzT2JqZWN0W25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZF9maWVsZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25hbF9maWVsZHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZF9mcm9tX3VzZXI6IFtdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NoZW1lLmZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0V4cGVjdGVkRm9ySW50ZWdyYXRpb25TZXR1cCA9IGZpZWxkLmV4cGVjdGVkX2Zyb21fY3VzdG9tZXIgPT09IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1JlcXVpcmVkID0gZmllbGQucmVxdWlyZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0V4cGVjdGVkRm9ySW50ZWdyYXRpb25TZXR1cCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoU2NoZW1lc09iamVjdFtuYW1lXS5leHBlY3RlZF9mcm9tX3VzZXIucHVzaChmaWVsZC5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhTY2hlbWVzT2JqZWN0W25hbWVdLm9wdGlvbmFsX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aFNjaGVtZXNPYmplY3RbbmFtZV0ucmVxdWlyZWRfZmllbGRzLnB1c2goZmllbGQubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlQXV0aFNjaGVtZXMsXG4gICAgICAgICAgICAgICAgYXV0aFNjaGVtZXM6IGF1dGhTY2hlbWVzT2JqZWN0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBvZiBhbiBhcHAgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gZmV0Y2ggdGhlIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBvZiBhbiBhcHAgYnkgcHJvdmlkaW5nIGl0cyB1bmlxdWUga2V5IGFuZCB0aGUgYXV0aGVudGljYXRpb24gc2NoZW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcHBHZXRSZXF1aXJlZFBhcmFtc0ZvckF1dGhTY2hlbWVQYXJhbX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QsIGluY2x1ZGluZyB0aGUgYXBwJ3MgdW5pcXVlIGtleSBhbmQgdGhlIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBcHBSZXF1aXJlZFBhcmFtc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgZm9yIHRoZSBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0UmVxdWlyZWRQYXJhbXNGb3JBdXRoU2NoZW1lKHsgYXBwSWQsIGFwcE5hbWUsIGF1dGhTY2hlbWUsIH0pIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRSZXF1aXJlZFBhcmFtc0ZvckF1dGhTY2hlbWVcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgYXBwSWQsIGF1dGhTY2hlbWUgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbEFwcElkID0gYXBwTmFtZSB8fCBhcHBJZDtcbiAgICAgICAgICAgIFpHZXRSZXF1aXJlZFBhcmFtc0ZvckF1dGhTY2hlbWUucGFyc2UoeyBhcHBJZDogZmluYWxBcHBJZCwgYXV0aFNjaGVtZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGF3YWl0IHRoaXMuZ2V0UmVxdWlyZWRQYXJhbXMoZmluYWxBcHBJZCk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmF1dGhTY2hlbWVzW2F1dGhTY2hlbWVdO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgWkNvbm5lY3Rpb25TdGF0dXMgPSB6LnouZW51bShbXCJJTklUSUFURURcIiwgXCJBQ1RJVkVcIiwgXCJGQUlMRURcIl0pO1xuY29uc3QgWkxpc3RDb25uZWN0aW9uc0RhdGEgPSB6Lnoub2JqZWN0KHtcbiAgICBhcHBOYW1lczogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgYXBwVW5pcXVlS2V5czogei56LnN0cmluZygpLmFycmF5KCkub3B0aW9uYWwoKSxcbiAgICBjb25uZWN0aW9uSWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGVudGl0eUlkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBpbnRlZ3JhdGlvbklkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBsYWJlbHM6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHBhZ2U6IHouei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIHBhZ2VTaXplOiB6LnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICBzaG93QWN0aXZlT25seTogei56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHNob3dEaXNhYmxlZDogei56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIHN0YXR1czogWkNvbm5lY3Rpb25TdGF0dXMub3B0aW9uYWwoKSxcbiAgICB1c2VyX3V1aWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG56Lnoub2JqZWN0KHtcbiAgICBjb25uZWN0aW9uUGFyYW1zOiB6LnoucmVjb3JkKHouei5zdHJpbmcoKSwgei56LnVua25vd24oKSkub3B0aW9uYWwoKSxcbiAgICBlbnRpdHlJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgbGFiZWxzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGludGVncmF0aW9uSWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHJlZGlyZWN0VXJpOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBhdXRoTW9kZTogWkF1dGhNb2RlLm9wdGlvbmFsKCksXG4gICAgYXV0aENvbmZpZzogei56LnJlY29yZCh6Lnouc3RyaW5nKCksIHouei51bmtub3duKCkpLm9wdGlvbmFsKCksXG4gICAgYXBwTmFtZTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFpTYXZlVXNlckFjY2Vzc0RhdGFQYXJhbSA9IHouei5vYmplY3Qoe1xuICAgIGZpZWxkSW5wdXRzOiB6LnoucmVjb3JkKHouei5zdHJpbmcoKSwgei56LnVua25vd24oKSksXG4gICAgcmVkaXJlY3RVcmw6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGVudGl0eUlkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWlNpbmdsZUNvbm5lY3Rpb25QYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHouei5zdHJpbmcoKSxcbn0pO1xuei56Lm9iamVjdCh7XG4gICAgZGF0YTogei56LnJlY29yZCh6Lnouc3RyaW5nKCksIHouei51bmtub3duKCkpLFxuICAgIGludGVncmF0aW9uSWQ6IHouei5zdHJpbmcoKSxcbiAgICByZWRpcmVjdFVyaTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdXNlclV1aWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGVudGl0eUlkOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBsYWJlbHM6IHouei5zdHJpbmcoKS5hcnJheSgpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFpSZWluaXRpYXRlQ29ubmVjdGlvblBheWxvYWREdG8gPSB6Lnoub2JqZWN0KHtcbiAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHouei5zdHJpbmcoKSxcbiAgICBkYXRhOiB6LnoucmVjb3JkKHouei5zdHJpbmcoKSwgei56LnVua25vd24oKSksXG4gICAgcmVkaXJlY3RVcmk6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGNvbm5lY3RlZCBhY2NvdW50cyBpbiB0aGUgc3lzdGVtLlxuICovXG5jbGFzcyBDb25uZWN0ZWRBY2NvdW50cyB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvbm5lY3RlZEFjY291bnRzIGNsYXNzLlxuICAgICAqIEBwYXJhbSB7QXhpb3NCYWNrZW5kQ2xpZW50fSBiYWNrZW5kQ2xpZW50IC0gVGhlIGJhY2tlbmQgY2xpZW50IGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGJhY2tlbmRDbGllbnQsIGNsaWVudCkge1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gXCJqcy9zcmMvc2RrL21vZGVscy9jb25uZWN0ZWRBY2NvdW50cy50c1wiO1xuICAgICAgICB0aGlzLmJhY2tlbmRDbGllbnQgPSBiYWNrZW5kQ2xpZW50O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgY29ubmVjdGVkIGFjY291bnRzXG4gICAgICogQHBhcmFtIHtDb25uZWN0ZWRBY2NvdW50c0xpc3REYXRhfSBkYXRhIC0gVGhlIGRhdGEgZm9yIHRoZSBjb25uZWN0ZWQgYWNjb3VudHMgbGlzdFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3RlZEFjY291bnRMaXN0UmVzcG9uc2U+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgbGlzdCBvZiBjb25uZWN0ZWQgYWNjb3VudHNcbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJsaXN0XCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGFwcE5hbWVzLCBhcHBVbmlxdWVLZXlzIH0gPSBaTGlzdENvbm5lY3Rpb25zRGF0YS5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQXBwTmFtZXMgPSBhcHBOYW1lcyB8fCAoYXBwVW5pcXVlS2V5cyA9PT0gbnVsbCB8fCBhcHBVbmlxdWVLZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHBVbmlxdWVLZXlzLmpvaW4oXCIsXCIpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaUNsaWVudC5jb25uZWN0aW9ucy5saXN0Q29ubmVjdGlvbnMoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZXM6IGZpbmFsQXBwTmFtZXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaW5nbGUgY29ubmVjdGVkIGFjY291bnRcbiAgICAgKiBAcGFyYW0ge1NpbmdsZUNvbm5lY3Rpb25QYXJhbX0gZGF0YSAtIFRoZSBkYXRhIGZvciB0aGUgc2luZ2xlIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaW5nbGVDb25uZWN0ZWRBY2NvdW50UmVzcG9uc2U+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc2luZ2xlIGNvbm5lY3RlZCBhY2NvdW50XG4gICAgICovXG4gICAgYXN5bmMgZ2V0KGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpTaW5nbGVDb25uZWN0aW9uUGFyYW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zLmdldENvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDogZGF0YSxcbiAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgc2luZ2xlIGNvbm5lY3RlZCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtTaW5nbGVDb25uZWN0aW9uUGFyYW19IGRhdGEgLSBUaGUgZGF0YSBmb3IgdGhlIHNpbmdsZSBjb25uZWN0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8U2luZ2xlRGVsZXRlUmVzcG9uc2U+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGNvbm5lY3RlZCBhY2NvdW50IGlzIGRlbGV0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImRlbGV0ZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgWlNpbmdsZUNvbm5lY3Rpb25QYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBhcGlDbGllbnQuY29ubmVjdGlvbnMuZGVsZXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiBkYXRhLFxuICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlIGEgc2luZ2xlIGNvbm5lY3RlZCBhY2NvdW50XG4gICAgICogQHBhcmFtIHtTaW5nbGVDb25uZWN0aW9uUGFyYW19IGRhdGEgLSBUaGUgZGF0YSBmb3IgdGhlIHNpbmdsZSBjb25uZWN0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvbkNoYW5nZVJlc3BvbnNlPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0ZWQgYWNjb3VudCBpcyBkaXNhYmxlZFxuICAgICAqL1xuICAgIGFzeW5jIGRpc2FibGUoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImRpc2FibGVcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpTaW5nbGVDb25uZWN0aW9uUGFyYW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zLmRpc2FibGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IGRhdGEsXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBkYXRhLmNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSBhIHNpbmdsZSBjb25uZWN0ZWQgYWNjb3VudFxuICAgICAqIEBwYXJhbSB7U2luZ2xlQ29ubmVjdGlvblBhcmFtfSBkYXRhIC0gVGhlIGRhdGEgZm9yIHRoZSBzaW5nbGUgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb25DaGFuZ2VSZXNwb25zZT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGVkIGFjY291bnQgaXMgZW5hYmxlZFxuICAgICAqL1xuICAgIGFzeW5jIGVuYWJsZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZW5hYmxlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaU2luZ2xlQ29ubmVjdGlvblBhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGF3YWl0IGFwaUNsaWVudC5jb25uZWN0aW9ucy5lbmFibGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBkYXRhLmNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwic3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogZGF0YS5jb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWF0ZSBhIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge0luaXRpYXRlQ29ubmVjdGlvbkRhdGFSZXF9IHBheWxvYWQgLSBUaGUgcGF5bG9hZCBmb3IgdGhlIGNvbm5lY3Rpb24gaW5pdGlhdGlvblxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb25SZXF1ZXN0Pn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGNvbm5lY3Rpb24gcmVxdWVzdFxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYXRlKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImluaXRpYXRlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IHBheWxvYWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zVjIuaW5pdGlhdGVDb25uZWN0aW9uVjIoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBhcHA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUtleTogcGF5bG9hZC5hcHBOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogcGF5bG9hZC5pbnRlZ3JhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuYXBwTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZUNvbXBvc2lvQXV0aDogISFwYXlsb2FkLmF1dGhNb2RlICYmICEhcGF5bG9hZC5hdXRoQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aFNjaGVtZTogcGF5bG9hZC5hdXRoTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmF0aW9uU2VjcmV0czogcGF5bG9hZC5hdXRoQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRpdHlJZDogcGF5bG9hZC5lbnRpdHlJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYXRlRGF0YTogcGF5bG9hZC5jb25uZWN0aW9uUGFyYW1zIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVSTDogcGF5bG9hZC5yZWRpcmVjdFVyaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYWJlbHM6IHBheWxvYWQubGFiZWxzIHx8IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uUmVzcG9uc2UgPSAoX2EgPSBjb25uZWN0aW9uID09PSBudWxsIHx8IGNvbm5lY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24uZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbm5lY3Rpb25SZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29ubmVjdGlvblJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGF0dXM6IGNvbm5lY3Rpb25SZXNwb25zZSA9PT0gbnVsbCB8fCBjb25uZWN0aW9uUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb25SZXNwb25zZS5jb25uZWN0aW9uU3RhdHVzLFxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogY29ubmVjdGlvblJlc3BvbnNlID09PSBudWxsIHx8IGNvbm5lY3Rpb25SZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGlvblJlc3BvbnNlLmNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFVyaTogY29ubmVjdGlvblJlc3BvbnNlID09PSBudWxsIHx8IGNvbm5lY3Rpb25SZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGlvblJlc3BvbnNlLnJlZGlyZWN0VXJsLFxuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVpbml0aWF0ZSBhIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0ge1JlaW5pdGlhdGVDb25uZWN0aW9uUGF5bG9hZH0gZGF0YSAtIFRoZSBwYXlsb2FkIGZvciB0aGUgY29ubmVjdGlvbiByZWluaXRpYWxpemF0aW9uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8Q29ubmVjdGlvblJlcXVlc3Q+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgY29ubmVjdGlvbiByZXF1ZXN0XG4gICAgICovXG4gICAgYXN5bmMgcmVpbml0aWF0ZUNvbm5lY3Rpb24oZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcInJlaW5pdGlhdGVDb25uZWN0aW9uXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaUmVpbml0aWF0ZUNvbm5lY3Rpb25QYXlsb2FkRHRvLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IGF3YWl0IGFwaUNsaWVudC5jb25uZWN0aW9ucy5yZWluaXRpYXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogZGF0YS5jb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RVcmk6IGRhdGEucmVkaXJlY3RVcmksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY29ubmVjdGlvbi5kYXRhO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb25uZWN0aW9uUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvblN0YXR1czogcmVzID09PSBudWxsIHx8IHJlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzLmNvbm5lY3Rpb25TdGF0dXMsXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiByZXMgPT09IG51bGwgfHwgcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXMuY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpOiByZXMgPT09IG51bGwgfHwgcmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXMucmVkaXJlY3RVcmwsXG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENvbm5lY3Rpb25SZXF1ZXN0IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbm5lY3Rpb25TdGF0dXMsIGNvbm5lY3RlZEFjY291bnRJZCwgcmVkaXJlY3RVcmksIGNsaWVudCwgfSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0dXMgPSBjb25uZWN0aW9uU3RhdHVzO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEFjY291bnRJZCA9IGNvbm5lY3RlZEFjY291bnRJZDtcbiAgICAgICAgdGhpcy5yZWRpcmVjdFVybCA9IHJlZGlyZWN0VXJpO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgYXN5bmMgc2F2ZVVzZXJBY2Nlc3NEYXRhKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIFpTYXZlVXNlckFjY2Vzc0RhdGFQYXJhbS5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogY29ubmVjdGVkQWNjb3VudCB9ID0gYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zLmdldENvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDogeyBjb25uZWN0ZWRBY2NvdW50SWQ6IHRoaXMuY29ubmVjdGVkQWNjb3VudElkIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGVkQWNjb3VudClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25uZWN0ZWQgYWNjb3VudCBub3QgZm91bmRcIik7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zLmluaXRpYXRlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVncmF0aW9uSWQ6IGNvbm5lY3RlZEFjY291bnQuaW50ZWdyYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEuZmllbGRJbnB1dHMsXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpOiBkYXRhLnJlZGlyZWN0VXJsLFxuICAgICAgICAgICAgICAgICAgICB1c2VyVXVpZDogZGF0YS5lbnRpdHlJZCxcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5SWQ6IGRhdGEuZW50aXR5SWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXYWl0IHVudGlsIHRoZSBjb25uZWN0aW9uIGJlY29tZXMgYWN0aXZlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXQgLSBUaGUgdGltZW91dCBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gYmVjb21lIGFjdGl2ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb24+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjb25uZWN0aW9uXG4gICAgICovXG4gICAgYXN5bmMgd2FpdFVudGlsQWN0aXZlKHRpbWVvdXQgPSA2MCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIHdoaWxlIChEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgdGltZW91dCAqIDEwMDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgYXBpQ2xpZW50LmNvbm5lY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC5nZXRDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogeyBjb25uZWN0ZWRBY2NvdW50SWQ6IHRoaXMuY29ubmVjdGVkQWNjb3VudElkIH0sXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghY29ubmVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ubmVjdGVkIGFjY291bnQgbm90IGZvdW5kXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnN0YXR1cyA9PT0gXCJBQ1RJVkVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ubmVjdGlvbiBkaWQgbm90IGJlY29tZSBhY3RpdmUgd2l0aGluIHRoZSB0aW1lb3V0IHBlcmlvZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBJbnRlZ3JhdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKGJhY2tlbmRDbGllbnQsIGNsaWVudCkge1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gXCJqcy9zcmMvc2RrL21vZGVscy9pbnRlZ3JhdGlvbnMudHNcIjtcbiAgICAgICAgdGhpcy5iYWNrZW5kQ2xpZW50ID0gYmFja2VuZENsaWVudDtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSBpbnRlZ3JhdGlvbnMgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gZXhwbG9yZSBhbmQgZGlzY292ZXIgdGhlIHN1cHBvcnRlZCBpbnRlZ3JhdGlvbnMuIEl0IHJldHVybnMgYW4gYXJyYXkgb2YgaW50ZWdyYXRpb24gb2JqZWN0cywgZWFjaCBjb250YWluaW5nIGVzc2VudGlhbCBkZXRhaWxzIHN1Y2ggYXMgdGhlIGludGVncmF0aW9uJ3Mga2V5LCBuYW1lLCBkZXNjcmlwdGlvbiwgbG9nbywgY2F0ZWdvcmllcywgYW5kIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW50ZWdyYXRpb25MaXN0UmVzPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2YgYWxsIGludGVncmF0aW9ucy5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KGRhdGEgPSB7fSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImxpc3RcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXBwTmFtZSwgYXBwVW5pcXVlS2V5LCAuLi5yZXN0IH0gPSBaTGlzdEludGVncmF0aW9uc1BhcmFtcy5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQXBwTmFtZSA9IGFwcE5hbWUgJiYgYXBwTmFtZS5sZW5ndGggPiAwID8gYXBwTmFtZSA6IGFwcFVuaXF1ZUtleTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmFwcENvbm5lY3Rvci5saXN0QWxsQ29ubmVjdG9ycyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBxdWVyeTogeyAuLi5yZXN0LCBhcHBOYW1lOiBmaW5hbEFwcE5hbWUgfSxcbiAgICAgICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBvZiBhIHNwZWNpZmljIGludGVncmF0aW9uIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybSBieSBwcm92aWRpbmcgaXRzIGludGVncmF0aW9uIG5hbWUuXG4gICAgICpcbiAgICAgKiBUaGUgcmVzcG9uc2UgaW5jbHVkZXMgdGhlIGludGVncmF0aW9uJ3MgbmFtZSwgZGlzcGxheSBuYW1lLCBkZXNjcmlwdGlvbiwgaW5wdXQgcGFyYW1ldGVycywgZXhwZWN0ZWQgcmVzcG9uc2UsIGFzc29jaWF0ZWQgYXBwIGluZm9ybWF0aW9uLCBhbmQgZW5hYmxlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ludGVncmF0aW9uR2V0UGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEludGVncmF0aW9uR2V0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZGV0YWlscyBvZiB0aGUgaW50ZWdyYXRpb24uXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KGRhdGEpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmFwcENvbm5lY3Rvci5nZXRDb25uZWN0b3JJbmZvKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IGRhdGEsXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGludGVncmF0aW9uJ3MgYXV0aGVudGljYXRpb24gc2NoZW1lLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBnZXQgdGhlIG5lY2Vzc2FyeSBpbnB1dCBmaWVsZHMgZm9yIGEgc3BlY2lmaWMgaW50ZWdyYXRpb24ncyBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ludGVncmF0aW9uR2V0UGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEludGVncmF0aW9uUmVxdWlyZWRQYXJhbXNSZXM+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBmb3IgdGhlIGludGVncmF0aW9uJ3MgYXV0aGVudGljYXRpb24gc2NoZW1lLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlcXVpcmVkUGFyYW1zKGRhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFJlcXVpcmVkUGFyYW1zXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaU2luZ2xlSW50ZWdyYXRpb25QYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5hcHBDb25uZWN0b3IuZ2V0Q29ubmVjdG9ySW5mbyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIGludGVncmF0aW9uSWQ6IGRhdGEuaW50ZWdyYXRpb25JZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHJlc3BvbnNlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5leHBlY3RlZElucHV0RmllbGRzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGludGVncmF0aW9uIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyBjbGllbnRzIHRvIGNyZWF0ZSBhIG5ldyBpbnRlZ3JhdGlvbiBieSBwcm92aWRpbmcgdGhlIG5lY2Vzc2FyeSBkZXRhaWxzIHN1Y2ggYXMgYXBwIElELCBuYW1lLCBhdXRoZW50aWNhdGlvbiBtb2RlLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW50ZWdyYXRpb25DcmVhdGVQYXJhbXN9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEludGVncmF0aW9uR2V0UmVzcG9uc2U+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgY3JlYXRlZCBpbnRlZ3JhdGlvbiBtb2RlbC5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGUoZGF0YSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiY3JlYXRlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaQ3JlYXRlSW50ZWdyYXRpb25QYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBsZXQgdW5pcXVlS2V5ID0gZGF0YS5hcHBVbmlxdWVLZXk7XG4gICAgICAgICAgICBpZiAoIXVuaXF1ZUtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcHMgPSBhd2FpdCBhcGlDbGllbnQuYXBwcy5nZXRBcHBzKHsgY2xpZW50OiB0aGlzLmNsaWVudCB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHAgPSAoX2EgPSBhcHBzLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pdGVtcy5maW5kKChhcHApID0+IGFwcC5hcHBJZCA9PT0gZGF0YS5hcHBJZCk7XG4gICAgICAgICAgICAgICAgdW5pcXVlS2V5ID0gYXBwLmtleTtcbiAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5JTlZBTElEX1BBUkFNU19QQVNTRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBObyBhcHAgd2FzIGZvdW5kIHdpdGggdGhlIHByb3ZpZGVkIGFwcElkYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgUGxlYXNlIHByb3ZpZGUgYW4gYXBwIHVuaXF1ZSBrZXlgLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5hcHBDb25uZWN0b3JWMi5jcmVhdGVDb25uZWN0b3JWMih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcXVlS2V5OiB1bmlxdWVLZXksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlQ29tcG9zaW9BdXRoOiBkYXRhLnVzZUNvbXBvc2lvQXV0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhTY2hlbWU6IGRhdGEuYXV0aFNjaGVtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmF0aW9uU2VjcmV0czogZGF0YS5hdXRoQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpbnRlZ3JhdGlvbklkID0gcmVzcG9uc2UuZGF0YS5pbnRlZ3JhdGlvbklkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHsgaW50ZWdyYXRpb25JZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0T3JDcmVhdGVJbnRlZ3JhdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRPckNyZWF0ZUludGVncmF0aW9uXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaQ3JlYXRlSW50ZWdyYXRpb25QYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBsZXQgdW5pcXVlS2V5ID0gZGF0YS5hcHBVbmlxdWVLZXk7XG4gICAgICAgICAgICBpZiAoIXVuaXF1ZUtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcHMgPSBhd2FpdCBhcGlDbGllbnQuYXBwcy5nZXRBcHBzKHsgY2xpZW50OiB0aGlzLmNsaWVudCB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcHAgPSAoX2EgPSBhcHBzLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pdGVtcy5maW5kKChhcHApID0+IGFwcC5hcHBJZCA9PT0gZGF0YS5hcHBJZCk7XG4gICAgICAgICAgICAgICAgdW5pcXVlS2V5ID0gYXBwLmtleTtcbiAgICAgICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5JTlZBTElEX1BBUkFNU19QQVNTRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vIGFwcCB3YXMgZm91bmQgd2l0aCB0aGUgcHJvdmlkZWQgYXBwSWRgLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYFBsZWFzZSBwcm92aWRlIGFuIGFwcCB1bmlxdWUga2V5YCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LmFwcENvbm5lY3RvclYyLmdldE9yQ3JlYXRlQ29ubmVjdG9yKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgYXBwOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmlxdWVLZXksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlQ29tcG9zaW9BdXRoOiBkYXRhLnVzZUNvbXBvc2lvQXV0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhTY2hlbWU6IGRhdGEuYXV0aFNjaGVtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVncmF0aW9uU2VjcmV0czogZGF0YS5hdXRoQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpbnRlZ3JhdGlvbklkID0gcmVzcG9uc2UuZGF0YS5pbnRlZ3JhdGlvbklkO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHsgaW50ZWdyYXRpb25JZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbiBleGlzdGluZyBpbnRlZ3JhdGlvbiBpbiB0aGUgQ29tcG9zaW8gcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgY2xpZW50cyB0byBkZWxldGUgYW4gZXhpc3RpbmcgaW50ZWdyYXRpb24gYnkgcHJvdmlkaW5nIGl0cyBpbnRlZ3JhdGlvbiBJRC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SW50ZWdyYXRpb25MaXN0RGF0YX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8SW50ZWdyYXRpb25EZWxldGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBkZWxldGVkIGludGVncmF0aW9uIG1vZGVsLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaU2luZ2xlSW50ZWdyYXRpb25QYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5hcHBDb25uZWN0b3IuZGVsZXRlQ29ubmVjdG9yKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogZGF0YS5pbnRlZ3JhdGlvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdGhyb3dPbkVycm9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IFBVU0hFUl9LRVkgPSBwcm9jZXNzLmVudi5DTElFTlRfUFVTSEVSX0tFWSB8fCBcIjhlMWI4YzkyYjdmOGIyMTUxYzE1XCI7XG5jb25zdCBQVVNIRVJfQ0xVU1RFUiA9IFwibXQxXCI7XG5jbGFzcyBQdXNoZXJVdGlscyB7XG4gICAgc3RhdGljIGdldFB1c2hlckNsaWVudChiYXNlVVJMLCBhcGlLZXkpIHtcbiAgICAgICAgaWYgKCFQdXNoZXJVdGlscy5wdXNoZXJDbGllbnQpIHtcbiAgICAgICAgICAgIC8vIER5bmFtaWMgaW1wb3J0IG5vdCBhdmFpbGFibGUsIHVzaW5nIHJlcXVpcmUgZm9yIG5vd1xuICAgICAgICAgICAgLy8gVE9ETzogVXBkYXRlIHRvIHVzZSBkeW5hbWljIGltcG9ydCB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgICAgIGNvbnN0IFB1c2hlckNsaWVudCA9IHJlcXVpcmUoXCJwdXNoZXItanNcIik7XG4gICAgICAgICAgICBQdXNoZXJVdGlscy5wdXNoZXJDbGllbnQgPSBuZXcgUHVzaGVyQ2xpZW50KFBVU0hFUl9LRVksIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyOiBQVVNIRVJfQ0xVU1RFUixcbiAgICAgICAgICAgICAgICBjaGFubmVsQXV0aG9yaXphdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBlbmRwb2ludDogYCR7YmFzZVVSTH0vYXBpL3YxL2NsaWVudC9hdXRoL3B1c2hlcl9hdXRoYCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ4LWFwaS1rZXlcIjogYXBpS2V5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6IFwiYWpheFwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHVzaGVyVXRpbHMucHVzaGVyQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGEgUHVzaGVyIGNoYW5uZWwgYW5kIGJpbmRzIGFuIGV2ZW50IHRvIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxOYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNoYW5uZWwgdG8gc3Vic2NyaWJlIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCAtIFRoZSBldmVudCB0byBiaW5kIHRvIHRoZSBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7KGRhdGE6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KSA9PiB2b2lkfSBmbiAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cbiAgICAgKiBAcmV0dXJucyB7UHVzaGVyQ2xpZW50fSBUaGUgUHVzaGVyIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgc3Vic2NyaWJlKGNoYW5uZWxOYW1lLCBldmVudCwgZm4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IFB1c2hlclV0aWxzLnB1c2hlckNsaWVudC5zdWJzY3JpYmUoY2hhbm5lbE5hbWUpLmJpbmQoZXZlbnQsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcihgRXJyb3Igc3Vic2NyaWJpbmcgdG8gJHtjaGFubmVsTmFtZX0gd2l0aCBldmVudCAke2V2ZW50fTogJHtlcnJvcn1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZXMgZnJvbSBhIFB1c2hlciBjaGFubmVsLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFubmVsTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjaGFubmVsIHRvIHVuc3Vic2NyaWJlIGZyb20uXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgc3RhdGljIGFzeW5jIHVuc3Vic2NyaWJlKGNoYW5uZWxOYW1lKSB7XG4gICAgICAgIFB1c2hlclV0aWxzLnB1c2hlckNsaWVudC51bnN1YnNjcmliZShjaGFubmVsTmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIGFuIGV2ZW50IHRvIGEgY2hhbm5lbCB3aXRoIHN1cHBvcnQgZm9yIGNodW5rZWQgbWVzc2FnZXMuXG4gICAgICogQHBhcmFtIHtQdXNoZXJDbGllbnR9IGNoYW5uZWwgLSBUaGUgUHVzaGVyIGNoYW5uZWwgdG8gYmluZCB0aGUgZXZlbnQgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IHRvIGJpbmQgdG8gdGhlIGNoYW5uZWwuXG4gICAgICogQHBhcmFtIHsoZGF0YTogdW5rbm93bikgPT4gdm9pZH0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG4gICAgICovXG4gICAgc3RhdGljIGJpbmRXaXRoQ2h1bmtpbmcoY2hhbm5lbCwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNoYW5uZWwuYmluZChldmVudCwgY2FsbGJhY2spOyAvLyBBbGxvdyBub3JtYWwgdW5jaHVua2VkIGV2ZW50cy5cbiAgICAgICAgLy8gTm93IHRoZSBjaHVua2VkIHZhcmlhdGlvbi4gQWxsb3dzIGFyYml0cmFyaWx5IGxvbmcgbWVzc2FnZXMuXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IHt9O1xuICAgICAgICBjaGFubmVsLmJpbmQoXCJjaHVua2VkLVwiICsgZXZlbnQsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlZERhdGEgPSBkYXRhO1xuICAgICAgICAgICAgaWYgKCFldmVudHMuaGFzT3duUHJvcGVydHkodHlwZWREYXRhLmlkKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50c1t0eXBlZERhdGEuaWRdID0geyBjaHVua3M6IFtdLCByZWNlaXZlZEZpbmFsOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXYgPSBldmVudHNbdHlwZWREYXRhLmlkXTtcbiAgICAgICAgICAgIGV2LmNodW5rc1t0eXBlZERhdGEuaW5kZXhdID0gdHlwZWREYXRhLmNodW5rO1xuICAgICAgICAgICAgaWYgKHR5cGVkRGF0YS5maW5hbClcbiAgICAgICAgICAgICAgICBldi5yZWNlaXZlZEZpbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChldi5yZWNlaXZlZEZpbmFsICYmXG4gICAgICAgICAgICAgICAgZXYuY2h1bmtzLmxlbmd0aCA9PT0gT2JqZWN0LmtleXMoZXYuY2h1bmtzKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhKU09OLnBhcnNlKGV2LmNodW5rcy5qb2luKFwiXCIpKSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlZERhdGEuaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBhIHRyaWdnZXIgY2hhbm5lbCBmb3IgYSBjbGllbnQgYW5kIGhhbmRsZXMgY2h1bmtlZCBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGllbnRJZCAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNsaWVudCBzdWJzY3JpYmluZyB0byB0aGUgZXZlbnRzLlxuICAgICAqIEBwYXJhbSB7KGRhdGE6IFRyaWdnZXJEYXRhKSA9PiB2b2lkfSBmbiAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdHJpZ2dlciBkYXRhIGlzIHJlY2VpdmVkLlxuICAgICAqL1xuICAgIHN0YXRpYyB0cmlnZ2VyU3Vic2NyaWJlKGNsaWVudElkLCBmbikge1xuICAgICAgICBjb25zdCBjaGFubmVsID0gUHVzaGVyVXRpbHMucHVzaGVyQ2xpZW50LnN1YnNjcmliZShgcHJpdmF0ZS0ke2NsaWVudElkfV90cmlnZ2Vyc2ApO1xuICAgICAgICBQdXNoZXJVdGlscy5iaW5kV2l0aENodW5raW5nKGNoYW5uZWwsIFwidHJpZ2dlcl90b19jbGllbnRcIiwgZm4pO1xuICAgICAgICBsb2dnZXIuaW5mbyhgU3Vic2NyaWJlZCB0byB0cmlnZ2Vycy4gWW91IHNob3VsZCBzdGFydCByZWNlaXZpbmcgZXZlbnRzIG5vdy5gKTtcbiAgICB9XG4gICAgc3RhdGljIHRyaWdnZXJVbnN1YnNjcmliZShjbGllbnRJZCkge1xuICAgICAgICBQdXNoZXJVdGlscy5wdXNoZXJDbGllbnQudW5zdWJzY3JpYmUoYCR7Y2xpZW50SWR9X3RyaWdnZXJzYCk7XG4gICAgfVxufVxuXG5jb25zdCBaVHJpZ2dlclF1ZXJ5ID0gei56Lm9iamVjdCh7XG4gICAgdHJpZ2dlcklkczogei56LmFycmF5KHouei5zdHJpbmcoKSkub3B0aW9uYWwoKS5kZXNjcmliZShcIlRyaWdnZXIgSW5zdGFuY2UgSURzXCIpLFxuICAgIHRyaWdnZXJJbnN0YW5jZUlkczogei56XG4gICAgICAgIC5hcnJheSh6Lnouc3RyaW5nKCkpXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIlRyaWdnZXIgSW5zdGFuY2UgSURzXCIpLFxuICAgIGFwcE5hbWVzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQXBwIE5hbWVzIGluIGxvd2VyY2FzZVwiKSxcbiAgICBhcHBVbmlxdWVLZXlzOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiQXBwIFVuaXF1ZSBLZXlzXCIpLFxuICAgIGNvbm5lY3RlZEFjY291bnRJZHM6IHouelxuICAgICAgICAuYXJyYXkoei56LnN0cmluZygpKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAuZGVzY3JpYmUoXCJDb25uZWN0ZWQgQWNjb3VudCBVVUlEc1wiKSxcbiAgICBpbnRlZ3JhdGlvbklkczogei56LmFycmF5KHouei5zdHJpbmcoKSkub3B0aW9uYWwoKS5kZXNjcmliZShcIkludGVncmF0aW9uIElEc1wiKSxcbiAgICBzaG93RW5hYmxlZE9ubHk6IHouelxuICAgICAgICAuYm9vbGVhbigpXG4gICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgIC5kZXNjcmliZShcIlNob3cgRW5hYmxlZCB0cmlnZ2VycyBvbmx5XCIpLFxufSk7XG5jb25zdCBaVHJpZ2dlckluc3RhbmNlSXRlbXMgPSB6Lnoub2JqZWN0KHtcbiAgICB0cmlnZ2VySW5zdGFuY2VJZDogei56LnN0cmluZygpLFxufSk7XG5jb25zdCBaVHJpZ2dlclNldHVwUGFyYW0gPSB6Lnoub2JqZWN0KHtcbiAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHouei5zdHJpbmcoKSxcbiAgICB0cmlnZ2VyTmFtZTogei56LnN0cmluZygpLFxuICAgIGNvbmZpZzogei56LnJlY29yZCh6LnoudW5rbm93bigpKS5vcHRpb25hbCgpLFxufSk7XG56Lnoub2JqZWN0KHtcbiAgICBhcHBOYW1lOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB0cmlnZ2VySWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNvbm5lY3Rpb25JZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgaW50ZWdyYXRpb25JZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdHJpZ2dlck5hbWU6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHRyaWdnZXJEYXRhOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICBlbnRpdHlJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IFpTaW5nbGVUcmlnZ2VyUGFyYW0gPSB6Lnoub2JqZWN0KHtcbiAgICB0cmlnZ2VySWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHRyaWdnZXJOYW1lOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbn0pO1xuei56Lm9iamVjdCh7XG4gICAgdHJpZ2dlckluc3RhbmNlSWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHRyaWdnZXJJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG59KTtcbnouei5vYmplY3Qoe1xuICAgIG5hbWU6IHouei5zdHJpbmcoKSxcbiAgICBkaXNwbGF5TmFtZTogei56LnN0cmluZygpLFxuICAgIGRlc2NyaXB0aW9uOiB6Lnouc3RyaW5nKCksXG4gICAgdHlwZTogei56LnN0cmluZygpLFxuICAgIGFwcElkOiB6Lnouc3RyaW5nKCksXG4gICAgYXBwTmFtZTogei56LnN0cmluZygpLFxuICAgIGluc3RydWN0aW9uczogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgcGF5bG9hZDogei56LnJlY29yZCh6LnoudW5rbm93bigpKSxcbiAgICBjb25maWc6IHouei5yZWNvcmQoei56LnVua25vd24oKSksXG59KTtcblxuY2xhc3MgVHJpZ2dlcnMge1xuICAgIGNvbnN0cnVjdG9yKGJhY2tlbmRDbGllbnQsIGNsaWVudCkge1xuICAgICAgICB0aGlzLnRyaWdnZXJfdG9fY2xpZW50X2V2ZW50ID0gXCJ0cmlnZ2VyX3RvX2NsaWVudFwiO1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gXCJqcy9zcmMvc2RrL21vZGVscy90cmlnZ2Vycy50c1wiO1xuICAgICAgICB0aGlzLmJhY2tlbmRDbGllbnQgPSBiYWNrZW5kQ2xpZW50O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBhbGwgdHJpZ2dlcnMgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIHlvdSB0byBmZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBhdmFpbGFibGUgdHJpZ2dlcnMuIEl0IHN1cHBvcnRzIHBhZ2luYXRpb24gdG8gaGFuZGxlIGxhcmdlIG51bWJlcnMgb2YgdHJpZ2dlcnMuIFRoZSByZXNwb25zZSBpbmNsdWRlcyBhbiBhcnJheSBvZiB0cmlnZ2VyIG9iamVjdHMsIGVhY2ggY29udGFpbmluZyBpbmZvcm1hdGlvbiBzdWNoIGFzIHRoZSB0cmlnZ2VyJ3MgbmFtZSwgZGVzY3JpcHRpb24sIGlucHV0IHBhcmFtZXRlcnMsIGV4cGVjdGVkIHJlc3BvbnNlLCBhc3NvY2lhdGVkIGFwcCBpbmZvcm1hdGlvbiwgYW5kIGVuYWJsZWQgc3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMaXN0VHJpZ2dlcnNEYXRhfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxMaXN0VHJpZ2dlcnNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsaXN0IG9mIGFsbCB0cmlnZ2Vycy5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0KGRhdGEgPSB7fSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImxpc3RcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXBwTmFtZXMsIHRyaWdnZXJJZHMsIGNvbm5lY3RlZEFjY291bnRJZHMsIGludGVncmF0aW9uSWRzLCBzaG93RW5hYmxlZE9ubHksIHRyaWdnZXJJbnN0YW5jZUlkcywgYXBwVW5pcXVlS2V5cywgfSA9IFpUcmlnZ2VyUXVlcnkucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBmaW5hbFRyaWdnZXJJbnN0YW5jZUlkcyA9IHRyaWdnZXJJZHMgJiYgdHJpZ2dlcklkcy5sZW5ndGggPiAwID8gdHJpZ2dlcklkcyA6IHRyaWdnZXJJbnN0YW5jZUlkcztcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsQXBwTmFtZXMgPSBhcHBOYW1lcyAmJiBhcHBOYW1lcy5sZW5ndGggPiAwID8gYXBwTmFtZXMgOiBhcHBVbmlxdWVLZXlzO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiByZXNwb25zZSB9ID0gYXdhaXQgYXBpQ2xpZW50LnRyaWdnZXJzLmxpc3RUcmlnZ2Vycyh7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lczogZmluYWxBcHBOYW1lcyA9PT0gbnVsbCB8fCBmaW5hbEFwcE5hbWVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaW5hbEFwcE5hbWVzLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VySWRzOiBmaW5hbFRyaWdnZXJJbnN0YW5jZUlkcyA9PT0gbnVsbCB8fCBmaW5hbFRyaWdnZXJJbnN0YW5jZUlkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmluYWxUcmlnZ2VySW5zdGFuY2VJZHMuam9pbihcIixcIiksXG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZHM6IGNvbm5lY3RlZEFjY291bnRJZHMgPT09IG51bGwgfHwgY29ubmVjdGVkQWNjb3VudElkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGVkQWNjb3VudElkcy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZHM6IGludGVncmF0aW9uSWRzID09PSBudWxsIHx8IGludGVncmF0aW9uSWRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlZ3JhdGlvbklkcy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgICAgICAgICAgc2hvd0VuYWJsZWRPbmx5OiBzaG93RW5hYmxlZE9ubHkgfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZSB8fCByZXNwb25zZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkJBQ0tFTkQuTk9UX0ZPVU5ELCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVHJpZ2dlciBub3QgZm91bmQgd2l0aCB0aGUgZ2l2ZW4gcGFyYW1zXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRyaWdnZXIgbm90IGZvdW5kIHdpdGggdGhlIGdpdmVuIHBhcmFtc1wiLFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQYXNzIGEgY2hlY2sgaWYgZmlsdGVyIHBhcmFtcyBhcmUgY29ycmVjdFwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBzaW5nbGUgdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJpZ2dlclNpbmdsZVBhcmFtfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxUcmlnZ2VyU2luZ2xlQ29uZmlnPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyaWdnZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgZGF0YSB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJpZ2dlckluZm8oZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHVzZSB0cmlnZ2VyLmdldCBpbnN0ZWFkXG4gICAgICogUmV0cmlldmVzIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgc2luZ2xlIHRyaWdnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyaWdnZXJTaW5nbGVQYXJhbX0gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHJpZ2dlclNpbmdsZUNvbmZpZz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB0cmlnZ2VyIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJpZ2dlckNvbmZpZyhkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0U2luZ2xlVHJpZ2dlckNvbmZpZ1wiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpTaW5nbGVUcmlnZ2VyUGFyYW0ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZERhdGEudHJpZ2dlck5hbWUgJiYgIXBhcnNlZERhdGEudHJpZ2dlcklkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uSU5WQUxJRF9QQVJBTVNfUEFTU0VELCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVHJpZ2dlciBuYW1lIG9yIHRyaWdnZXIgaWQgaXMgcmVxdWlyZWRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVHJpZ2dlciBuYW1lIG9yIHRyaWdnZXIgaWQgaXMgcmVxdWlyZWRcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGaXg6IFwiUGFzcyBlaXRoZXIgdHJpZ2dlck5hbWUgb3IgdHJpZ2dlcklkXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBhcGlDbGllbnQudHJpZ2dlcnMuZ2V0VHJpZ2dlckluZm9WMih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOYW1lOiBwYXJzZWREYXRhLnRyaWdnZXJOYW1lIHx8IHBhcnNlZERhdGEudHJpZ2dlcklkIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQmFkIHR5cGUgaW5mZXJlbmNlXG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VySW5mbyA9IHJlcy5kYXRhO1xuICAgICAgICAgICAgaWYgKCF0cmlnZ2VySW5mbykge1xuICAgICAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5OT1RfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUcmlnZ2VyIGluZm8gbm90IGZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRyaWdnZXIgaW5mbyBub3QgZm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGaXg6IFwiUGFzcyBhIGNoZWNrIGlmIHRyaWdnZXIgZXhpc3RzXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBjb25maWc6IHRyaWdnZXJJbmZvLmNvbmZpZyB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgaW5mb3JtYXRpb24gYWJvdXQgYSBzaW5nbGUgdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJpZ2dlclNpbmdsZVBhcmFtfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTaW5nbGVUcmlnZ2VyUmVzPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHRyaWdnZXIgaW5mb3JtYXRpb24uXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0VHJpZ2dlckluZm8oZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFRyaWdnZXJJbmZvXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWlNpbmdsZVRyaWdnZXJQYXJhbS5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGFwaUNsaWVudC50cmlnZ2Vycy5nZXRUcmlnZ2VySW5mb1YyKHtcbiAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LFxuICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlck5hbWU6IHBhcnNlZERhdGEudHJpZ2dlck5hbWUgfHwgcGFyc2VkRGF0YS50cmlnZ2VySWQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBCYWQgdHlwZSBpbmZlcmVuY2VcbiAgICAgICAgICAgIGNvbnN0IHRyaWdnZXIgPSByZXMuZGF0YTtcbiAgICAgICAgICAgIGlmICghdHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQkFDS0VORC5OT1RfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUcmlnZ2VyIGluZm8gbm90IGZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRyaWdnZXIgaW5mbyBub3QgZm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgcG9zc2libGVGaXg6IFwiUGFzcyBhIGNoZWNrIGlmIHRyaWdnZXIgZXhpc3RzXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgYSB0cmlnZ2VyIGZvciBhIGNvbm5lY3RlZCBhY2NvdW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZXR1cFRyaWdnZXJEYXRhfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxTZXR1cFRyaWdnZXJSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBzZXR1cCB0cmlnZ2VyIHJlc3BvbnNlLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHNldHVwKHBhcmFtcykge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcInNldHVwXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRGF0YSA9IFpUcmlnZ2VyU2V0dXBQYXJhbS5wYXJzZShwYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQudHJpZ2dlcnMuZW5hYmxlVHJpZ2dlcih7XG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogcGFyc2VkRGF0YS5jb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOYW1lOiBwYXJzZWREYXRhLnRyaWdnZXJOYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQ29uZmlnOiBwYXJzZWREYXRhLmNvbmZpZyB8fCB7fSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRocm93T25FcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyB0cmlnZ2VySWQsIHN0YXR1cyB9ID0gcmVzcG9uc2UuZGF0YTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcklkOiB0cmlnZ2VySWQsXG4gICAgICAgICAgICAgICAgdHJpZ2dlck5hbWU6IHBhcnNlZERhdGEudHJpZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJJbnN0YW5jZUlkOiB0cmlnZ2VySWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGEgdHJpZ2dlciBmb3IgYSBjb25uZWN0ZWQgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dHJpZ2dlcklkLHRyaWdnZXJJbnN0YW5jZUlkfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIG9mIHRoZSBlbmFibGUgcmVxdWVzdC5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBlbmFibGUoZGF0YSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImVuYWJsZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZmluYWxUcmlnZ2VySWQgPSBkYXRhLnRyaWdnZXJJZCB8fCBkYXRhLnRyaWdnZXJJbnN0YW5jZUlkO1xuICAgICAgICAgICAgaWYgKCFmaW5hbFRyaWdnZXJJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLklOVkFMSURfUEFSQU1TX1BBU1NFRCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRyaWdnZXIgSUQgaXMgcmVxdWlyZWRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVHJpZ2dlciBJRCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQYXNzIGVpdGhlciB0cmlnZ2VySWQgb3IgdHJpZ2dlckluc3RhbmNlSWRcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGFwaUNsaWVudC50cmlnZ2Vycy5zd2l0Y2hUcmlnZ2VySW5zdGFuY2VTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VySWQ6IGZpbmFsVHJpZ2dlcklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIGEgdHJpZ2dlciBmb3IgYSBjb25uZWN0ZWQgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dHJpZ2dlcklkLHRyaWdnZXJJbnN0YW5jZUlkfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlc3BvbnNlIG9mIHRoZSBkaXNhYmxlIHJlcXVlc3QuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZGlzYWJsZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZGlzYWJsZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZmluYWxUcmlnZ2VySWQgPSBkYXRhLnRyaWdnZXJJZCB8fCBkYXRhLnRyaWdnZXJJbnN0YW5jZUlkO1xuICAgICAgICAgICAgaWYgKCFmaW5hbFRyaWdnZXJJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLklOVkFMSURfUEFSQU1TX1BBU1NFRCwge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlRyaWdnZXIgSUQgaXMgcmVxdWlyZWRcIixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiVHJpZ2dlciBJRCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQYXNzIGVpdGhlciB0cmlnZ2VySWQgb3IgdHJpZ2dlckluc3RhbmNlSWRcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IGFwaUNsaWVudC50cmlnZ2Vycy5zd2l0Y2hUcmlnZ2VySW5zdGFuY2VTdGF0dXMoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VySWQ6IGZpbmFsVHJpZ2dlcklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgdHJpZ2dlciBmb3IgYSBjb25uZWN0ZWQgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJpZ2dlckluc3RhbmNlSXRlbXN9IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgcmVzcG9uc2Ugb2YgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShkYXRhKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGRhdGEgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWREYXRhID0gWlRyaWdnZXJJbnN0YW5jZUl0ZW1zLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgYXdhaXQgYXBpQ2xpZW50LnRyaWdnZXJzLmRlbGV0ZVRyaWdnZXIoe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VySW5zdGFuY2VJZDogcGFyc2VkRGF0YS50cmlnZ2VySW5zdGFuY2VJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJzdWNjZXNzXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzdWJzY3JpYmUoZm4sIGZpbHRlcnMgPSB7fSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcInN1YnNjcmliZVwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBmaWx0ZXJzIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gaXMgcmVxdWlyZWQgZm9yIHRyaWdnZXIgc3Vic2NyaXB0aW9uXCIpO1xuICAgICAgICBjb25zdCBjbGllbnRJZCA9IGF3YWl0IHRoaXMuYmFja2VuZENsaWVudC5nZXRDbGllbnRJZCgpO1xuICAgICAgICBhd2FpdCBQdXNoZXJVdGlscy5nZXRQdXNoZXJDbGllbnQodGhpcy5iYWNrZW5kQ2xpZW50LmJhc2VVcmwsIHRoaXMuYmFja2VuZENsaWVudC5hcGlLZXkpO1xuICAgICAgICBjb25zdCBzaG91bGRTZW5kVHJpZ2dlciA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoZmlsdGVycykubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoIWZpbHRlcnMuYXBwTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICBkYXRhLmFwcE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gZmlsdGVycy5hcHBOYW1lLnRvTG93ZXJDYXNlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgICghZmlsdGVycy50cmlnZ2VySWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEubWV0YWRhdGEuaWQudG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzLnRyaWdnZXJJZC50b0xvd2VyQ2FzZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWZpbHRlcnMuY29ubmVjdGlvbklkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm1ldGFkYXRhLmNvbm5lY3Rpb25JZC50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcnMuY29ubmVjdGlvbklkLnRvTG93ZXJDYXNlKCkpICYmXG4gICAgICAgICAgICAgICAgICAgICghZmlsdGVycy50cmlnZ2VyTmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5tZXRhZGF0YS50cmlnZ2VyTmFtZS50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcnMudHJpZ2dlck5hbWUudG9Mb3dlckNhc2UoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmaWx0ZXJzLmVudGl0eUlkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLm1ldGFkYXRhLmNvbm5lY3Rpb24uY2xpZW50VW5pcXVlVXNlcklkLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVycy5lbnRpdHlJZC50b0xvd2VyQ2FzZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWZpbHRlcnMuaW50ZWdyYXRpb25JZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5tZXRhZGF0YS5jb25uZWN0aW9uLmludGVncmF0aW9uSWQudG9Mb3dlckNhc2UoKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXJzLmludGVncmF0aW9uSWQudG9Mb3dlckNhc2UoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoXCJTdWJzY3JpYmluZyB0byB0cmlnZ2Vyc1wiLCBmaWx0ZXJzKTtcbiAgICAgICAgUHVzaGVyVXRpbHMudHJpZ2dlclN1YnNjcmliZShjbGllbnRJZCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTZW5kVHJpZ2dlcihkYXRhKSkge1xuICAgICAgICAgICAgICAgIGZuKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIGNvbnN0IGNsaWVudElkID0gYXdhaXQgdGhpcy5iYWNrZW5kQ2xpZW50LmdldENsaWVudElkKCk7XG4gICAgICAgIFB1c2hlclV0aWxzLnRyaWdnZXJVbnN1YnNjcmliZShjbGllbnRJZCk7XG4gICAgfVxufVxuXG5jb25zdCBMQUJFTFMgPSB7XG4gICAgUFJJTUFSWTogXCJwcmltYXJ5XCIsXG59O1xuY2xhc3MgRW50aXR5IHtcbiAgICBjb25zdHJ1Y3RvcihiYWNrZW5kQ2xpZW50LCBpZCA9IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9zZGsvbW9kZWxzL0VudGl0eS50c1wiO1xuICAgICAgICB0aGlzLmJhY2tlbmRDbGllbnQgPSBiYWNrZW5kQ2xpZW50O1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMudHJpZ2dlck1vZGVsID0gbmV3IFRyaWdnZXJzKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5hY3Rpb25zTW9kZWwgPSBuZXcgQWN0aW9ucyh0aGlzLmJhY2tlbmRDbGllbnQsIHRoaXMuYmFja2VuZENsaWVudC5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYXBwcyA9IG5ldyBBcHBzKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBY2NvdW50cyA9IG5ldyBDb25uZWN0ZWRBY2NvdW50cyh0aGlzLmJhY2tlbmRDbGllbnQsIHRoaXMuYmFja2VuZENsaWVudC5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuaW50ZWdyYXRpb25zID0gbmV3IEludGVncmF0aW9ucyh0aGlzLmJhY2tlbmRDbGllbnQsIHRoaXMuYmFja2VuZENsaWVudC5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYWN0aXZlVHJpZ2dlcnMgPSBuZXcgQWN0aXZlVHJpZ2dlcnModGhpcy5iYWNrZW5kQ2xpZW50LCB0aGlzLmJhY2tlbmRDbGllbnQuaW5zdGFuY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyBhbiBhY3Rpb24gZm9yIGFuIGVudGl0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25OYW1lIFRoZSBuYW1lIG9mIHRoZSBhY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIHVua25vd24+fSBwYXJhbXMgVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBhY3Rpb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gcGFzcyB0byB0aGUgYWN0aW9uLiBUaGlzIGNhbiBiZSB0byBwZXJmb3JtIE5MQSBleGVjdXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29ubmVjdGVkQWNjb3VudElkIFRoZSBJRCBvZiB0aGUgY29ubmVjdGVkIGFjY291bnQgdG8gdXNlIGZvciB0aGUgYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGlvbkV4ZWN1dGVSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXNwb25zZSBmcm9tIHRoZSBhY3Rpb24gZXhlY3V0aW9uLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGUoeyBhY3Rpb25OYW1lLCBwYXJhbXMsIHRleHQsIGNvbm5lY3RlZEFjY291bnRJZCwgfSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImV4ZWN1dGVcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgYWN0aW9uTmFtZSwgcGFyYW1zLCB0ZXh0LCBjb25uZWN0ZWRBY2NvdW50SWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBaRXhlY3V0ZUFjdGlvblBhcmFtcyQxLnBhcnNlKHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gYXdhaXQgdGhpcy5hY3Rpb25zTW9kZWwuZ2V0KHtcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lOiBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYWN0aW9uOiAke2FjdGlvbk5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcHAgPSBhd2FpdCB0aGlzLmFwcHMuZ2V0KHtcbiAgICAgICAgICAgICAgICBhcHBLZXk6IGFjdGlvbi5hcHBLZXksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChhcHAubm9fYXV0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjdGlvbnNNb2RlbC5leGVjdXRlKHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uTmFtZTogYWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBOYW1lOiBhY3Rpb24uYXBwS2V5LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkQWNjb3VudCA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGlvbih7XG4gICAgICAgICAgICAgICAgYXBwOiBhY3Rpb24uYXBwS2V5LFxuICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5TREsuTk9fQ09OTkVDVEVEX0FDQ09VTlRfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGlvbiB3aXRoIGFwcD0nJHthY3Rpb24uYXBwS2V5fScgYW5kIGVudGl0eT0nJHt0aGlzLmlkfSdgLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYENvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGlvbiB3aXRoIGFwcD0nJHthY3Rpb24uYXBwS2V5fScgYW5kIGVudGl0eT0nJHt0aGlzLmlkfSdgLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uc01vZGVsLmV4ZWN1dGUoe1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IGNvbm5lY3RlZEFjY291bnQgPT09IG51bGwgfHwgY29ubmVjdGVkQWNjb3VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGVkQWNjb3VudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZTogYWN0aW9uLmFwcEtleSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgcmVxdWlyZWQgcGFyYW1ldGVycyBmb3IgYSBzcGVjaWZpYyBhdXRoZW50aWNhdGlvbiBzY2hlbWUgb2YgYW4gYXBwIGluIHRoZSBDb21wb3NpbyBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyBjbGllbnRzIHRvIGZldGNoIHRoZSBuZWNlc3NhcnkgcGFyYW1ldGVycyBmb3IgYSBzcGVjaWZpYyBhdXRoZW50aWNhdGlvbiBzY2hlbWUgb2YgYW4gYXBwIGJ5IHByb3ZpZGluZyBpdHMgdW5pcXVlIGtleSBhbmQgdGhlIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29ubmVjdGlvblBhcmFtc30gZGF0YSBUaGUgZGF0YSBmb3IgdGhlIHJlcXVlc3QsIGluY2x1ZGluZyB0aGUgYXBwJ3MgdW5pcXVlIGtleSBhbmQgdGhlIGF1dGhlbnRpY2F0aW9uIHNjaGVtZS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1aXJlZFBhcmFtc1Jlc3BvbnNlPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlcXVpcmVkIHBhcmFtZXRlcnMgZm9yIHRoZSBhdXRoZW50aWNhdGlvbiBzY2hlbWUuXG4gICAgICogQHRocm93cyB7Q29tcG9zaW9FcnJvcn0gSWYgdGhlIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q29ubmVjdGlvbih7IGFwcCwgYXBwTmFtZSwgY29ubmVjdGVkQWNjb3VudElkIH0pIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRDb25uZWN0aW9uXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGFwcCwgYXBwTmFtZSwgY29ubmVjdGVkQWNjb3VudElkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZmluYWxBcHAgPSBhcHBOYW1lIHx8IGFwcDtcbiAgICAgICAgICAgIFpDb25uZWN0aW9uUGFyYW1zLnBhcnNlKHsgYXBwOiBmaW5hbEFwcCwgY29ubmVjdGVkQWNjb3VudElkIH0pO1xuICAgICAgICAgICAgaWYgKCFmaW5hbEFwcCAmJiAhY29ubmVjdGVkQWNjb3VudElkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uSU5WQUxJRF9QQVJBTVNfUEFTU0VELCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQXBwIG9yIGNvbm5lY3RlZEFjY291bnRJZCBpcyByZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJBcHAgb3IgY29ubmVjdGVkQWNjb3VudElkIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29ubmVjdGVkQWNjb3VudElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY29ubmVjdGVkQWNjb3VudHMuZ2V0KHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGxhdGVzdEFjY291bnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGxhdGVzdENyZWF0aW9uRGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRBY2NvdW50cyA9IGF3YWl0IHRoaXMuY29ubmVjdGVkQWNjb3VudHMubGlzdCh7XG4gICAgICAgICAgICAgICAgdXNlcl91dWlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgY29ubmVjdGVkQWNjb3VudHMuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGFjY291bnQgPT09IG51bGwgfHwgYWNjb3VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWNjb3VudC5sYWJlbHMpICYmIChhY2NvdW50ID09PSBudWxsIHx8IGFjY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjY291bnQubGFiZWxzLmluY2x1ZGVzKExBQkVMUy5QUklNQVJZKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0QWNjb3VudCA9IGFjY291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGF0ZXN0QWNjb3VudCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29ubmVjdGVkQWNjb3VudCBvZiBjb25uZWN0ZWRBY2NvdW50cy5pdGVtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGZpbmFsQXBwID09PSBudWxsIHx8IGZpbmFsQXBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaW5hbEFwcC50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnQuYXBwTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjcmVhdGlvbkRhdGUgPSBuZXcgRGF0ZShjb25uZWN0ZWRBY2NvdW50LmNyZWF0ZWRBdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCFsYXRlc3RBY2NvdW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxhdGVzdENyZWF0aW9uRGF0ZSAmJiBjcmVhdGlvbkRhdGUgPiBsYXRlc3RDcmVhdGlvbkRhdGUpKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnQuc3RhdHVzID09PSBcIkFDVElWRVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0Q3JlYXRpb25EYXRlID0gY3JlYXRpb25EYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhdGVzdEFjY291bnQgPSBjb25uZWN0ZWRBY2NvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsYXRlc3RBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5TREsuTk9fQ09OTkVDVEVEX0FDQ09VTlRfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGlvbiB3aXRoIGFwcD0nJHtmaW5hbEFwcH0nIGFuZCBlbnRpdHk9JyR7dGhpcy5pZH0nYCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDb3VsZCBub3QgZmluZCBhIGNvbm5lY3Rpb24gd2l0aCBhcHA9JyR7ZmluYWxBcHB9JyBhbmQgZW50aXR5PScke3RoaXMuaWR9J2AsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRBY2NvdW50ID0gYXdhaXQgdGhpcy5jb25uZWN0ZWRBY2NvdW50cy5nZXQoe1xuICAgICAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogbGF0ZXN0QWNjb3VudC5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWRBY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5TREsuTk9fQ09OTkVDVEVEX0FDQ09VTlRfRk9VTkQsIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYENvdWxkIG5vdCBmaW5kIGEgY29ubmVjdGlvbiB3aXRoIGFwcD0nJHtmaW5hbEFwcH0nIGFuZCBlbnRpdHk9JyR7dGhpcy5pZH0nYCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDb3VsZCBub3QgZmluZCBhIGNvbm5lY3Rpb24gd2l0aCBhcHA9JyR7ZmluYWxBcHB9JyBhbmQgZW50aXR5PScke3RoaXMuaWR9J2AsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGVkQWNjb3VudDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBvZiBhbiBhcHAgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gc2V0dXAgYSB0cmlnZ2VyIGZvciBhbiBhcHAgYnkgcHJvdmlkaW5nIGl0cyB1bmlxdWUga2V5IGFuZCB0aGUgdHJpZ2dlciBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmlnZ2VyU3Vic2NyaWJlUGFyYW19IGRhdGEgVGhlIGRhdGEgZm9yIHRoZSByZXF1ZXN0LCBpbmNsdWRpbmcgdGhlIGFwcCdzIHVuaXF1ZSBrZXkgYW5kIHRoZSB0cmlnZ2VyIG5hbWUuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8UmVxdWlyZWRQYXJhbXNSZXNwb25zZT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciB0aGUgYXV0aGVudGljYXRpb24gc2NoZW1lLlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIHNldHVwVHJpZ2dlcih7IGFwcCwgYXBwTmFtZSwgdHJpZ2dlck5hbWUsIGNvbmZpZywgfSkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcInNldHVwVHJpZ2dlclwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBhcHAsIGFwcE5hbWUsIHRyaWdnZXJOYW1lLCBjb25maWcgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbEFwcCA9IGFwcE5hbWUgfHwgYXBwO1xuICAgICAgICAgICAgWlRyaWdnZXJTdWJzY3JpYmVQYXJhbS5wYXJzZSh7IGFwcDogZmluYWxBcHAsIHRyaWdnZXJOYW1lLCBjb25maWcgfSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRBY2NvdW50ID0gYXdhaXQgdGhpcy5nZXRDb25uZWN0aW9uKHsgYXBwOiBmaW5hbEFwcCB9KTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGVkQWNjb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuU0RLLk5PX0NPTk5FQ1RFRF9BQ0NPVU5UX0ZPVU5ELCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBDb3VsZCBub3QgZmluZCBhIGNvbm5lY3Rpb24gd2l0aCBhcHA9JyR7ZmluYWxBcHB9JyBhbmQgZW50aXR5PScke3RoaXMuaWR9J2AsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ291bGQgbm90IGZpbmQgYSBjb25uZWN0aW9uIHdpdGggYXBwPScke2ZpbmFsQXBwfScgYW5kIGVudGl0eT0nJHt0aGlzLmlkfSdgLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJpZ2dlciA9IGF3YWl0IHRoaXMudHJpZ2dlck1vZGVsLnNldHVwKHtcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IGNvbm5lY3RlZEFjY291bnQuaWQsXG4gICAgICAgICAgICAgICAgdHJpZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJpZ2dlcjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSByZXF1aXJlZCBwYXJhbWV0ZXJzIGZvciBhIHNwZWNpZmljIGF1dGhlbnRpY2F0aW9uIHNjaGVtZSBvZiBhbiBhcHAgaW4gdGhlIENvbXBvc2lvIHBsYXRmb3JtLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxsb3dzIGNsaWVudHMgdG8gZGlzYWJsZSBhIHRyaWdnZXIgYnkgcHJvdmlkaW5nIGl0cyB0cmlnZ2VyIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyaWdnZXJJZCBUaGUgSUQgb2YgdGhlIHRyaWdnZXIgdG8gZGlzYWJsZS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IHN0YXR1czogc3RyaW5nIH0+fSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgc3RhdHVzIG9mIHRoZSB0cmlnZ2VyIGRpc2FibGVtZW50LlxuICAgICAqIEB0aHJvd3Mge0NvbXBvc2lvRXJyb3J9IElmIHRoZSByZXF1ZXN0IGZhaWxzLlxuICAgICAqL1xuICAgIGFzeW5jIGRpc2FibGVUcmlnZ2VyKHRyaWdnZXJJZCkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImRpc2FibGVUcmlnZ2VyXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IHRyaWdnZXJJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYWN0aXZlVHJpZ2dlcnMuZGlzYWJsZSh7IHRyaWdnZXJJZDogdHJpZ2dlcklkIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInN1Y2Nlc3NcIiB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmhhbmRsZUFsbEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIGNvbm5lY3Rpb25zIGZvciBhbiBlbnRpdHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxDb25uZWN0aW9uSXRlbVtdPn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgY29ubmVjdGlvbiBpdGVtcy5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDb25uZWN0aW9ucygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbGwgY29ubmVjdGlvbnMgZm9yIGFuIGVudGl0eS5cbiAgICAgICAgICovXG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0Q29ubmVjdGlvbnNcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnRzID0gYXdhaXQgdGhpcy5jb25uZWN0ZWRBY2NvdW50cy5saXN0KHtcbiAgICAgICAgICAgICAgICB1c2VyX3V1aWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0ZWRBY2NvdW50cy5pdGVtcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFsbCBhY3RpdmUgdHJpZ2dlcnMgZm9yIGFuIGVudGl0eS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEFjdGl2ZVRyaWdnZXJbXT59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGFjdGl2ZSB0cmlnZ2Vycy5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRBY3RpdmVUcmlnZ2VycygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbGwgYWN0aXZlIHRyaWdnZXJzIGZvciBhbiBlbnRpdHkuXG4gICAgICAgICAqL1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldEFjdGl2ZVRyaWdnZXJzXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0ZWRBY2NvdW50cyA9IGF3YWl0IHRoaXMuZ2V0Q29ubmVjdGlvbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVRyaWdnZXJzID0gYXdhaXQgdGhpcy5hY3RpdmVUcmlnZ2Vycy5saXN0KHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkczogY29ubmVjdGVkQWNjb3VudHNcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoYWNjb3VudCkgPT4gYWNjb3VudC5pZClcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCIsXCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlVHJpZ2dlcnM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgY29ubmVjdGlvbiBmb3IgYW4gZW50aXR5LlxuICAgICAqIEBwYXJhbSB7SW5pdGlhdGVDb25uZWN0aW9uUGFyYW1zfSBkYXRhIFRoZSBkYXRhIGZvciB0aGUgcmVxdWVzdCwgaW5jbHVkaW5nIHRoZSBhcHAncyB1bmlxdWUga2V5IGFuZCB0aGUgYXV0aGVudGljYXRpb24gc2NoZW1lLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPENvbm5lY3Rpb25SZXF1ZXN0Pn0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNvbm5lY3Rpb24gcmVxdWVzdC5cbiAgICAgKiBAdGhyb3dzIHtDb21wb3Npb0Vycm9yfSBJZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBpbml0aWF0ZUNvbm5lY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImluaXRpYXRlQ29ubmVjdGlvblwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBkYXRhIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBhcHBOYW1lLCBhdXRoTW9kZSwgYXV0aENvbmZpZywgaW50ZWdyYXRpb25JZCwgY29ubmVjdGlvblBhcmFtcywgcmVkaXJlY3RVcmksIGxhYmVscywgfSA9IFpJbml0aWF0ZUNvbm5lY3Rpb25QYXJhbXMucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAvLyBJbml0aWF0ZSB0aGUgY29ubmVjdGlvbiBwcm9jZXNzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRBY2NvdW50cy5pbml0aWF0ZSh7XG4gICAgICAgICAgICAgICAgYXV0aE1vZGU6IGF1dGhNb2RlLFxuICAgICAgICAgICAgICAgIGF1dGhDb25maWc6IGF1dGhDb25maWcsXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogaW50ZWdyYXRpb25JZCxcbiAgICAgICAgICAgICAgICBhcHBOYW1lOiBhcHBOYW1lLFxuICAgICAgICAgICAgICAgIGVudGl0eUlkOiB0aGlzLmlkLFxuICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpOiByZWRpcmVjdFVyaSB8fCAoKF9hID0gZGF0YS5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFVybCkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUGFyYW1zOiBjb25uZWN0aW9uUGFyYW1zLFxuICAgICAgICAgICAgICAgIGxhYmVsczogbGFiZWxzIHx8ICgoX2IgPSBkYXRhLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhYmVscykgfHwgW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNvbnN0IHJlbW92ZVRyYWlsaW5nU2xhc2hJZkV4aXN0cyA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyB0aGUgZGV0YWlscyByZXF1aXJlZCB0byBpbml0aWFsaXplIGFuZCBjb25maWd1cmUgdGhlIEFQSSBjbGllbnQuXG4gKi9cbmNsYXNzIEF4aW9zQmFja2VuZENsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhcGlDbGllbnREZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhcGlLZXkgLSBUaGUgQVBJIGtleSBmb3IgY2xpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVXJsIC0gVGhlIGJhc2UgVVJMIGZvciB0aGUgQVBJIGNsaWVudC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcnVudGltZSAtIFRoZSBydW50aW1lIGVudmlyb25tZW50IGlkZW50aWZpZXIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBBUEkga2V5IGlzIG5vdCBwcm92aWRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihhcGlLZXksIGJhc2VVcmwsIHJ1bnRpbWUpIHtcbiAgICAgICAgdGhpcy5ydW50aW1lID0gcnVudGltZSB8fCBcIlwiO1xuICAgICAgICB0aGlzLmFwaUtleSA9IGFwaUtleTtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gcmVtb3ZlVHJhaWxpbmdTbGFzaElmRXhpc3RzKGJhc2VVcmwpO1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gY2xpZW50QXhpb3MuY3JlYXRlQ2xpZW50KGNsaWVudEF4aW9zLmNyZWF0ZUNvbmZpZyh7XG4gICAgICAgICAgICBiYXNlVVJMOiB0aGlzLmJhc2VVcmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgLy8gY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgXCJYLUFQSS1LRVlcIjogYCR7dGhpcy5hcGlLZXl9YCxcbiAgICAgICAgICAgICAgICBcIlgtU09VUkNFXCI6IFwianNfc2RrXCIsXG4gICAgICAgICAgICAgICAgXCJYLVJVTlRJTUVcIjogdGhpcy5ydW50aW1lLFxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKCFhcGlLZXkpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLkFQSV9LRVlfVU5BVkFJTEFCTEUsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkFQSSBrZXkgaXMgbm90IGF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlRoZSBBUEkga2V5IHJlcXVpcmVkIGZvciBhdXRoZW50aWNhdGlvbiBpcyBub3QgcHJvdmlkZWQuIFlvdSBjYW4gZ2V0IHRoZSBBUEkga2V5IGZyb20gdGhlIENvbXBvc2lvIGRhc2hib2FyZC5cIixcbiAgICAgICAgICAgICAgICBwb3NzaWJsZUZpeDogXCJQbGVhc2UgcHJvdmlkZSB0aGUgQVBJIGtleSBpbiB0aGUgY29uc3RydWN0b3JcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFZhbGlkYXRlIGJhc2VVcmxcbiAgICAgICAgaWYgKCFiYXNlVXJsLnN0YXJ0c1dpdGgoXCJodHRwOi8vXCIpICYmICFiYXNlVXJsLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgQ0VHLmdldEN1c3RvbUVycm9yKENPTVBPU0lPX1NES19FUlJPUl9DT0RFUy5DT01NT04uQkFTRV9VUkxfTk9UX1JFQUNIQUJMRSwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGDwn5SXIEJhc2UgVVJMICR7YmFzZVVybH0gaXMgbm90IHZhbGlkYCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJUaGUgY29tcG9zaW8gYmFja2VuZCBVUkwgcHJvdmlkZWQgaXMgbm90IHZhbGlkXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXRpYWxpemVBcGlDbGllbnQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjbGllbnQgSUQgZnJvbSB0aGUgdXNlcidzIGluZm9ybWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjbGllbnQgSUQuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBIVFRQIHJlcXVlc3QgZmFpbHMuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0Q2xpZW50SWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXBpQ2xpZW50LmNsaWVudEF1dGguZ2V0VXNlckluZm8oe1xuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5pbnN0YW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgoX2EgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuY2xpZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuaGFuZGxlQWxsRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBBUEkgY2xpZW50IHdpdGggdGhlIHByb3ZpZGVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplQXBpQ2xpZW50KCkge1xuICAgICAgICB0aGlzLmluc3RhbmNlLnNldENvbmZpZyh7XG4gICAgICAgICAgICBiYXNlVVJMOiByZW1vdmVUcmFpbGluZ1NsYXNoSWZFeGlzdHModGhpcy5iYXNlVXJsKSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgXCJYLUFQSS1LRVlcIjogYCR7dGhpcy5hcGlLZXl9YCxcbiAgICAgICAgICAgICAgICAgICAgXCJYLVNPVVJDRVwiOiBcImpzX3Nka1wiLFxuICAgICAgICAgICAgICAgICAgICBcIlgtUlVOVElNRVwiOiB0aGlzLnJ1bnRpbWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aHJvd09uRXJyb3I6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzZXRBeGlvc0NsaWVudENvbmZpZyh0aGlzLmluc3RhbmNlLmluc3RhbmNlKTtcbiAgICB9XG4gICAgZ2V0QXhpb3NJbnN0YW5jZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuaW5zdGFuY2U7XG4gICAgfVxufVxuXG4vLyBGaWxlIHBhdGggaGVscGVyc1xuY29uc3QgdXNlckRhdGFQYXRoID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gICAgICAgIGNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG4gICAgICAgIHJldHVybiBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCBDT01QT1NJT19ESVIsIFVTRVJfREFUQV9GSUxFX05BTUUpO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5jb25zdCBnZXRVc2VyRGF0YUpzb24gPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBmcy5yZWFkRmlsZVN5bmModXNlckRhdGFQYXRoKCksIFwidXRmOFwiKTtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbn07XG4vLyBBeGlvcyBjb25maWd1cmF0aW9uXG5jb25zdCBzZXRBeGlvc0NsaWVudENvbmZpZyA9IChheGlvc0NsaWVudEluc3RhbmNlKSA9PiB7XG4gICAgYXhpb3NDbGllbnRJbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoKHJlcXVlc3QpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBib2R5ID0gcmVxdWVzdC5kYXRhID8gSlNPTi5zdHJpbmdpZnkocmVxdWVzdC5kYXRhKSA6IFwiXCI7XG4gICAgICAgIC8vIHNldCB4LXJlcXVlc3QtaWQgaGVhZGVyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IGdldFVVSUQoKTtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzW1wieC1yZXF1ZXN0LWlkXCJdID0gcmVxdWVzdElkO1xuICAgICAgICByZXF1ZXN0Lm1ldGFkYXRhID0ge1xuICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoYEFQSSBSZXEgWyR7KF9hID0gcmVxdWVzdC5tZXRob2QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1VwcGVyQ2FzZSgpfV0gJHtyZXF1ZXN0LnVybH0sIHgtcmVxdWVzdC1pZDogJHtyZXF1ZXN0SWR9YCwge1xuICAgICAgICAgICAgLi4uKGJvZHkgJiYgeyBib2R5IH0pLFxuICAgICAgICAgICAgcXVlcnk6IHJlcXVlc3QucGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfSk7XG4gICAgYXhpb3NDbGllbnRJbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKChyZXNwb25zZSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKF9hID0gcmVzcG9uc2UuY29uZmlnLm1ldGhvZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlU2l6ZSA9IE1hdGgucm91bmQoSlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuZGF0YSkubGVuZ3RoIC8gMTAyNCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RTdGFydFRpbWUgPSAoX2IgPSByZXNwb25zZS5jb25maWdcbiAgICAgICAgICAgIC5tZXRhZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXJ0VGltZTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gcmVxdWVzdFN0YXJ0VGltZSA/IERhdGUubm93KCkgLSByZXF1ZXN0U3RhcnRUaW1lIDogMDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBjb25zdCByZXF1ZXN0SWQgPSByZXNwb25zZS5oZWFkZXJzW1wieC1yZXF1ZXN0LWlkXCJdIHx8XG4gICAgICAgICAgICAoKF9jID0gcmVzcG9uc2UuY29uZmlnLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVxdWVzdElkKTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBFcnJvciB3aXRoIG1ldGFkYXRhIHR5cGVcbiAgICAgICAgcmVzcG9uc2VbXCJtZXRhZGF0YVwiXSA9IHtcbiAgICAgICAgICAgIHJlc3BvbnNlVGltZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU2l6ZSxcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBBUEkgUmVzIFske21ldGhvZH1dICR7cmVzcG9uc2UuY29uZmlnLnVybH0gLSAke3N0YXR1c30gLSAke3Jlc3BvbnNlU2l6ZX0gS0IgJHtyZXNwb25zZVRpbWV9bXNgKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbSwgX28sIF9wO1xuICAgICAgICBjb25zdCByZXF1ZXN0U3RhcnRUaW1lID0gKF9iID0gKF9hID0gZXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWV0YWRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RTdGFydFRpbWVJZCA9IChfZCA9IChfYyA9IGVycm9yLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVxdWVzdElkO1xuICAgICAgICBjb25zdCByZXNwb25zZVRpbWUgPSByZXF1ZXN0U3RhcnRUaW1lID8gRGF0ZS5ub3coKSAtIHJlcXVlc3RTdGFydFRpbWUgOiAwO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSAoKF9lID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zdGF0dXMpIHx8IFwiVW5rbm93blwiO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAoKF9nID0gSlNPTi5zdHJpbmdpZnkoKF9mID0gZXJyb3IucmVzcG9uc2UpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5kYXRhKSkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmxlbmd0aCkgfHwgMDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VTaXplID0gTWF0aC5yb3VuZChsZW5ndGggLyAxMDI0KTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gKChfaiA9IChfaCA9IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guaGVhZGVycykgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qW1wieC1yZXF1ZXN0LWlkXCJdKSB8fCByZXF1ZXN0U3RhcnRUaW1lSWQ7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0ge1xuICAgICAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICAgICAgcmVzcG9uc2VTaXplLFxuICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICB9O1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEVycm9yIHdpdGggbWV0YWRhdGEgdHlwZVxuICAgICAgICBlcnJvci5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICBsb2dnZXIuZGVidWcoYEFQSSBFcnJvciBbJHtzdGF0dXN9XSAkeyhfbCA9IChfayA9IGVycm9yLmNvbmZpZykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLm1ldGhvZCkgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnRvVXBwZXJDYXNlKCl9ICR7KF9tID0gZXJyb3IuY29uZmlnKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20udXJsfSAtICR7c3RhdHVzfSAtICR7cmVzcG9uc2VUaW1lfW1zLCB4LXJlcXVlc3QtaWQ6ICR7cmVxdWVzdElkfWAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IChfbyA9IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX28uaGVhZGVycyxcbiAgICAgICAgICAgIGRhdGE6IChfcCA9IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3AuZGF0YSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgcmVzcG9uc2VUaW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbn07XG4vLyBDbGllbnQgY29uZmlndXJhdGlvbiBmdW5jdGlvbnNcbmZ1bmN0aW9uIGdldFNES0NvbmZpZyhiYXNlVXJsLCBhcGlLZXkpIHtcbiAgICBjb25zdCB1c2VyRGF0YSA9IGdldFVzZXJEYXRhSnNvbigpO1xuICAgIGNvbnN0IHsgYXBpX2tleTogYXBpS2V5RnJvbVVzZXJDb25maWcsIGJhc2VfdXJsOiBiYXNlVVJMRnJvbVVzZXJDb25maWcgfSA9IHVzZXJEYXRhO1xuICAgIGNvbnN0IGJhc2VVUkxQYXJzZWQgPSBiYXNlVXJsIHx8XG4gICAgICAgIGdldEVudlZhcmlhYmxlKFwiQ09NUE9TSU9fQkFTRV9VUkxcIikgfHxcbiAgICAgICAgYmFzZVVSTEZyb21Vc2VyQ29uZmlnIHx8XG4gICAgICAgIERFRkFVTFRfQkFTRV9VUkw7XG4gICAgY29uc3QgYXBpS2V5UGFyc2VkID0gYXBpS2V5IHx8IGdldEVudlZhcmlhYmxlKFwiQ09NUE9TSU9fQVBJX0tFWVwiKSB8fCBhcGlLZXlGcm9tVXNlckNvbmZpZyB8fCBcIlwiO1xuICAgIHJldHVybiB7IGJhc2VVUkw6IGJhc2VVUkxQYXJzZWQsIGFwaUtleTogYXBpS2V5UGFyc2VkIH07XG59XG5cbmNvbnN0IGlzTmV3ZXJWZXJzaW9uID0gKHYxLCB2MikgPT4ge1xuICAgIGNvbnN0IHBhcnRzMSA9IHYxLnNwbGl0KFwiLlwiKS5tYXAoTnVtYmVyKTtcbiAgICBjb25zdCBwYXJ0czIgPSB2Mi5zcGxpdChcIi5cIikubWFwKE51bWJlcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgaWYgKHBhcnRzMVtpXSA+IHBhcnRzMltpXSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAocGFydHMxW2ldIDwgcGFydHMyW2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jbGFzcyBDb21wb3NpbyB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENvbXBvc2lvIGNsYXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgQ29tcG9zaW8gU0RLXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuYXBpS2V5XSAtIFRoZSBBUEkga2V5IGZvciBhdXRoZW50aWNhdGluZyB3aXRoIHRoZSBDb21wb3NpbyBiYWNrZW5kLiBDYW4gYWxzbyBiZSBzZXQgbG9jYWxseSBpbiBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NvbmZpZy5iYXNlVXJsXSAtIFRoZSBiYXNlIFVSTCBmb3IgdGhlIENvbXBvc2lvIGJhY2tlbmQuIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byB0aGUgcHJvZHVjdGlvbiBVUkwuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcucnVudGltZV0gLSBUaGUgcnVudGltZSBlbnZpcm9ubWVudCBmb3IgdGhlIFNESy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcuYWxsb3dUcmFjaW5nXSAtIFdoZXRoZXIgdG8gYWxsb3cgdHJhY2luZyBmb3IgdGhlIFNESy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLmZpbGVOYW1lID0gXCJqcy9zcmMvc2RrL2luZGV4LnRzXCI7XG4gICAgICAgIC8vIFBhcnNlIHRoZSBiYXNlIFVSTCBhbmQgQVBJIGtleSwgZmFsbGluZyBiYWNrIHRvIGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBkZWZhdWx0cyBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgY29uc3QgeyBiYXNlVVJMOiBiYXNlVVJMUGFyc2VkLCBhcGlLZXk6IGFwaUtleVBhcnNlZCB9ID0gZ2V0U0RLQ29uZmlnKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5iYXNlVXJsLCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXBpS2V5KTtcbiAgICAgICAgaWYgKElTX0RFVkVMT1BNRU5UX09SX0NJKSB7XG4gICAgICAgICAgICBsb2dnZXIuaW5mbyhgSW5pdGlhbGl6aW5nIENvbXBvc2lvIHcgQVBJIEtleTogW1JFREFDVEVEXSBhbmQgYmFzZVVSTDogJHtiYXNlVVJMUGFyc2VkfWApO1xuICAgICAgICB9XG4gICAgICAgIENvbXBvc2lvU0RLQ29udGV4dC5hcGlLZXkgPSBhcGlLZXlQYXJzZWQ7XG4gICAgICAgIENvbXBvc2lvU0RLQ29udGV4dC5iYXNlVVJMID0gYmFzZVVSTFBhcnNlZDtcbiAgICAgICAgQ29tcG9zaW9TREtDb250ZXh0LmZyYW1ld29ya1J1bnRpbWUgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcucnVudGltZTtcbiAgICAgICAgQ29tcG9zaW9TREtDb250ZXh0LmNvbXBvc2lvVmVyc2lvbiA9IENPTVBPU0lPX1ZFUlNJT047XG4gICAgICAgIENvbXBvc2lvU0RLQ29udGV4dC5hbGxvd1RyYWNpbmcgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYWxsb3dUcmFjaW5nO1xuICAgICAgICAvLyBieSBkZWZhdWx0LCBnZW5lcmF0ZSBhIHNlc3Npb25JZCB1bmxlc3MgYWxsb3dUcmFjaW5nIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGZhbHNlXG4gICAgICAgIENvbXBvc2lvU0RLQ29udGV4dC5zZXNzaW9uSWQgPVxuICAgICAgICAgICAgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hbGxvd1RyYWNpbmcpICE9PSBmYWxzZSA/IGdldFVVSUQoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfSU5JVElBTElaRUQsIHt9KTtcbiAgICAgICAgaWYgKCFhcGlLZXlQYXJzZWQpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLkFQSV9LRVlfVU5BVkFJTEFCTEUsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIvCflJEgQVBJIEtleSBpcyBub3QgcHJvdmlkZWRcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJZb3UgbmVlZCB0byBwcm92aWRlIGl0IGluIHRoZSBjb25zdHJ1Y3RvciBvciBhcyBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZSBDT01QT1NJT19BUElfS0VZXCIsXG4gICAgICAgICAgICAgICAgcG9zc2libGVGaXg6IFwiUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBBUEkgS2V5LiBZb3UgY2FuIGdldCBpdCBmcm9tIGh0dHBzOi8vYXBwLmNvbXBvc2lvLmRldi9zZXR0aW5ncyBPUiBDaGVjayBpZiB5b3UgYXJlIHBhc3NpbmcgaXQgYXMgYW4gb2JqZWN0IGluIHRoZSBjb25zdHJ1Y3RvciBsaWtlIC0geyBhcGlLZXk6ICd5b3VyLWFwaS1rZXknIH1cIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5pbmZvKGBJbml0aWFsaXppbmcgQ29tcG9zaW8gdyBBUEkgS2V5OiBbUkVEQUNURURdIGFuZCBiYXNlVVJMOiAke2Jhc2VVUkxQYXJzZWR9YCk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIEJhY2tlbmRDbGllbnQgd2l0aCB0aGUgcGFyc2VkIEFQSSBrZXkgYW5kIGJhc2UgVVJMLlxuICAgICAgICB0aGlzLmJhY2tlbmRDbGllbnQgPSBuZXcgQXhpb3NCYWNrZW5kQ2xpZW50KGFwaUtleVBhcnNlZCwgYmFzZVVSTFBhcnNlZCwgY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLnJ1bnRpbWUpO1xuICAgICAgICBzZXRBeGlvc0NsaWVudENvbmZpZyh0aGlzLmJhY2tlbmRDbGllbnQuZ2V0QXhpb3NJbnN0YW5jZSgpKTtcbiAgICAgICAgLy8gSW5zdGFudGlhdGUgbW9kZWxzIHdpdGggZGVwZW5kZW5jaWVzIGFzIG5lZWRlZC5cbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBY2NvdW50cyA9IG5ldyBDb25uZWN0ZWRBY2NvdW50cyh0aGlzLmJhY2tlbmRDbGllbnQsIHRoaXMuYmFja2VuZENsaWVudC5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcnMgPSBuZXcgVHJpZ2dlcnModGhpcy5iYWNrZW5kQ2xpZW50LCB0aGlzLmJhY2tlbmRDbGllbnQuaW5zdGFuY2UpO1xuICAgICAgICB0aGlzLmFwcHMgPSBuZXcgQXBwcyh0aGlzLmJhY2tlbmRDbGllbnQsIHRoaXMuYmFja2VuZENsaWVudC5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuYWN0aW9ucyA9IG5ldyBBY3Rpb25zKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5pbnRlZ3JhdGlvbnMgPSBuZXcgSW50ZWdyYXRpb25zKHRoaXMuYmFja2VuZENsaWVudCwgdGhpcy5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5hY3RpdmVUcmlnZ2VycyA9IG5ldyBBY3RpdmVUcmlnZ2Vycyh0aGlzLmJhY2tlbmRDbGllbnQsIHRoaXMuYmFja2VuZENsaWVudC5pbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuY2hlY2tGb3JMYXRlc3RWZXJzaW9uRnJvbU5QTSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgZm9yIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiB0aGUgQ29tcG9zaW8gU0RLIGZyb20gTlBNLlxuICAgICAqIElmIGEgbmV3ZXIgdmVyc2lvbiBpcyBhdmFpbGFibGUsIGl0IGxvZ3MgYSB3YXJuaW5nIHRvIHRoZSBjb25zb2xlLlxuICAgICAqL1xuICAgIGFzeW5jIGNoZWNrRm9yTGF0ZXN0VmVyc2lvbkZyb21OUE0oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlTmFtZSA9IFwiY29tcG9zaW8tY29yZVwiO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFZlcnNpb25Gcm9tUGFja2FnZUpzb24gPSBDT01QT1NJT19WRVJTSU9OO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnLyR7cGFja2FnZU5hbWV9L2xhdGVzdGApO1xuICAgICAgICAgICAgY29uc3QgbGF0ZXN0VmVyc2lvbiA9IHJlc3BvbnNlLmRhdGEudmVyc2lvbjtcbiAgICAgICAgICAgIGlmIChpc05ld2VyVmVyc2lvbihsYXRlc3RWZXJzaW9uLCBjdXJyZW50VmVyc2lvbkZyb21QYWNrYWdlSnNvbikgJiZcbiAgICAgICAgICAgICAgICAhSVNfREVWRUxPUE1FTlRfT1JfQ0kpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuaW5mbyhg8J+agCBVcGdyYWRlIGF2YWlsYWJsZSEgWW91ciBjb21wb3Npby1jb3JlIHZlcnNpb24gKCR7Y3VycmVudFZlcnNpb25Gcm9tUGFja2FnZUpzb259KSBpcyBiZWhpbmQuIExhdGVzdCB2ZXJzaW9uOiAke2xhdGVzdFZlcnNpb259LmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbmQgZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhbiBFbnRpdHkgaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gSUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2lkPSdkZWZhdWx0J10gLSBUaGUgSUQgb2YgdGhlIGVudGl0eSB0byByZXRyaWV2ZS5cbiAgICAgKiBAcmV0dXJucyB7RW50aXR5fSBBbiBpbnN0YW5jZSBvZiB0aGUgRW50aXR5IGNsYXNzLlxuICAgICAqL1xuICAgIGdldEVudGl0eShpZCA9IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZ2V0RW50aXR5XCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGlkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEVudGl0eSh0aGlzLmJhY2tlbmRDbGllbnQsIGlkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0RXhwZWN0ZWRQYXJhbXNGb3JVc2VyKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldEV4cGVjdGVkUGFyYW1zRm9yVXNlclwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBhcHAgfSA9IHBhcmFtcztcbiAgICAgICAgbGV0IHsgaW50ZWdyYXRpb25JZCB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoaW50ZWdyYXRpb25JZCA9PT0gbnVsbCAmJiBhcHAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJvdGggYGludGVncmF0aW9uX2lkYCBhbmQgYGFwcGAgY2Fubm90IGJlIE5vbmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnRlZ3JhdGlvbklkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVncmF0aW9ucyA9IGF3YWl0IHRoaXMuaW50ZWdyYXRpb25zLmxpc3Qoe1xuICAgICAgICAgICAgICAgICAgICBhcHBOYW1lOiBhcHAsXG4gICAgICAgICAgICAgICAgICAgIHNob3dEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5hdXRoU2NoZW1lICYmIGludGVncmF0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbnMuaXRlbXMgPSBpbnRlZ3JhdGlvbnMuaXRlbXMuZmlsdGVyKChpbnRlZ3JhdGlvbikgPT4gaW50ZWdyYXRpb24uYXV0aFNjaGVtZSA9PT0gcGFyYW1zLmF1dGhTY2hlbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkID0gKF9hID0gaW50ZWdyYXRpb25zID09PSBudWxsIHx8IGludGVncmF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZWdyYXRpb25zLml0ZW1zWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaW50ZWdyYXRpb24gPSBpbnRlZ3JhdGlvbklkXG4gICAgICAgICAgICA/IGF3YWl0IHRoaXMuaW50ZWdyYXRpb25zLmdldCh7XG4gICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogaW50ZWdyYXRpb25JZCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGludGVncmF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkSW5wdXRGaWVsZHM6IGludGVncmF0aW9uLmV4cGVjdGVkSW5wdXRGaWVsZHMsXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogaW50ZWdyYXRpb24uaWQsXG4gICAgICAgICAgICAgICAgYXV0aFNjaGVtZTogaW50ZWdyYXRpb24uYXV0aFNjaGVtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwSW5mbyA9IGF3YWl0IHRoaXMuYXBwcy5nZXQoe1xuICAgICAgICAgICAgYXBwS2V5OiBhcHAudG9Mb2NhbGVMb3dlckNhc2UoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHByZWZlcnJlZEF1dGhTY2hlbWUgPSBbXG4gICAgICAgICAgICBcIk9BVVRIMlwiLFxuICAgICAgICAgICAgXCJPQVVUSDFcIixcbiAgICAgICAgICAgIFwiQVBJX0tFWVwiLFxuICAgICAgICAgICAgXCJCQVNJQ1wiLFxuICAgICAgICAgICAgXCJCRUFSRVJfVE9LRU5cIixcbiAgICAgICAgICAgIFwiQkFTSUNfV0lUSF9KV1RcIixcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IHNjaGVtYSA9IHBhcmFtcy5hdXRoU2NoZW1lO1xuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzY2hlbWUgb2YgcHJlZmVycmVkQXV0aFNjaGVtZSkge1xuICAgICAgICAgICAgICAgIGlmICgoX2IgPSBhcHBJbmZvLmF1dGhfc2NoZW1lcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1hcCgoX2F1dGhTY2hlbWUpID0+IF9hdXRoU2NoZW1lLm1vZGUpLmluY2x1ZGVzKHNjaGVtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hID0gc2NoZW1lO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzVGVzdENvbm5lY3RvcnMgPSAoKF9kID0gKF9jID0gYXBwSW5mby50ZXN0Q29ubmVjdG9ycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCkgPiAwO1xuICAgICAgICBjb25zdCBhdXRoU2NoZW1lRmllbGRzID0gKF9mID0gKF9lID0gYXBwSW5mby5hdXRoX3NjaGVtZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5maW5kKChfYXV0aFNjaGVtZSkgPT4gX2F1dGhTY2hlbWUubW9kZSA9PT0gc2NoZW1hKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmZpZWxkcztcbiAgICAgICAgY29uc3QgcmVxdWlyZWRDdXN0b21lckZpZWxkcyA9IChfaCA9IChfZyA9IGF1dGhTY2hlbWVGaWVsZHMgPT09IG51bGwgfHwgYXV0aFNjaGVtZUZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXV0aFNjaGVtZUZpZWxkcy5maWx0ZXIoKGZpZWxkKSA9PiAhZmllbGQuZXhwZWN0ZWRfZnJvbV9jdXN0b21lcikpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5sZW5ndGgpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IDA7XG4gICAgICAgIGNvbnN0IGFyZU5vRmllbGRzUmVxdWlyZWRGb3JJbnRlZ3JhdGlvbiA9IGhhc1Rlc3RDb25uZWN0b3JzIHx8IHJlcXVpcmVkQ3VzdG9tZXJGaWVsZHMgPT09IDA7XG4gICAgICAgIGlmICghYXJlTm9GaWVsZHNSZXF1aXJlZEZvckludGVncmF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRlZmF1bHQgY3JlZGVudGlhbHMgYXZhaWxhYmxlIGZvciB0aGlzIGFwcCwgcGxlYXNlIGNyZWF0ZSBuZXcgaW50ZWdyYXRpb24gYnkgZ29pbmcgdG8gYXBwLmNvbXBvc2lvLmRldiBvciB0aHJvdWdoIENMSSAtIGNvbXBvc2lvIGFkZCAke2FwcEluZm8ua2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9bLTouXS9nLCBcIlwiKTtcbiAgICAgICAgY29uc3QgaGFzUmVsZXZhbnRUZXN0Q29ubmVjdG9ycyA9IHBhcmFtcy5hdXRoU2NoZW1lXG4gICAgICAgICAgICA/ICgoX2sgPSAoX2ogPSBhcHBJbmZvLnRlc3RDb25uZWN0b3JzKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouZmlsdGVyKChjb25uZWN0b3IpID0+IGNvbm5lY3Rvci5hdXRoU2NoZW1lID09PSBwYXJhbXMuYXV0aFNjaGVtZSkpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5sZW5ndGgpID4gMFxuICAgICAgICAgICAgOiAoKF9sID0gYXBwSW5mby50ZXN0Q29ubmVjdG9ycykgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLmxlbmd0aCkgPiAwO1xuICAgICAgICBpZiAoaGFzUmVsZXZhbnRUZXN0Q29ubmVjdG9ycykge1xuICAgICAgICAgICAgaW50ZWdyYXRpb24gPSBhd2FpdCB0aGlzLmludGVncmF0aW9ucy5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGFwcElkOiBhcHBJbmZvLmFwcElkLFxuICAgICAgICAgICAgICAgIG5hbWU6IGBpbnRlZ3JhdGlvbl8ke3RpbWVzdGFtcH1gLFxuICAgICAgICAgICAgICAgIGF1dGhTY2hlbWU6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICBhdXRoQ29uZmlnOiB7fSxcbiAgICAgICAgICAgICAgICB1c2VDb21wb3Npb0F1dGg6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRJbnB1dEZpZWxkczogaW50ZWdyYXRpb24gPT09IG51bGwgfHwgaW50ZWdyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVncmF0aW9uLmV4cGVjdGVkSW5wdXRGaWVsZHMsXG4gICAgICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogaW50ZWdyYXRpb24gPT09IG51bGwgfHwgaW50ZWdyYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVncmF0aW9uLmlkLFxuICAgICAgICAgICAgICAgIGF1dGhTY2hlbWU6IGludGVncmF0aW9uID09PSBudWxsIHx8IGludGVncmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlZ3JhdGlvbi5hdXRoU2NoZW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdXBwb3J0ZWQgYXV0aCBzY2hlbWUgZm91bmQgZm9yIFxcYCR7U3RyaW5nKGFwcCl9XFxgLCBgICtcbiAgICAgICAgICAgICAgICBcIlBsZWFzZSBjcmVhdGUgYW4gaW50ZWdyYXRpb24gYW5kIHVzZSB0aGUgSUQgdG8gXCIgK1xuICAgICAgICAgICAgICAgIFwiZ2V0IHRoZSBleHBlY3RlZCBwYXJhbWV0ZXJzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlZ3JhdGlvbiA9IGF3YWl0IHRoaXMuaW50ZWdyYXRpb25zLmNyZWF0ZSh7XG4gICAgICAgICAgICBhcHBJZDogYXBwSW5mby5hcHBJZCxcbiAgICAgICAgICAgIG5hbWU6IGBpbnRlZ3JhdGlvbl8ke3RpbWVzdGFtcH1gLFxuICAgICAgICAgICAgYXV0aFNjaGVtZTogc2NoZW1hLFxuICAgICAgICAgICAgYXV0aENvbmZpZzoge30sXG4gICAgICAgICAgICB1c2VDb21wb3Npb0F1dGg6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpbnRlZ3JhdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCB3aGlsZSBjcmVhdGluZyB0aGUgaW50ZWdyYXRpb24sIHBsZWFzZSBjcmVhdGUgYW4gaW50ZWdyYXRpb24gbWFudWFsbHkgYW5kIHVzZSBpdHMgSUQgdG8gZ2V0IHRoZSBleHBlY3RlZCBwYXJhbWV0ZXJzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBleHBlY3RlZElucHV0RmllbGRzOiBpbnRlZ3JhdGlvbi5leHBlY3RlZElucHV0RmllbGRzLFxuICAgICAgICAgICAgaW50ZWdyYXRpb25JZDogaW50ZWdyYXRpb24uaWQsXG4gICAgICAgICAgICBhdXRoU2NoZW1lOiBpbnRlZ3JhdGlvbi5hdXRoU2NoZW1lLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuLypcbiAgICBUaGlzIGlzIHRoZSBzY2hlbWEgZm9yIHRoZSByYXcgYWN0aW9uIHRvIGJlIHN0b3JlZCBsb2NhbGx5XG4gICAgQWxzbyByZXR1cm5lZCBieSB0aGUgQVBJXG4qL1xuei56Lm9iamVjdCh7XG4gICAgbmFtZTogei56LnN0cmluZygpLFxuICAgIGRpc3BsYXlfbmFtZTogei56LnN0cmluZygpLFxuICAgIGRlc2NyaXB0aW9uOiB6Lnouc3RyaW5nKCksXG4gICAgYXBwS2V5OiB6Lnouc3RyaW5nKCksXG4gICAgYXBwSWQ6IHouei5zdHJpbmcoKSxcbiAgICBhcHBOYW1lOiB6Lnouc3RyaW5nKCksXG4gICAgbG9nbzogei56LnN0cmluZygpLFxuICAgIGVuYWJsZWQ6IHouei5ib29sZWFuKCksXG4gICAgdGFnczogei56LmFycmF5KHouei5zdHJpbmcoKSksXG4gICAgcGFyYW1ldGVyczogei56Lm9iamVjdCh7XG4gICAgICAgIHR5cGU6IHouei5zdHJpbmcoKSxcbiAgICAgICAgdGl0bGU6IHouei5zdHJpbmcoKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHouei5zdHJpbmcoKSxcbiAgICAgICAgcmVxdWlyZWQ6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLFxuICAgICAgICBwcm9wZXJ0aWVzOiB6LnoucmVjb3JkKHouei5hbnkoKSksXG4gICAgfSksXG4gICAgcmVzcG9uc2U6IHouei5yZWNvcmQoei56LmFueSgpKSxcbiAgICBtZXRhZGF0YTogei56Lm9iamVjdCh7XG4gICAgICAgIG5hbWU6IHouei5zdHJpbmcoKSxcbiAgICAgICAgdG9vbE5hbWU6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIH0pLFxufSk7XG4vKlxuICAgIFRoaXMgaXMgdGhlIHNjaGVtYSBmb3IgdGhlIHBhcmFtcyBvYmplY3QgaW4gdGhlIEV4ZWN1dGVBY3Rpb24gZnVuY3Rpb25cbiovXG5jb25zdCBaRXhlY3V0ZUFjdGlvblBhcmFtcyA9IHouei5vYmplY3Qoe1xuICAgIGFjdGlvbjogei56LnN0cmluZygpLFxuICAgIHBhcmFtczogei56LnJlY29yZCh6LnouYW55KCkpLm9wdGlvbmFsKCksXG4gICAgZW50aXR5SWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIG5sYVRleHQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGNvbm5lY3RlZEFjY291bnRJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgY29uZmlnOiB6LnpcbiAgICAgICAgLm9iamVjdCh7XG4gICAgICAgIGxhYmVsczogei56LmFycmF5KHouei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgWlRvb2xTY2hlbWFGaWx0ZXIgPSB6Lnoub2JqZWN0KHtcbiAgICBhY3Rpb25zOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGFwcHM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgdGFnczogei56LmFycmF5KHouei5zdHJpbmcoKSkub3B0aW9uYWwoKSxcbiAgICB1c2VDYXNlOiB6Lnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB1c2VDYXNlTGltaXQ6IHouei5udW1iZXIoKS5vcHRpb25hbCgpLFxuICAgIGZpbHRlckJ5QXZhaWxhYmxlQXBwczogei56LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgIGludGVncmF0aW9uSWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG5cbmNsYXNzIEFjdGlvblJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuY3VzdG9tQWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuYWN0aW9uTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhY3Rpb25OYW1lIGZvciB0aGlzIGFjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5wdXRQYXJhbXMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaW5wdXRQYXJhbXMgPSB6Lnoub2JqZWN0KHt9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSBvcHRpb25zLmlucHV0UGFyYW1zO1xuICAgICAgICBjb25zdCBhY3Rpb25OYW1lID0gb3B0aW9ucy5hY3Rpb25OYW1lIHx8IGNhbGxiYWNrLm5hbWUgfHwgXCJcIjtcbiAgICAgICAgY29uc3QgcGFyYW1zU2NoZW1hID0gKGF3YWl0IHpvZFRvSnNvblNjaGVtYS56b2RUb0pzb25TY2hlbWEocGFyYW1zLCB7XG4gICAgICAgICAgICBuYW1lOiBcImlucHV0XCIsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgX3BhcmFtcyA9IHBhcmFtc1NjaGVtYS5kZWZpbml0aW9ucy5pbnB1dC5wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBjb21wb3Npb1NjaGVtYSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGFjdGlvbk5hbWUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogb3B0aW9ucy5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogYWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBvcHRpb25zLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHJlcXVpcmVkOiBwYXJhbXNTY2hlbWEuZGVmaW5pdGlvbnMuaW5wdXQucmVxdWlyZWQgfHwgW10sXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogX3BhcmFtcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgdGl0bGU6IFwiUmVzcG9uc2UgZm9yIFwiICsgYWN0aW9uTmFtZSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY3VzdG9tQWN0aW9ucy5zZXQoKChfYSA9IG9wdGlvbnMuYWN0aW9uTmFtZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvTG9jYWxlTG93ZXJDYXNlKCkpIHx8IFwiXCIsIHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBvcHRpb25zLFxuICAgICAgICAgICAgc2NoZW1hOiBjb21wb3Npb1NjaGVtYSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb21wb3Npb1NjaGVtYTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0QWN0aW9ucyh7IGFjdGlvbnMsIH0pIHtcbiAgICAgICAgY29uc3QgYWN0aW9uc0FyciA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgYWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1c3RvbUFjdGlvbnMuaGFzKGxvd2VyQ2FzZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy5jdXN0b21BY3Rpb25zLmdldChsb3dlckNhc2VOYW1lKTtcbiAgICAgICAgICAgICAgICBhY3Rpb25zQXJyLnB1c2goYWN0aW9uLnNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnNBcnI7XG4gICAgfVxuICAgIGFzeW5jIGdldEFsbEFjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY3VzdG9tQWN0aW9ucy52YWx1ZXMoKSkubWFwKChhY3Rpb24pID0+IGFjdGlvbi5zY2hlbWEpO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb29sTmFtZSh7IGFjdGlvbiwgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBDRUcuZ2V0Q3VzdG9tRXJyb3IoQ09NUE9TSU9fU0RLX0VSUk9SX0NPREVTLkNPTU1PTi5JTlZBTElEX1BBUkFNU19QQVNTRUQsIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkFjdGlvbiBuYW1lIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUGxlYXNlIHByb3ZpZGUgYW4gYWN0aW9uIG5hbWUgdG8gZ2V0IGl0cyB0b29sIG5hbWVcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvd2VyQ2FzZU5hbWUgPSBhY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY3VzdG9tQWN0aW9ucy5nZXQobG93ZXJDYXNlTmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXRhZGF0YS50b29sTmFtZTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZUFjdGlvbihuYW1lLCBpbnB1dFBhcmFtcywgbWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgbG93ZXJDYXNlTmFtZSA9IG5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLmN1c3RvbUFjdGlvbnMuaGFzKGxvd2VyQ2FzZU5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGlvbiB3aXRoIG5hbWUgJHtuYW1lfSBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuY3VzdG9tQWN0aW9ucy5nZXQobG93ZXJDYXNlTmFtZSk7XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGlvbiB3aXRoIG5hbWUgJHtuYW1lfSBjb3VsZCBub3QgYmUgcmV0cmlldmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjYWxsYmFjaywgdG9vbE5hbWUgfSA9IGFjdGlvbi5tZXRhZGF0YSB8fCB7fTtcbiAgICAgICAgbGV0IGF1dGhDcmVkZW50aWFscyA9IHt9O1xuICAgICAgICBpZiAodG9vbE5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudGl0eSA9IGF3YWl0IHRoaXMuY2xpZW50LmdldEVudGl0eShtZXRhZGF0YS5lbnRpdHlJZCk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gYXdhaXQgZW50aXR5LmdldENvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgIGFwcDogdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBtZXRhZGF0YS5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiB3aXRoIGFwcCBuYW1lICR7dG9vbE5hbWV9IGFuZCBlbnRpdHlJZCAke21ldGFkYXRhLmVudGl0eUlkfSBub3QgZm91bmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25QYXJhbXMgPSBjb25uZWN0aW9uLmNvbm5lY3Rpb25QYXJhbXM7XG4gICAgICAgICAgICBhdXRoQ3JlZGVudGlhbHMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogY29ubmVjdGlvblBhcmFtcyA9PT0gbnVsbCB8fCBjb25uZWN0aW9uUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uUGFyYW1zLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IGNvbm5lY3Rpb25QYXJhbXMgPT09IG51bGwgfHwgY29ubmVjdGlvblBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29ubmVjdGlvblBhcmFtcy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBiYXNlVXJsOiAoY29ubmVjdGlvblBhcmFtcyA9PT0gbnVsbCB8fCBjb25uZWN0aW9uUGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0aW9uUGFyYW1zLmJhc2VVcmwpIHx8IChjb25uZWN0aW9uUGFyYW1zID09PSBudWxsIHx8IGNvbm5lY3Rpb25QYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb25QYXJhbXMuYmFzZV91cmwpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuQ09NTU9OLklOVkFMSURfUEFSQU1TX1BBU1NFRCwge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiQ2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUGxlYXNlIHByb3ZpZGUgYSB2YWxpZCBjYWxsYmFjayBmdW5jdGlvblwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhlY3V0ZVJlcXVlc3QgPSBhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHJlcyB9ID0gYXdhaXQgYXBpQ2xpZW50LmFjdGlvbnNWMi5leGVjdXRlV2l0aEh0dHBDbGllbnQoe1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQ6IHRoaXMuY2xpZW50LmJhY2tlbmRDbGllbnQuaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IG1ldGFkYXRhID09PSBudWxsIHx8IG1ldGFkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXRhZGF0YS5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IENFRy5oYW5kbGVBbGxFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhd2FpdCBjYWxsYmFjayhpbnB1dFBhcmFtcywgYXV0aENyZWRlbnRpYWxzLCAoZGF0YSkgPT4gZXhlY3V0ZVJlcXVlc3QoZGF0YSkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBDb21wb3NpbyBkaXJlY3RvcnkuXG4gKiBAcGFyYW0gY3JlYXRlRGlySWZOb3RFeGlzdHMgLSBXaGV0aGVyIHRvIGNyZWF0ZSB0aGUgZGlyZWN0b3J5IGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKiBAcmV0dXJucyBUaGUgcGF0aCB0byB0aGUgQ29tcG9zaW8gZGlyZWN0b3J5LlxuICovXG5jb25zdCBnZXRDb21wb3Npb0RpciA9IChjcmVhdGVEaXJJZk5vdEV4aXN0cyA9IGZhbHNlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gICAgICAgIGNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgICAgIGNvbnN0IGNvbXBvc2lvRGlyID0gcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgQ09NUE9TSU9fRElSKTtcbiAgICAgICAgaWYgKGNyZWF0ZURpcklmTm90RXhpc3RzICYmICFmcy5leGlzdHNTeW5jKGNvbXBvc2lvRGlyKSkge1xuICAgICAgICAgICAgZnMubWtkaXJTeW5jKGNvbXBvc2lvRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9zaW9EaXI7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcbi8qKlxuICogR2V0cyB0aGUgQ29tcG9zaW8gdGVtcG9yYXJ5IGZpbGVzIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSBjcmVhdGVEaXJJZk5vdEV4aXN0cyAtIFdoZXRoZXIgdG8gY3JlYXRlIHRoZSBkaXJlY3RvcnkgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAqIEByZXR1cm5zIFRoZSBwYXRoIHRvIHRoZSBDb21wb3NpbyB0ZW1wb3JhcnkgZmlsZXMgZGlyZWN0b3J5LlxuICovXG5jb25zdCBnZXRDb21wb3Npb1RlbXBGaWxlc0RpciA9IChjcmVhdGVEaXJJZk5vdEV4aXN0cyA9IGZhbHNlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3Qgb3MgPSByZXF1aXJlKFwib3NcIik7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG4gICAgICAgIGNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgICAgIGNvbnN0IGNvbXBvc2lvRmlsZXNEaXIgPSBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCBDT01QT1NJT19ESVIsIFRFTVBfRklMRVNfRElSRUNUT1JZX05BTUUpO1xuICAgICAgICBpZiAoY3JlYXRlRGlySWZOb3RFeGlzdHMgJiYgIWZzLmV4aXN0c1N5bmMoY29tcG9zaW9GaWxlc0RpcikpIHtcbiAgICAgICAgICAgIGZzLm1rZGlyU3luYyhjb21wb3Npb0ZpbGVzRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9zaW9GaWxlc0RpcjtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnJvcikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuLyoqXG4gKiBTYXZlcyBhIGZpbGUgdG8gdGhlIENvbXBvc2lvIGRpcmVjdG9yeS5cbiAqIEBwYXJhbSBmaWxlIC0gVGhlIG5hbWUgb2YgdGhlIGZpbGUgdG8gc2F2ZS5cbiAqIEBwYXJhbSBjb250ZW50IC0gVGhlIGNvbnRlbnQgb2YgdGhlIGZpbGUgdG8gc2F2ZS4gU2hvdWxkIGJlIGEgc3RyaW5nLlxuICogQHBhcmFtIGlzVGVtcEZpbGUgLSBXaGV0aGVyIHRoZSBmaWxlIGlzIGEgdGVtcG9yYXJ5IGZpbGUuXG4gKiBAcmV0dXJucyBUaGUgcGF0aCB0byB0aGUgc2F2ZWQgZmlsZS5cbiAqL1xuY29uc3Qgc2F2ZUZpbGUgPSAoZmlsZSwgY29udGVudCwgaXNUZW1wRmlsZSA9IGZhbHNlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgICAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICAgICAgY29uc3QgY29tcG9zaW9GaWxlc0RpciA9IGlzVGVtcEZpbGVcbiAgICAgICAgICAgID8gZ2V0Q29tcG9zaW9UZW1wRmlsZXNEaXIodHJ1ZSlcbiAgICAgICAgICAgIDogZ2V0Q29tcG9zaW9EaXIodHJ1ZSk7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKGNvbXBvc2lvRmlsZXNEaXIsIHBhdGguYmFzZW5hbWUoZmlsZSkpO1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVQYXRoLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGNvbnRlbnQsIFwidXRmOFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsZVBhdGg7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuY29uc3QgcmVhZEZpbGVDb250ZW50ID0gYXN5bmMgKHBhdGgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlU3luYyhwYXRoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICAgICAgICBtaW1lVHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgcmVhZGluZyBmaWxlIGF0ICR7cGF0aH06ICR7ZXJyb3J9YCk7XG4gICAgfVxufTtcbmNvbnN0IHJlYWRGaWxlQ29udGVudEZyb21VUkwgPSBhc3luYyAocGF0aCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KHBhdGgsIHtcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBcImFycmF5YnVmZmVyXCIsXG4gICAgfSk7XG4gICAgY29uc3QgY29udGVudCA9IEJ1ZmZlci5mcm9tKHJlc3BvbnNlLmRhdGEpO1xuICAgIGNvbnN0IG1pbWVUeXBlID0gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQudG9TdHJpbmcoXCJiYXNlNjRcIiksXG4gICAgICAgIG1pbWVUeXBlLFxuICAgIH07XG59O1xuY29uc3QgdXBsb2FkRmlsZVRvUzMgPSBhc3luYyAoY29udGVudCwgYWN0aW9uTmFtZSwgYXBwTmFtZSwgbWltZVR5cGUsIGNsaWVudCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBtaW1lVHlwZS5zcGxpdChcIi9cIilbMV0gfHwgXCJiaW5cIjtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaUNsaWVudC5hY3Rpb25zVjIuY3JlYXRlRmlsZVVwbG9hZFVybCh7XG4gICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgICBhcHA6IGFwcE5hbWUsXG4gICAgICAgICAgICBmaWxlbmFtZTogYCR7YWN0aW9uTmFtZX1fJHtEYXRlLm5vdygpfS4ke2V4dGVuc2lvbn1gLFxuICAgICAgICAgICAgbWltZXR5cGU6IG1pbWVUeXBlLFxuICAgICAgICAgICAgbWQ1OiBjcnlwdG9cbiAgICAgICAgICAgICAgICAuY3JlYXRlSGFzaChcIm1kNVwiKVxuICAgICAgICAgICAgICAgIC51cGRhdGUoQnVmZmVyLmZyb20oY29udGVudCwgXCJiYXNlNjRcIikpXG4gICAgICAgICAgICAgICAgLmRpZ2VzdChcImhleFwiKSxcbiAgICAgICAgfSxcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgICAgZmlsZVR5cGU6IFwicmVxdWVzdFwiLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgIGNvbnN0IHNpZ25lZFVSTCA9IGRhdGEudXJsO1xuICAgIGNvbnN0IHMza2V5ID0gZGF0YS5rZXk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oY29udGVudCwgXCJiYXNlNjRcIik7XG4gICAgICAgIGF3YWl0IGF4aW9zLnB1dChzaWduZWRVUkwsIGJ1ZmZlciwge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IG1pbWVUeXBlLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IGU7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIGF4aW9zLkF4aW9zRXJyb3IgJiYgKChfYSA9IGVycm9yLnJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdHVzKSA9PT0gNDAzKSB7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmVkVVJMO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgdXBsb2FkaW5nIGZpbGUgdG8gUzM6ICR7ZXJyb3J9YCk7XG4gICAgfVxuICAgIHJldHVybiBzM2tleTtcbn07XG5jb25zdCBnZXRGaWxlRGF0YUFmdGVyVXBsb2FkaW5nVG9TMyA9IGFzeW5jIChwYXRoLCBhY3Rpb25OYW1lLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBpc1VSTCA9IHBhdGguc3RhcnRzV2l0aChcImh0dHBcIik7XG4gICAgY29uc3QgZmlsZURhdGEgPSBpc1VSTFxuICAgICAgICA/IGF3YWl0IHJlYWRGaWxlQ29udGVudEZyb21VUkwocGF0aClcbiAgICAgICAgOiBhd2FpdCByZWFkRmlsZUNvbnRlbnQocGF0aCk7XG4gICAgY29uc3QgczNrZXkgPSBhd2FpdCB1cGxvYWRGaWxlVG9TMyhmaWxlRGF0YS5jb250ZW50LCBhY3Rpb25OYW1lLCBhY3Rpb25OYW1lLCBmaWxlRGF0YS5taW1lVHlwZSwgY2xpZW50KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBwYXRoTW9kdWxlLmJhc2VuYW1lKHBhdGgpIHx8IGAke2FjdGlvbk5hbWV9XyR7RGF0ZS5ub3coKX1gLFxuICAgICAgICBtaW1ldHlwZTogZmlsZURhdGEubWltZVR5cGUsXG4gICAgICAgIHMza2V5OiBzM2tleSxcbiAgICB9O1xufTtcbmNvbnN0IGRvd25sb2FkRmlsZUZyb21TMyA9IGFzeW5jICh7IGFjdGlvbk5hbWUsIHMzVXJsLCBtaW1lVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KHMzVXJsLCB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogXCJhcnJheWJ1ZmZlclwiLFxuICAgIH0pO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG1pbWVUeXBlLnNwbGl0KFwiL1wiKVsxXSB8fCBcInR4dFwiO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7YWN0aW9uTmFtZX1fJHtEYXRlLm5vdygpfS4ke2V4dGVuc2lvbn1gO1xuICAgIGNvbnN0IGZpbGVQYXRoID0gc2F2ZUZpbGUoZmlsZU5hbWUsIHJlc3BvbnNlLmRhdGEsIHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGZpbGVOYW1lLFxuICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIHMzS2V5OiBzM1VybCxcbiAgICAgICAgZmlsZVBhdGg6IGZpbGVQYXRoLFxuICAgIH07XG59O1xuXG5jb25zdCBGSUxFX1NVRkZJWCA9IFwiX3NjaGVtYV9wYXJzZWRfZmlsZVwiO1xuY29uc3QgY29udmVydEZpbGVTY2hlbWFQcm9wZXJ0eSA9IChrZXksIHByb3BlcnR5KSA9PiB7XG4gICAgaWYgKCFwcm9wZXJ0eS5maWxlX3VwbG9hZGFibGUpIHtcbiAgICAgICAgcmV0dXJuIHByb3BlcnR5O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlOYW1lOiBgJHtrZXl9JHtGSUxFX1NVRkZJWH1gLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBkZXNjcmlwdGlvbjogcHJvcGVydHkuZGVzY3JpcHRpb24sXG4gICAgfTtcbn07XG5jb25zdCBwcm9jZXNzRmlsZVVwbG9hZCA9IGFzeW5jIChwYXJhbXMsIGFjdGlvbk5hbWUsIGNsaWVudCkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4ucGFyYW1zIH07XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVzdWx0KSkge1xuICAgICAgICBpZiAoIWtleS5lbmRzV2l0aChGSUxFX1NVRkZJWCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxLZXkgPSBrZXkucmVwbGFjZShGSUxFX1NVRkZJWCwgXCJcIik7XG4gICAgICAgIGNvbnN0IGZpbGVEYXRhID0gYXdhaXQgZ2V0RmlsZURhdGFBZnRlclVwbG9hZGluZ1RvUzModmFsdWUsIGFjdGlvbk5hbWUsIGNsaWVudCk7XG4gICAgICAgIHJlc3VsdFtvcmlnaW5hbEtleV0gPSBmaWxlRGF0YTtcbiAgICAgICAgZGVsZXRlIHJlc3VsdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IEZJTEVfSU5QVVRfUFJPQ0VTU09SID0gYXN5bmMgKHsgcGFyYW1zLCBhY3Rpb25OYW1lLCBjbGllbnQsIH0pID0+IHtcbiAgICByZXR1cm4gcHJvY2Vzc0ZpbGVVcGxvYWQocGFyYW1zLCBhY3Rpb25OYW1lLCBjbGllbnQpO1xufTtcbmNvbnN0IEZJTEVfRE9XTkxPQURBQkxFX1BST0NFU1NPUiA9IGFzeW5jICh7IGFjdGlvbk5hbWUsIHRvb2xSZXNwb25zZSwgfSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodG9vbFJlc3BvbnNlKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModG9vbFJlc3BvbnNlLmRhdGEpKSB7XG4gICAgICAgIGNvbnN0IGZpbGVEYXRhID0gdmFsdWU7XG4gICAgICAgIGlmICghKGZpbGVEYXRhID09PSBudWxsIHx8IGZpbGVEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWxlRGF0YS5zM3VybCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZG93bmxvYWRlZEZpbGUgPSBhd2FpdCBkb3dubG9hZEZpbGVGcm9tUzMoe1xuICAgICAgICAgICAgYWN0aW9uTmFtZSxcbiAgICAgICAgICAgIHMzVXJsOiBmaWxlRGF0YS5zM3VybCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBmaWxlRGF0YS5taW1ldHlwZSB8fCBcImFwcGxpY2F0aW9uL3R4dFwiLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVzdWx0LmRhdGFba2V5XSA9IHtcbiAgICAgICAgICAgIHVyaTogZG93bmxvYWRlZEZpbGUuZmlsZVBhdGgsXG4gICAgICAgICAgICBzM3VybDogZmlsZURhdGEuczN1cmwsXG4gICAgICAgICAgICBtaW1lVHlwZTogZG93bmxvYWRlZEZpbGUubWltZVR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgRklMRV9TQ0hFTUFfUFJPQ0VTU09SID0gKHsgdG9vbFNjaGVtYSB9KSA9PiB7XG4gICAgY29uc3QgeyBwcm9wZXJ0aWVzLCByZXF1aXJlZDogcmVxdWlyZWRQcm9wcyA9IFtdIH0gPSB0b29sU2NoZW1hLnBhcmFtZXRlcnM7XG4gICAgY29uc3QgbmV3UHJvcGVydGllcyA9IHsgLi4ucHJvcGVydGllcyB9O1xuICAgIGNvbnN0IG5ld1JlcXVpcmVkID0gWy4uLnJlcXVpcmVkUHJvcHNdO1xuICAgIGZvciAoY29uc3QgW2tleSwgcHJvcGVydHldIG9mIE9iamVjdC5lbnRyaWVzKG5ld1Byb3BlcnRpZXMpKSB7XG4gICAgICAgIGlmICghcHJvcGVydHkuZmlsZV91cGxvYWRhYmxlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwga2V5TmFtZSwgZGVzY3JpcHRpb24gfSA9IGNvbnZlcnRGaWxlU2NoZW1hUHJvcGVydHkoa2V5LCBwcm9wZXJ0eSk7XG4gICAgICAgIG5ld1Byb3BlcnRpZXNba2V5TmFtZV0gPSB7XG4gICAgICAgICAgICB0aXRsZTogcHJvcGVydHkudGl0bGUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXF1aXJlZFByb3BzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIG5ld1JlcXVpcmVkW25ld1JlcXVpcmVkLmluZGV4T2Yoa2V5KV0gPSBrZXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBuZXdQcm9wZXJ0aWVzW2tleV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRvb2xTY2hlbWEsXG4gICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIC4uLnRvb2xTY2hlbWEucGFyYW1ldGVycyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IG5ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICByZXF1aXJlZDogbmV3UmVxdWlyZWQsXG4gICAgICAgIH0sXG4gICAgfTtcbn07XG5cbmNsYXNzIENvbXBvc2lvVG9vbFNldCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb21wb3Npb1Rvb2xTZXRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBjb25maWcuYXBpS2V5IC0gQVBJIGtleSBmb3IgYXV0aGVudGljYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBjb25maWcuYmFzZVVybCAtIEJhc2UgVVJMIGZvciBBUEkgcmVxdWVzdHNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSBjb25maWcucnVudGltZSAtIFJ1bnRpbWUgZW52aXJvbm1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnLmVudGl0eUlkIC0gRW50aXR5IElEIGZvciBvcGVyYXRpb25zXG4gICAgICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBjb25maWcuY29ubmVjdGVkQWNjb3VudElkcyAtIE1hcCBvZiBhcHAgbmFtZXMgdG8gdGhlaXIgY29ubmVjdGVkIGFjY291bnQgSURzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjb25maWcuYWxsb3dUcmFjaW5nIC0gV2hldGhlciB0byBhbGxvdyB0cmFjaW5nIGZvciB0aGUgU0RLXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBhcGlLZXksIGJhc2VVcmwsIHJ1bnRpbWUsIGVudGl0eUlkLCBjb25uZWN0ZWRBY2NvdW50SWRzLCBhbGxvd1RyYWNpbmcsIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmVudGl0eUlkID0gXCJkZWZhdWx0XCI7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWNjb3VudElkcyA9IHt9O1xuICAgICAgICB0aGlzLmludGVybmFsUHJvY2Vzc29ycyA9IHtcbiAgICAgICAgICAgIHByZTogW0ZJTEVfSU5QVVRfUFJPQ0VTU09SXSxcbiAgICAgICAgICAgIHBvc3Q6IFtGSUxFX0RPV05MT0FEQUJMRV9QUk9DRVNTT1JdLFxuICAgICAgICAgICAgc2NoZW1hOiBbRklMRV9TQ0hFTUFfUFJPQ0VTU09SXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51c2VyRGVmaW5lZFByb2Nlc3NvcnMgPSB7fTtcbiAgICAgICAgY29uc3QgY2xpZW50QXBpS2V5ID0gYXBpS2V5IHx8XG4gICAgICAgICAgICBnZXRFbnZWYXJpYWJsZShcIkNPTVBPU0lPX0FQSV9LRVlcIikgfHxcbiAgICAgICAgICAgIGdldFVzZXJEYXRhSnNvbigpLmFwaV9rZXk7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gY2xpZW50QXBpS2V5O1xuICAgICAgICB0aGlzLmNsaWVudCA9IG5ldyBDb21wb3Npbyh7XG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgYmFzZVVybDogYmFzZVVybCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBydW50aW1lOiBydW50aW1lLFxuICAgICAgICAgICAgYWxsb3dUcmFjaW5nOiBhbGxvd1RyYWNpbmcgfHwgZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJ1bnRpbWUgPSBydW50aW1lIHx8IG51bGw7XG4gICAgICAgIHRoaXMuYmFja2VuZENsaWVudCA9IHRoaXMuY2xpZW50LmJhY2tlbmRDbGllbnQ7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWNjb3VudHMgPSB0aGlzLmNsaWVudC5jb25uZWN0ZWRBY2NvdW50cztcbiAgICAgICAgdGhpcy5hcHBzID0gdGhpcy5jbGllbnQuYXBwcztcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdGhpcy5jbGllbnQuYWN0aW9ucztcbiAgICAgICAgdGhpcy50cmlnZ2VycyA9IHRoaXMuY2xpZW50LnRyaWdnZXJzO1xuICAgICAgICB0aGlzLmludGVncmF0aW9ucyA9IHRoaXMuY2xpZW50LmludGVncmF0aW9ucztcbiAgICAgICAgdGhpcy5hY3RpdmVUcmlnZ2VycyA9IHRoaXMuY2xpZW50LmFjdGl2ZVRyaWdnZXJzO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEFjY291bnRJZHMgPSBjb25uZWN0ZWRBY2NvdW50SWRzIHx8IHt9O1xuICAgICAgICB0aGlzLnVzZXJBY3Rpb25SZWdpc3RyeSA9IG5ldyBBY3Rpb25SZWdpc3RyeSh0aGlzLmNsaWVudCk7XG4gICAgICAgIGlmIChlbnRpdHlJZCAmJiBjb25uZWN0ZWRBY2NvdW50SWRzKSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybihcIldoZW4gYm90aCBlbnRpdHkgYW5kIGNvbm5lY3RlZEFjY291bnRJZHMgYXJlIHByb3ZpZGVkLCBwcmVmZXJlbmNlIHdpbGwgYmUgZ2l2ZW4gdG8gY29ubmVjdGVkQWNjb3VudElkc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGVkQWNjb3VudElkcykge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0ZWRBY2NvdW50SWRzID0gY29ubmVjdGVkQWNjb3VudElkcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50aXR5SWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW50aXR5SWQgPSBlbnRpdHlJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRBY3Rpb25zU2NoZW1hKGZpbHRlcnMgPSB7fSwgX2VudGl0eUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFRvb2xzU2NoZW1hKHtcbiAgICAgICAgICAgIGFjdGlvbnM6IGZpbHRlcnMuYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgfSwgX2VudGl0eUlkKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9vbHNTY2hlbWEoZmlsdGVycywgX2VudGl0eUlkLCBfaW50ZWdyYXRpb25JZCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBwYXJzZWRGaWx0ZXJzID0gWlRvb2xTY2hlbWFGaWx0ZXIucGFyc2UoZmlsdGVycyk7XG4gICAgICAgIGxldCBhY3Rpb25zID0gcGFyc2VkRmlsdGVycy5hY3Rpb25zO1xuICAgICAgICBpZiAoX2ludGVncmF0aW9uSWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVncmF0aW9uID0gYXdhaXQgdGhpcy5pbnRlZ3JhdGlvbnMuZ2V0KHtcbiAgICAgICAgICAgICAgICBpbnRlZ3JhdGlvbklkOiBfaW50ZWdyYXRpb25JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGludGVncmF0aW9uID09PSBudWxsIHx8IGludGVncmF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlZ3JhdGlvbi5saW1pdGVkQWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmICghYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zID0gWy4uLmludGVncmF0aW9uLmxpbWl0ZWRBY3Rpb25zXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0ZWRBY3Rpb25zVXBwZXJjYXNlID0gaW50ZWdyYXRpb24ubGltaXRlZEFjdGlvbnMubWFwKChhY3Rpb24pID0+IGFjdGlvbi50b1VwcGVyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuZmlsdGVyKChhY3Rpb24pID0+IGxpbWl0ZWRBY3Rpb25zVXBwZXJjYXNlLmluY2x1ZGVzKGFjdGlvbi50b1VwcGVyQ2FzZSgpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcEFjdGlvbnMgPSBhd2FpdCB0aGlzLmNsaWVudC5hY3Rpb25zLmxpc3Qoe1xuICAgICAgICAgICAgYXBwczogKF9hID0gcGFyc2VkRmlsdGVycy5hcHBzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbihcIixcIiksXG4gICAgICAgICAgICB0YWdzOiAoX2IgPSBwYXJzZWRGaWx0ZXJzLnRhZ3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgIHVzZUNhc2U6IHBhcnNlZEZpbHRlcnMudXNlQ2FzZSxcbiAgICAgICAgICAgIGFjdGlvbnM6IGFjdGlvbnMgPT09IG51bGwgfHwgYWN0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aW9ucy5qb2luKFwiLFwiKSxcbiAgICAgICAgICAgIHVzZWNhc2VMaW1pdDogcGFyc2VkRmlsdGVycy51c2VDYXNlTGltaXQsXG4gICAgICAgICAgICBmaWx0ZXJCeUF2YWlsYWJsZUFwcHM6IHBhcnNlZEZpbHRlcnMuZmlsdGVyQnlBdmFpbGFibGVBcHBzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY3VzdG9tQWN0aW9ucyA9IGF3YWl0IHRoaXMudXNlckFjdGlvblJlZ2lzdHJ5LmdldEFsbEFjdGlvbnMoKTtcbiAgICAgICAgY29uc3QgdG9vbHNXaXRoQ3VzdG9tQWN0aW9ucyA9IGN1c3RvbUFjdGlvbnMuZmlsdGVyKChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmFtZTogYWN0aW9uTmFtZSB9ID0gYWN0aW9uIHx8IHt9O1xuICAgICAgICAgICAgcmV0dXJuICgoIWZpbHRlcnMuYWN0aW9ucyB8fFxuICAgICAgICAgICAgICAgIGZpbHRlcnMuYWN0aW9ucy5zb21lKChuYW1lKSA9PiBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IChhY3Rpb25OYW1lID09PSBudWxsIHx8IGFjdGlvbk5hbWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdGlvbk5hbWUudG9Mb3dlckNhc2UoKSkpKSAmJlxuICAgICAgICAgICAgICAgICghZmlsdGVycy50YWdzIHx8XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcnMudGFncy5zb21lKCh0YWcpID0+IHRhZy50b0xvd2VyQ2FzZSgpID09PSBcImN1c3RvbVwiKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9vbHNBY3Rpb25zID0gW1xuICAgICAgICAgICAgLi4uKChhcHBBY3Rpb25zID09PSBudWxsIHx8IGFwcEFjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFwcEFjdGlvbnMuaXRlbXMpIHx8IFtdKSxcbiAgICAgICAgICAgIC4uLnRvb2xzV2l0aEN1c3RvbUFjdGlvbnMsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGFsbFNjaGVtYVByb2Nlc3NvciA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuaW50ZXJuYWxQcm9jZXNzb3JzLnNjaGVtYSxcbiAgICAgICAgICAgIC4uLih0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5zY2hlbWFcbiAgICAgICAgICAgICAgICA/IFt0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5zY2hlbWFdXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZFRvb2xzID0gW107XG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciB0aGUgdG9vbHMgYW5kIHByb2Nlc3MgdGhlbVxuICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbHNBY3Rpb25zKSB7XG4gICAgICAgICAgICBsZXQgc2NoZW1hID0gdG9vbDtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHNjaGVtYSB3aXRoIGFsbCB0aGUgcHJvY2Vzc29yc1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9jZXNzb3Igb2YgYWxsU2NoZW1hUHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hID0gYXdhaXQgcHJvY2Vzc29yKHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uTmFtZTogc2NoZW1hID09PSBudWxsIHx8IHNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZW1hLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xTY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NlZFRvb2xzLnB1c2goc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkVG9vbHM7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUFjdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVzZXJBY3Rpb25SZWdpc3RyeS5jcmVhdGVBY3Rpb24ob3B0aW9ucyk7XG4gICAgfVxuICAgIGlzQ3VzdG9tQWN0aW9uKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy51c2VyQWN0aW9uUmVnaXN0cnlcbiAgICAgICAgICAgIC5nZXRBY3Rpb25zKHsgYWN0aW9uczogW2FjdGlvbl0gfSlcbiAgICAgICAgICAgIC50aGVuKChhY3Rpb25zKSA9PiBhY3Rpb25zLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBhc3luYyBnZXRFbnRpdHkoZW50aXR5SWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmdldEVudGl0eShlbnRpdHlJZCk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGVBY3Rpb24oZnVuY3Rpb25QYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGFjdGlvbiwgcGFyYW1zOiBpbnB1dFBhcmFtcyA9IHt9LCBlbnRpdHlJZCA9IHRoaXMuZW50aXR5SWQsIG5sYVRleHQgPSBcIlwiLCBjb25uZWN0ZWRBY2NvdW50SWQsIH0gPSBaRXhlY3V0ZUFjdGlvblBhcmFtcy5wYXJzZSh7XG4gICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uUGFyYW1zLmFjdGlvbk5hbWUgfHwgZnVuY3Rpb25QYXJhbXMuYWN0aW9uLFxuICAgICAgICAgICAgcGFyYW1zOiBmdW5jdGlvblBhcmFtcy5wYXJhbXMsXG4gICAgICAgICAgICBlbnRpdHlJZDogZnVuY3Rpb25QYXJhbXMuZW50aXR5SWQsXG4gICAgICAgICAgICBubGFUZXh0OiBmdW5jdGlvblBhcmFtcy5ubGFUZXh0LFxuICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBmdW5jdGlvblBhcmFtcy5jb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWVudGl0eUlkICYmICFjb25uZWN0ZWRBY2NvdW50SWQpIHtcbiAgICAgICAgICAgIHRocm93IENFRy5nZXRDdXN0b21FcnJvcihDT01QT1NJT19TREtfRVJST1JfQ09ERVMuU0RLLk5PX0NPTk5FQ1RFRF9BQ0NPVU5UX0ZPVU5ELCB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYE5vIGVudGl0eUlkIG9yIGNvbm5lY3RlZEFjY291bnRJZCBwcm92aWRlZGAsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBQbGVhc2UgcHJvdmlkZSBlaXRoZXIgZW50aXR5SWQgb3IgY29ubmVjdGVkQWNjb3VudElkYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbXMgPSBpbnB1dFBhcmFtcyB8fCB7fTtcbiAgICAgICAgY29uc3QgYWxsSW5wdXRQcm9jZXNzb3IgPSBbXG4gICAgICAgICAgICAuLi50aGlzLmludGVybmFsUHJvY2Vzc29ycy5wcmUsXG4gICAgICAgICAgICAuLi4odGhpcy51c2VyRGVmaW5lZFByb2Nlc3NvcnMucHJlXG4gICAgICAgICAgICAgICAgPyBbdGhpcy51c2VyRGVmaW5lZFByb2Nlc3NvcnMucHJlXVxuICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBhbGxJbnB1dFByb2Nlc3Nvcikge1xuICAgICAgICAgICAgcGFyYW1zID0gYXdhaXQgcHJvY2Vzc29yKHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICBhY3Rpb25OYW1lOiBhY3Rpb24sXG4gICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudC5iYWNrZW5kQ2xpZW50Lmluc3RhbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3VzdG9tIGFjdGlvbnMgYXJlIGFsd2F5cyBleGVjdXRlZCBpbiB0aGUgaG9zdC9sb2NhbCBlbnZpcm9ubWVudCBmb3IgSlMgU0RLXG4gICAgICAgIGlmIChhd2FpdCB0aGlzLmlzQ3VzdG9tQWN0aW9uKGFjdGlvbikpIHtcbiAgICAgICAgICAgIGxldCBhY2NvdW50SWQgPSBjb25uZWN0ZWRBY2NvdW50SWQ7XG4gICAgICAgICAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gYXdhaXQgdGhpcy51c2VyQWN0aW9uUmVnaXN0cnkuZ2V0VG9vbE5hbWUoeyBhY3Rpb24gfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY29ubmVjdGVkQWNjb3VudHMgPSBhd2FpdCB0aGlzLmNsaWVudC5jb25uZWN0ZWRBY2NvdW50cy5saXN0KHtcbiAgICAgICAgICAgICAgICAgICAgYXBwTmFtZXM6IHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICB1c2VyX3V1aWQ6IGVudGl0eUlkLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiQUNUSVZFXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3dBY3RpdmVPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFjY291bnRJZCA9IChfYSA9IGNvbm5lY3RlZEFjY291bnRzID09PSBudWxsIHx8IGNvbm5lY3RlZEFjY291bnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25uZWN0ZWRBY2NvdW50cy5pdGVtc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWxsb3dzIHRoZSB1c2VyIHRvIHVzZSBjdXN0b20gYWN0aW9ucyBhbmQgdG9vbHMgd2l0aG91dCBhIGNvbm5lY3RlZCBhY2NvdW50XG4gICAgICAgICAgICBpZiAoIWFjY291bnRJZCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiTm8gY29ubmVjdGVkIGFjY291bnQgZm91bmQgZm9yIHRoZSB1c2VyLiBJZiB5b3VyIGN1c3RvbSBhY3Rpb24gcmVxdWlyZXMgYSBjb25uZWN0ZWQgYWNjb3VudCwgcGxlYXNlIGRvdWJsZSBjaGVjayBpZiB5b3UgaGF2ZSBhY3RpdmUgYWNjb3VudHMgY29ubmVjdGVkIHRvIGl0LlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJBY3Rpb25SZWdpc3RyeS5leGVjdXRlQWN0aW9uKGFjdGlvbiwgcGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgZW50aXR5SWQ6IGVudGl0eUlkLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogYWNjb3VudElkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuY2xpZW50LmdldEVudGl0eShlbnRpdHlJZCkuZXhlY3V0ZSh7XG4gICAgICAgICAgICBhY3Rpb25OYW1lOiBhY3Rpb24sXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICAgIHRleHQ6IG5sYVRleHQsXG4gICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IGNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NSZXNwb25zZShkYXRhLCB7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGVudGl0eUlkOiBlbnRpdHlJZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHByb2Nlc3NSZXNwb25zZShkYXRhLCBtZXRhKSB7XG4gICAgICAgIGNvbnN0IGFsbE91dHB1dFByb2Nlc3NvciA9IFtcbiAgICAgICAgICAgIC4uLnRoaXMuaW50ZXJuYWxQcm9jZXNzb3JzLnBvc3QsXG4gICAgICAgICAgICAuLi4odGhpcy51c2VyRGVmaW5lZFByb2Nlc3NvcnMucG9zdFxuICAgICAgICAgICAgICAgID8gW3RoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnBvc3RdXG4gICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgIF07XG4gICAgICAgIC8vIERpcnR5IHdheSB0byBhdm9pZCBjb3B5XG4gICAgICAgIGxldCBkYXRhVG9SZXR1cm4gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICAgICAgZm9yIChjb25zdCBwcm9jZXNzb3Igb2YgYWxsT3V0cHV0UHJvY2Vzc29yKSB7XG4gICAgICAgICAgICBkYXRhVG9SZXR1cm4gPSBhd2FpdCBwcm9jZXNzb3Ioe1xuICAgICAgICAgICAgICAgIGFjdGlvbk5hbWU6IG1ldGEuYWN0aW9uLFxuICAgICAgICAgICAgICAgIHRvb2xSZXNwb25zZTogZGF0YVRvUmV0dXJuLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFUb1JldHVybjtcbiAgICB9XG4gICAgYXN5bmMgYWRkU2NoZW1hUHJvY2Vzc29yKHByb2Nlc3Nvcikge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3NvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5zY2hlbWEgPSBwcm9jZXNzb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb2Nlc3NvciB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyBhZGRQcmVQcm9jZXNzb3IocHJvY2Vzc29yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2Vzc29yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnByZSA9IHByb2Nlc3NvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHJvY2Vzc29yIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFzeW5jIGFkZFBvc3RQcm9jZXNzb3IocHJvY2Vzc29yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2Vzc29yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRQcm9jZXNzb3JzLnBvc3QgPSBwcm9jZXNzb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByb2Nlc3NvciB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVQcmVQcm9jZXNzb3IoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5wcmU7XG4gICAgfVxuICAgIGFzeW5jIHJlbW92ZVBvc3RQcm9jZXNzb3IoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5wb3N0O1xuICAgIH1cbiAgICBhc3luYyByZW1vdmVTY2hlbWFQcm9jZXNzb3IoKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVzZXJEZWZpbmVkUHJvY2Vzc29ycy5zY2hlbWE7XG4gICAgfVxufVxuXG5jb25zdCBDT01QT1NJT19CQVNFX1VSTCA9IFwiaHR0cHM6Ly9iYWNrZW5kLmNvbXBvc2lvLmRldlwiO1xuXG4vKipcbiAqIENsb3VkZmxhcmVUb29sU2V0IHByb3ZpZGVzIGludGVncmF0aW9uIHdpdGggQ2xvdWRmbGFyZSBXb3JrZXJzIEFJXG4gKiBmb3IgZXhlY3V0aW5nIEFJIHRvb2wgY2FsbHMgYW5kIGhhbmRsaW5nIHJlc3BvbnNlc1xuICovXG5jbGFzcyBDbG91ZGZsYXJlVG9vbFNldCBleHRlbmRzIENvbXBvc2lvVG9vbFNldCB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBhIG5ldyBDbG91ZGZsYXJlVG9vbFNldCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIG9wdGlvbnMgaW5jbHVkaW5nIEFQSSBrZXksIGJhc2UgVVJMLCBlbnRpdHkgSUQgYW5kIHdvcmtzcGFjZSBjb25maWdcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgIGJhc2VVcmw6IGNvbmZpZy5iYXNlVXJsIHx8IENPTVBPU0lPX0JBU0VfVVJMLFxuICAgICAgICAgICAgcnVudGltZTogbnVsbCxcbiAgICAgICAgICAgIGVudGl0eUlkOiBjb25maWcuZW50aXR5SWQgfHwgQ2xvdWRmbGFyZVRvb2xTZXQuREVGQVVMVF9FTlRJVFlfSUQsXG4gICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWRzOiBjb25maWcuY29ubmVjdGVkQWNjb3VudElkcyxcbiAgICAgICAgICAgIGFsbG93VHJhY2luZzogY29uZmlnLmFsbG93VHJhY2luZyB8fCBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9mcmFtZXdvcmtzL2Nsb3VkZmxhcmUudHNcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmUgYXZhaWxhYmxlIHRvb2xzIGJhc2VkIG9uIHByb3ZpZGVkIGZpbHRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXJzIE9wdGlvbmFsIGZpbHRlcnMgZm9yIGFjdGlvbnMsIGFwcHMsIHRhZ3MgYW5kIHVzZSBjYXNlc1xuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIEFJIHRleHQgZ2VuZXJhdGlvbiB0b29sc1xuICAgICAqL1xuICAgIGFzeW5jIGdldFRvb2xzKGZpbHRlcnMpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUb29sc1wiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogZmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSBhd2FpdCB0aGlzLmdldFRvb2xzU2NoZW1hKGZpbHRlcnMpO1xuICAgICAgICByZXR1cm4gKGFjdGlvbnMubWFwKChhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIC8vIEZvcm1hdCB0aGUgYWN0aW9uIHNjaGVtYSBmb3IgQ2xvdWRmbGFyZSBXb3JrZXJzIEFJXG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRTY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogYWN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGFjdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBhY3Rpb24ucGFyYW1ldGVycyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0b29sID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogZm9ybWF0dGVkU2NoZW1hLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0b29sO1xuICAgICAgICB9KSB8fCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBzaW5nbGUgdG9vbCBjYWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9vbCBUaGUgdG9vbCB0byBleGVjdXRlIHdpdGggbmFtZSBhbmQgYXJndW1lbnRzXG4gICAgICogQHBhcmFtIGVudGl0eUlkIE9wdGlvbmFsIGVudGl0eSBJRCB0byBleGVjdXRlIHRoZSB0b29sIGZvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHN0cmluZ2lmaWVkIHRvb2wgZXhlY3V0aW9uIHJlc3VsdFxuICAgICAqL1xuICAgIGFzeW5jIGV4ZWN1dGVUb29sQ2FsbCh0b29sLCBlbnRpdHlJZCA9IG51bGwpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXhlY3V0ZVRvb2xDYWxsXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IHRvb2wsIGVudGl0eUlkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b29sU2NoZW1hID0gYXdhaXQgdGhpcy5nZXRUb29sc1NjaGVtYSh7XG4gICAgICAgICAgICBhY3Rpb25zOiBbdG9vbC5uYW1lXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFwcE5hbWUgPSAoX2IgPSAoX2EgPSB0b29sU2NoZW1hWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwTmFtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnRJZCA9IGFwcE5hbWUgJiYgKChfYyA9IHRoaXMuY29ubmVjdGVkQWNjb3VudElkcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW2FwcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGF3YWl0IHRoaXMuZXhlY3V0ZUFjdGlvbih7XG4gICAgICAgICAgICBhY3Rpb246IHRvb2wubmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogdHlwZW9mIHRvb2wuYXJndW1lbnRzID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBKU09OLnBhcnNlKHRvb2wuYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIDogdG9vbC5hcmd1bWVudHMsXG4gICAgICAgICAgICBlbnRpdHlJZDogZW50aXR5SWQgfHwgdGhpcy5lbnRpdHlJZCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0b29sIGNhbGxzIGZyb20gQUkgdGV4dCBnZW5lcmF0aW9uIG91dHB1dFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlc3VsdCBUaGUgQUkgdGV4dCBnZW5lcmF0aW9uIG91dHB1dCBjb250YWluaW5nIHRvb2wgY2FsbHNcbiAgICAgKiBAcGFyYW0gZW50aXR5SWQgT3B0aW9uYWwgZW50aXR5IElEIHRvIGV4ZWN1dGUgdGhlIHRvb2xzIGZvclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGFycmF5IG9mIHRvb2wgZXhlY3V0aW9uIHJlc3VsdHNcbiAgICAgKi9cbiAgICBhc3luYyBoYW5kbGVUb29sQ2FsbChyZXN1bHQsIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImhhbmRsZVRvb2xDYWxsXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IHJlc3VsdCwgZW50aXR5SWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgaWYgKFwidG9vbF9jYWxsc1wiIGluIHJlc3VsdCAmJiBBcnJheS5pc0FycmF5KHJlc3VsdC50b29sX2NhbGxzKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sX2NhbGwgb2YgcmVzdWx0LnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbF9jYWxsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKGF3YWl0IHRoaXMuZXhlY3V0ZVRvb2xDYWxsKHRvb2xfY2FsbCwgZW50aXR5SWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfVxufVxuLy8gQ2xhc3MgY29uc3RhbnRzXG5DbG91ZGZsYXJlVG9vbFNldC5GUkFNRVdPUktfTkFNRSA9IFwiY2xvdWRmbGFyZVwiO1xuQ2xvdWRmbGFyZVRvb2xTZXQuREVGQVVMVF9FTlRJVFlfSUQgPSBcImRlZmF1bHRcIjtcblxuY2xhc3MgTGFuZ2NoYWluVG9vbFNldCBleHRlbmRzIENvbXBvc2lvVG9vbFNldCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYXBpS2V5OiBjb25maWcuYXBpS2V5IHx8IG51bGwsXG4gICAgICAgICAgICBiYXNlVXJsOiBjb25maWcuYmFzZVVybCB8fCBDT01QT1NJT19CQVNFX1VSTCxcbiAgICAgICAgICAgIHJ1bnRpbWU6IChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcucnVudGltZSkgfHwgTGFuZ2NoYWluVG9vbFNldC5GUkFNRVdPUktfTkFNRSxcbiAgICAgICAgICAgIGVudGl0eUlkOiBjb25maWcuZW50aXR5SWQgfHwgTGFuZ2NoYWluVG9vbFNldC5ERUZBVUxUX0VOVElUWV9JRCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZHM6IGNvbmZpZy5jb25uZWN0ZWRBY2NvdW50SWRzLFxuICAgICAgICAgICAgYWxsb3dUcmFjaW5nOiBjb25maWcuYWxsb3dUcmFjaW5nIHx8IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IFwianMvc3JjL2ZyYW1ld29ya3MvbGFuZ2NoYWluLnRzXCI7XG4gICAgfVxuICAgIF93cmFwVG9vbChzY2hlbWEsIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IHNjaGVtYVtcIm5hbWVcIl07XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gc2NoZW1hW1wiZGVzY3JpcHRpb25cIl07XG4gICAgICAgIGNvbnN0IGFwcE5hbWUgPSAoX2EgPSBzY2hlbWFbXCJhcHBOYW1lXCJdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZnVuYyA9IGFzeW5jICguLi5rd2FyZ3MpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnRJZCA9IGFwcE5hbWUgJiYgKChfYSA9IHRoaXMuY29ubmVjdGVkQWNjb3VudElkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2FwcE5hbWVdKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhd2FpdCB0aGlzLmV4ZWN1dGVBY3Rpb24oe1xuICAgICAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGt3YXJnc1swXSxcbiAgICAgICAgICAgICAgICBlbnRpdHlJZDogZW50aXR5SWQgfHwgdGhpcy5lbnRpdHlJZCxcbiAgICAgICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IGNvbm5lY3RlZEFjY291bnRJZCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IGpzb25TY2hlbWFUb01vZGVsKHNjaGVtYVtcInBhcmFtZXRlcnNcIl0pO1xuICAgICAgICAvLyBAVE9ETzogQWRkIGVzY3JpaXB0aW9uIGFuIG90aGVyIHN0dWZmIGhlcmVcbiAgICAgICAgcmV0dXJuIG5ldyB0b29scy5EeW5hbWljU3RydWN0dXJlZFRvb2woe1xuICAgICAgICAgICAgbmFtZTogYWN0aW9uLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBzY2hlbWE6IHBhcmFtZXRlcnMsXG4gICAgICAgICAgICBmdW5jOiBmdW5jLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0VG9vbHMoZmlsdGVycyA9IHt9LCBlbnRpdHlJZCA9IG51bGwpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUb29sc1wiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBmaWx0ZXJzLCBlbnRpdHlJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9vbHMgPSBhd2FpdCB0aGlzLmdldFRvb2xzU2NoZW1hKGZpbHRlcnMsIGVudGl0eUlkLCBmaWx0ZXJzLmludGVncmF0aW9uSWQpO1xuICAgICAgICByZXR1cm4gdG9vbHMubWFwKCh0b29sKSA9PiB0aGlzLl93cmFwVG9vbCh0b29sLCBlbnRpdHlJZCB8fCB0aGlzLmVudGl0eUlkKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDb21wb3NpbyB0b29sc2V0IGZvciBMYW5nY2hhaW4gZnJhbWV3b3JrLlxuICpcbiAqL1xuTGFuZ2NoYWluVG9vbFNldC5GUkFNRVdPUktfTkFNRSA9IFwibGFuZ2NoYWluXCI7XG5MYW5nY2hhaW5Ub29sU2V0LkRFRkFVTFRfRU5USVRZX0lEID0gXCJkZWZhdWx0XCI7XG5cbmNsYXNzIExhbmdHcmFwaFRvb2xTZXQgZXh0ZW5kcyBMYW5nY2hhaW5Ub29sU2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBhcGlLZXk6IGNvbmZpZy5hcGlLZXkgfHwgbnVsbCxcbiAgICAgICAgICAgIGJhc2VVcmw6IGNvbmZpZy5iYXNlVXJsIHx8IENPTVBPU0lPX0JBU0VfVVJMLFxuICAgICAgICAgICAgZW50aXR5SWQ6IGNvbmZpZy5lbnRpdHlJZCB8fCBMYW5nR3JhcGhUb29sU2V0LkRFRkFVTFRfRU5USVRZX0lELFxuICAgICAgICAgICAgcnVudGltZTogTGFuZ0dyYXBoVG9vbFNldC5GUkFNRVdPUktfTkFNRSxcbiAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZHM6IGNvbmZpZy5jb25uZWN0ZWRBY2NvdW50SWRzLFxuICAgICAgICAgICAgYWxsb3dUcmFjaW5nOiBjb25maWcuYWxsb3dUcmFjaW5nIHx8IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIENvbXBvc2lvIHRvb2xzZXQgZm9yIExhbmdncmFwaCBmcmFtZXdvcmsuXG4gKlxuICovXG5MYW5nR3JhcGhUb29sU2V0LkZSQU1FV09SS19OQU1FID0gXCJsYW5nR3JhcGhcIjtcbkxhbmdHcmFwaFRvb2xTZXQuREVGQVVMVF9FTlRJVFlfSUQgPSBcImRlZmF1bHRcIjtcblxuY2xhc3MgT3BlbkFJVG9vbFNldCBleHRlbmRzIENvbXBvc2lvVG9vbFNldCB7XG4gICAgLyoqXG4gICAgICogQ29tcG9zaW8gdG9vbHNldCBmb3IgT3BlbkFJIGZyYW1ld29yay5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYXBpS2V5OiBjb25maWcuYXBpS2V5IHx8IG51bGwsXG4gICAgICAgICAgICBiYXNlVXJsOiBjb25maWcuYmFzZVVybCB8fCBDT01QT1NJT19CQVNFX1VSTCxcbiAgICAgICAgICAgIHJ1bnRpbWU6IE9wZW5BSVRvb2xTZXQuRlJBTUVXT1JLX05BTUUsXG4gICAgICAgICAgICBlbnRpdHlJZDogY29uZmlnLmVudGl0eUlkIHx8IE9wZW5BSVRvb2xTZXQuREVGQVVMVF9FTlRJVFlfSUQsXG4gICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWRzOiBjb25maWcuY29ubmVjdGVkQWNjb3VudElkcyxcbiAgICAgICAgICAgIGFsbG93VHJhY2luZzogY29uZmlnLmFsbG93VHJhY2luZyB8fCBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9mcmFtZXdvcmtzL29wZW5haS50c1wiO1xuICAgIH1cbiAgICBhc3luYyBnZXRUb29scyhmaWx0ZXJzLCBlbnRpdHlJZCkge1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImdldFRvb2xzXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiBmaWx0ZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWFpbkFjdGlvbnMgPSBhd2FpdCB0aGlzLmdldFRvb2xzU2NoZW1hKGZpbHRlcnMsIGVudGl0eUlkLCBmaWx0ZXJzLmludGVncmF0aW9uSWQpO1xuICAgICAgICByZXR1cm4gKG1haW5BY3Rpb25zLm1hcCgoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRTY2hlbWEgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogYWN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGFjdGlvbi5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBhY3Rpb24ucGFyYW1ldGVycyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0b29sID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogZm9ybWF0dGVkU2NoZW1hLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0b29sO1xuICAgICAgICB9KSB8fCBbXSk7XG4gICAgfVxuICAgIGFzeW5jIGV4ZWN1dGVUb29sQ2FsbCh0b29sLCBlbnRpdHlJZCA9IG51bGwpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiZXhlY3V0ZVRvb2xDYWxsXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IHRvb2wsIGVudGl0eUlkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b29sU2NoZW1hID0gYXdhaXQgdGhpcy5nZXRUb29sc1NjaGVtYSh7XG4gICAgICAgICAgICBhY3Rpb25zOiBbdG9vbC5mdW5jdGlvbi5uYW1lXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFwcE5hbWUgPSAoX2IgPSAoX2EgPSB0b29sU2NoZW1hWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwTmFtZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RlZEFjY291bnRJZCA9IGFwcE5hbWUgJiYgKChfYyA9IHRoaXMuY29ubmVjdGVkQWNjb3VudElkcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW2FwcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGF3YWl0IHRoaXMuZXhlY3V0ZUFjdGlvbih7XG4gICAgICAgICAgICBhY3Rpb246IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogSlNPTi5wYXJzZSh0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cyksXG4gICAgICAgICAgICBlbnRpdHlJZDogZW50aXR5SWQgfHwgdGhpcy5lbnRpdHlJZCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEFjY291bnRJZDogY29ubmVjdGVkQWNjb3VudElkLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZVRvb2xDYWxsKGNoYXRDb21wbGV0aW9uLCBlbnRpdHlJZCA9IG51bGwpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJoYW5kbGVUb29sQ2FsbFwiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBjaGF0Q29tcGxldGlvbiwgZW50aXR5SWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG91dHB1dHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIGNoYXRDb21wbGV0aW9uLmNob2ljZXMpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLm1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICAgIG91dHB1dHMucHVzaChhd2FpdCB0aGlzLmV4ZWN1dGVUb29sQ2FsbChtZXNzYWdlLm1lc3NhZ2UudG9vbF9jYWxsc1swXSwgZW50aXR5SWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlQXNzaXN0YW50TWVzc2FnZShydW4sIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBURUxFTUVUUllfTE9HR0VSLm1hbnVhbFRlbGVtZXRyeShURUxFTUVUUllfRVZFTlRTLlNES19NRVRIT0RfSU5WT0tFRCwge1xuICAgICAgICAgICAgbWV0aG9kOiBcImhhbmRsZUFzc2lzdGFudE1lc3NhZ2VcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgcnVuLCBlbnRpdHlJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG9vbF9jYWxscyA9ICgoX2IgPSAoX2EgPSBydW4ucmVxdWlyZWRfYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3VibWl0X3Rvb2xfb3V0cHV0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvb2xfY2FsbHMpIHx8IFtdO1xuICAgICAgICBjb25zdCB0b29sX291dHB1dHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0b29sX2NhbGxzLm1hcChhc3luYyAodG9vbF9jYWxsKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoYEV4ZWN1dGluZyB0b29sIGNhbGwgd2l0aCBJRDogJHt0b29sX2NhbGwuZnVuY3Rpb24ubmFtZX0gYW5kIHBhcmFtZXRlcnM6ICR7SlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyl9YCk7XG4gICAgICAgICAgICBjb25zdCB0b29sX3Jlc3BvbnNlID0gYXdhaXQgdGhpcy5leGVjdXRlVG9vbENhbGwodG9vbF9jYWxsLCBlbnRpdHlJZCB8fCB0aGlzLmVudGl0eUlkKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgUmVjZWl2ZWQgdG9vbCByZXNwb25zZTogJHtKU09OLnN0cmluZ2lmeSh0b29sX3Jlc3BvbnNlKX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkOiB0b29sX2NhbGwuaWQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBKU09OLnN0cmluZ2lmeSh0b29sX3Jlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHRvb2xfb3V0cHV0cztcbiAgICB9XG4gICAgYXN5bmMgKndhaXRBbmRIYW5kbGVBc3Npc3RhbnRTdHJlYW1Ub29sQ2FsbHMoY2xpZW50LCBydW5TdHJlYW0sIHRocmVhZCwgZW50aXR5SWQgPSBudWxsKSB7XG4gICAgICAgIFRFTEVNRVRSWV9MT0dHRVIubWFudWFsVGVsZW1ldHJ5KFRFTEVNRVRSWV9FVkVOVFMuU0RLX01FVEhPRF9JTlZPS0VELCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwid2FpdEFuZEhhbmRsZUFzc2lzdGFudFN0cmVhbVRvb2xDYWxsc1wiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogeyBjbGllbnQsIHJ1blN0cmVhbSwgdGhyZWFkLCBlbnRpdHlJZCB9LFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJ1bklkID0gbnVsbDtcbiAgICAgICAgLy8gU3RhcnQgcHJvY2Vzc2luZyB0aGUgcnVuU3RyZWFtIGV2ZW50c1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIHJ1blN0cmVhbSkge1xuICAgICAgICAgICAgeWllbGQgZXZlbnQ7IC8vIFlpZWxkIGVhY2ggZXZlbnQgZnJvbSB0aGUgc3RyZWFtIGFzIGl0IGFycml2ZXNcbiAgICAgICAgICAgIGlmIChldmVudC5ldmVudCA9PT0gXCJ0aHJlYWQucnVuLmNyZWF0ZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICAgICAgcnVuSWQgPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVuSWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgJ3JlcXVpcmVzX2FjdGlvbicgZXZlbnRcbiAgICAgICAgICAgIGlmIChldmVudC5ldmVudCA9PT0gXCJ0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbE91dHB1dHMgPSBhd2FpdCB0aGlzLmhhbmRsZUFzc2lzdGFudE1lc3NhZ2UoZXZlbnQuZGF0YSwgZW50aXR5SWQpO1xuICAgICAgICAgICAgICAgIC8vIFN1Ym1pdCB0aGUgdG9vbCBvdXRwdXRzXG4gICAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLnN1Ym1pdFRvb2xPdXRwdXRzKHRocmVhZC5pZCwgcnVuSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9vdXRwdXRzOiB0b29sT3V0cHV0cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJyZWFrIGlmIHRoZSBydW4gc3RhdHVzIGJlY29tZXMgaW5hY3RpdmVcbiAgICAgICAgICAgIGlmIChbXG4gICAgICAgICAgICAgICAgXCJ0aHJlYWQucnVuLmNvbXBsZXRlZFwiLFxuICAgICAgICAgICAgICAgIFwidGhyZWFkLnJ1bi5mYWlsZWRcIixcbiAgICAgICAgICAgICAgICBcInRocmVhZC5ydW4uY2FuY2VsbGVkXCIsXG4gICAgICAgICAgICAgICAgXCJ0aHJlYWQucnVuLmV4cGlyZWRcIixcbiAgICAgICAgICAgIF0uaW5jbHVkZXMoZXZlbnQuZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydW5JZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcnVuIElEIGZvdW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBhbnkgZmluYWwgYWN0aW9ucyBhZnRlciB0aGUgc3RyZWFtIGVuZHNcbiAgICAgICAgbGV0IGZpbmFsUnVuID0gYXdhaXQgY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLnJldHJpZXZlKHRocmVhZC5pZCwgcnVuSWQpO1xuICAgICAgICB3aGlsZSAoW1wicXVldWVkXCIsIFwiaW5fcHJvZ3Jlc3NcIiwgXCJyZXF1aXJlc19hY3Rpb25cIl0uaW5jbHVkZXMoZmluYWxSdW4uc3RhdHVzKSkge1xuICAgICAgICAgICAgaWYgKGZpbmFsUnVuLnN0YXR1cyA9PT0gXCJyZXF1aXJlc19hY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xPdXRwdXRzID0gYXdhaXQgdGhpcy5oYW5kbGVBc3Npc3RhbnRNZXNzYWdlKGZpbmFsUnVuLCBlbnRpdHlJZCk7XG4gICAgICAgICAgICAgICAgLy8gU3VibWl0IHRvb2wgb3V0cHV0c1xuICAgICAgICAgICAgICAgIGZpbmFsUnVuID0gYXdhaXQgY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLnN1Ym1pdFRvb2xPdXRwdXRzKHRocmVhZC5pZCwgcnVuSWQsIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9vdXRwdXRzOiB0b29sT3V0cHV0cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcnVuIHN0YXR1c1xuICAgICAgICAgICAgICAgIGZpbmFsUnVuID0gYXdhaXQgY2xpZW50LmJldGEudGhyZWFkcy5ydW5zLnJldHJpZXZlKHRocmVhZC5pZCwgcnVuSWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpOyAvLyBXYWl0IGJlZm9yZSByZWNoZWNraW5nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgd2FpdEFuZEhhbmRsZUFzc2lzdGFudFRvb2xDYWxscyhjbGllbnQsIHJ1biwgdGhyZWFkLCBlbnRpdHlJZCA9IG51bGwpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJ3YWl0QW5kSGFuZGxlQXNzaXN0YW50VG9vbENhbGxzXCIsXG4gICAgICAgICAgICBmaWxlOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB7IGNsaWVudCwgcnVuLCB0aHJlYWQsIGVudGl0eUlkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoW1wicXVldWVkXCIsIFwiaW5fcHJvZ3Jlc3NcIiwgXCJyZXF1aXJlc19hY3Rpb25cIl0uaW5jbHVkZXMocnVuLnN0YXR1cykpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ3VycmVudCBydW4gc3RhdHVzOiAke3J1bi5zdGF0dXN9YCk7XG4gICAgICAgICAgICBjb25zdCB0b29sX291dHB1dHMgPSBhd2FpdCB0aGlzLmhhbmRsZUFzc2lzdGFudE1lc3NhZ2UocnVuLCBlbnRpdHlJZCB8fCB0aGlzLmVudGl0eUlkKTtcbiAgICAgICAgICAgIGlmIChydW4uc3RhdHVzID09PSBcInJlcXVpcmVzX2FjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKGBTdWJtaXR0aW5nIHRvb2wgb3V0cHV0cyBmb3IgcnVuIElEOiAke3J1bi5pZH0gaW4gdGhyZWFkIElEOiAke3RocmVhZC5pZH1gKTtcbiAgICAgICAgICAgICAgICBydW4gPSBhd2FpdCBjbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMuc3VibWl0VG9vbE91dHB1dHModGhyZWFkLmlkLCBydW4uaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbF9vdXRwdXRzOiB0b29sX291dHB1dHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBydW4gPSBhd2FpdCBjbGllbnQuYmV0YS50aHJlYWRzLnJ1bnMucmV0cmlldmUodGhyZWFkLmlkLCBydW4uaWQpO1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW47XG4gICAgfVxufVxuT3BlbkFJVG9vbFNldC5GUkFNRVdPUktfTkFNRSA9IFwib3BlbmFpXCI7XG5PcGVuQUlUb29sU2V0LkRFRkFVTFRfRU5USVRZX0lEID0gXCJkZWZhdWx0XCI7XG5cbmNvbnN0IFpFeGVjdXRlVG9vbENhbGxQYXJhbXMgPSB6Lnoub2JqZWN0KHtcbiAgICBhY3Rpb25zOiB6LnouYXJyYXkoei56LnN0cmluZygpKS5vcHRpb25hbCgpLFxuICAgIGFwcHM6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgcGFyYW1zOiB6LnoucmVjb3JkKHouei5hbnkoKSkub3B0aW9uYWwoKSxcbiAgICBlbnRpdHlJZDogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdXNlQ2FzZTogei56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgdXNlY2FzZUxpbWl0OiB6LnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICBjb25uZWN0ZWRBY2NvdW50SWQ6IHouei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIHRhZ3M6IHouei5hcnJheSh6Lnouc3RyaW5nKCkpLm9wdGlvbmFsKCksXG4gICAgZmlsdGVyQnlBdmFpbGFibGVBcHBzOiB6LnouYm9vbGVhbigpLm9wdGlvbmFsKCkuZGVmYXVsdChmYWxzZSksXG59KTtcbmNsYXNzIFZlcmNlbEFJVG9vbFNldCBleHRlbmRzIENvbXBvc2lvVG9vbFNldCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgYXBpS2V5OiBjb25maWcuYXBpS2V5IHx8IG51bGwsXG4gICAgICAgICAgICBiYXNlVXJsOiBjb25maWcuYmFzZVVybCB8fCBudWxsLFxuICAgICAgICAgICAgcnVudGltZTogXCJ2ZXJjZWwtYWlcIixcbiAgICAgICAgICAgIGVudGl0eUlkOiBjb25maWcuZW50aXR5SWQgfHwgXCJkZWZhdWx0XCIsXG4gICAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50SWRzOiBjb25maWcuY29ubmVjdGVkQWNjb3VudElkcyxcbiAgICAgICAgICAgIGFsbG93VHJhY2luZzogY29uZmlnLmFsbG93VHJhY2luZyB8fCBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBcImpzL3NyYy9mcmFtZXdvcmtzL3ZlcmNlbC50c1wiO1xuICAgIH1cbiAgICBnZW5lcmF0ZVZlcmNlbFRvb2woc2NoZW1hLCBlbnRpdHlJZCA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGFpLnRvb2woe1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdGhlIHR5cGUgYXJlIEpTT05TY2hlbVY3LiBJbnRlcm5hbGx5IGl0J3MgcmVzb2x2ZWRcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGFpLmpzb25TY2hlbWEoc2NoZW1hLnBhcmFtZXRlcnMpLFxuICAgICAgICAgICAgZXhlY3V0ZTogYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVUb29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHNjaGVtYS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04uc3RyaW5naWZ5KHBhcmFtcyksXG4gICAgICAgICAgICAgICAgfSwgZW50aXR5SWQgfHwgdGhpcy5lbnRpdHlJZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2hhbmdlIHRoaXMgaW1wbGVtZW50YXRpb25cbiAgICBhc3luYyBnZXRUb29scyhmaWx0ZXJzLCBlbnRpdHlJZCA9IG51bGwpIHtcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUb29sc1wiLFxuICAgICAgICAgICAgZmlsZTogdGhpcy5maWxlTmFtZSxcbiAgICAgICAgICAgIHBhcmFtczogZmlsdGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgYXBwcywgdGFncywgdXNlQ2FzZSwgdXNlY2FzZUxpbWl0LCBmaWx0ZXJCeUF2YWlsYWJsZUFwcHMsIGFjdGlvbnMsIH0gPSBaRXhlY3V0ZVRvb2xDYWxsUGFyYW1zLnBhcnNlKGZpbHRlcnMpO1xuICAgICAgICBjb25zdCBhY3Rpb25zTGlzdCA9IGF3YWl0IHRoaXMuZ2V0VG9vbHNTY2hlbWEoe1xuICAgICAgICAgICAgYXBwcyxcbiAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICB0YWdzLFxuICAgICAgICAgICAgdXNlQ2FzZSxcbiAgICAgICAgICAgIHVzZUNhc2VMaW1pdDogdXNlY2FzZUxpbWl0LFxuICAgICAgICAgICAgZmlsdGVyQnlBdmFpbGFibGVBcHBzLFxuICAgICAgICB9LCBlbnRpdHlJZCwgZmlsdGVycy5pbnRlZ3JhdGlvbklkKTtcbiAgICAgICAgY29uc3QgdG9vbHMgPSB7fTtcbiAgICAgICAgYWN0aW9uc0xpc3QuZm9yRWFjaCgoYWN0aW9uU2NoZW1hKSA9PiB7XG4gICAgICAgICAgICB0b29sc1thY3Rpb25TY2hlbWEubmFtZV0gPSB0aGlzLmdlbmVyYXRlVmVyY2VsVG9vbChhY3Rpb25TY2hlbWEsIGVudGl0eUlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0b29scztcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZVRvb2xDYWxsKHRvb2wsIGVudGl0eUlkID0gbnVsbCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgVEVMRU1FVFJZX0xPR0dFUi5tYW51YWxUZWxlbWV0cnkoVEVMRU1FVFJZX0VWRU5UUy5TREtfTUVUSE9EX0lOVk9LRUQsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJleGVjdXRlVG9vbENhbGxcIixcbiAgICAgICAgICAgIGZpbGU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHsgdG9vbCwgZW50aXR5SWQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRvb2xTY2hlbWEgPSBhd2FpdCB0aGlzLmdldFRvb2xzU2NoZW1hKHtcbiAgICAgICAgICAgIGFjdGlvbnM6IFt0b29sLm5hbWVdLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXBwTmFtZSA9IChfYiA9IChfYSA9IHRvb2xTY2hlbWFbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBOYW1lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgY29ubmVjdGVkQWNjb3VudElkID0gYXBwTmFtZSAmJiAoKF9jID0gdGhpcy5jb25uZWN0ZWRBY2NvdW50SWRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbYXBwTmFtZV0pO1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXdhaXQgdGhpcy5leGVjdXRlQWN0aW9uKHtcbiAgICAgICAgICAgIGFjdGlvbjogdG9vbC5uYW1lLFxuICAgICAgICAgICAgcGFyYW1zOiB0eXBlb2YgdG9vbC5hcmd1bWVudHMgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IEpTT04ucGFyc2UodG9vbC5hcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgOiB0b29sLmFyZ3VtZW50cyxcbiAgICAgICAgICAgIGVudGl0eUlkOiBlbnRpdHlJZCB8fCB0aGlzLmVudGl0eUlkLFxuICAgICAgICAgICAgY29ubmVjdGVkQWNjb3VudElkOiBjb25uZWN0ZWRBY2NvdW50SWQsXG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzXG5jb25zdCB7IEFQUFMsIEFDVElPTlMgfSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcblxuZXhwb3J0cy5BQ1RJT05TID0gQUNUSU9OUztcbmV4cG9ydHMuQVBQUyA9IEFQUFM7XG5leHBvcnRzLkNPTVBPU0lPX1NES19FUlJPUl9DT0RFUyA9IENPTVBPU0lPX1NES19FUlJPUl9DT0RFUztcbmV4cG9ydHMuQ2xvdWRmbGFyZVRvb2xTZXQgPSBDbG91ZGZsYXJlVG9vbFNldDtcbmV4cG9ydHMuQ29tcG9zaW8gPSBDb21wb3NpbztcbmV4cG9ydHMuQ29tcG9zaW9FcnJvciA9IENvbXBvc2lvRXJyb3I7XG5leHBvcnRzLkNvbXBvc2lvVG9vbFNldCA9IENvbXBvc2lvVG9vbFNldDtcbmV4cG9ydHMuQ29ubmVjdGlvblJlcXVlc3QgPSBDb25uZWN0aW9uUmVxdWVzdDtcbmV4cG9ydHMuTGFuZ0dyYXBoVG9vbFNldCA9IExhbmdHcmFwaFRvb2xTZXQ7XG5leHBvcnRzLkxhbmdjaGFpblRvb2xTZXQgPSBMYW5nY2hhaW5Ub29sU2V0O1xuZXhwb3J0cy5PcGVuQUlUb29sU2V0ID0gT3BlbkFJVG9vbFNldDtcbmV4cG9ydHMuVmVyY2VsQUlUb29sU2V0ID0gVmVyY2VsQUlUb29sU2V0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/composio-core/index.js\n");

/***/ })

};
;